{"id": "algebra_poly_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `polynomial?`\nSpec: (polynomial? p) -> Boolean - Check if p is a polynomial (tagged list)\n\nWrite exactly one Scheme definition for `polynomial?`.\nReturn only code, no explanation.", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "polynomial?"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `polynomial?`\nSpec: (polynomial? p) -> Boolean - Check if p is a polynomial (tagged list)\n\nWrite exactly one Scheme definition for `polynomial?`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (polynomial? p)\n  ;; TODO: Check if p is tagged as 'polynomial\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `polynomial?`.", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "polynomial?"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (polynomial? p)\n  ;; TODO: Check if p is tagged as 'polynomial\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `polynomial?`."}
{"id": "algebra_poly_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Implement `polynomial?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (polynomial? p) -> Boolean - Check if p is a polynomial (tagged list)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "polynomial?"], "split": "train", "prompt": "Implement `polynomial?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (polynomial? p) -> Boolean - Check if p is a polynomial (tagged list)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-field`\nSpec: (poly-field p) -> Field - Get the coefficient field of a polynomial\n\nWrite exactly one Scheme definition for `poly-field`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-field"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-field`\nSpec: (poly-field p) -> Field - Get the coefficient field of a polynomial\n\nWrite exactly one Scheme definition for `poly-field`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-field p)\n  ;; TODO: Extract field from polynomial structure\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-field`.", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-field"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-field p)\n  ;; TODO: Extract field from polynomial structure\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-field`."}
{"id": "algebra_poly_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Implement `poly-field` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-field p) -> Field - Get the coefficient field of a polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-field"], "split": "train", "prompt": "Implement `poly-field` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-field p) -> Field - Get the coefficient field of a polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-coeffs`\nSpec: (poly-coeffs p) -> (List Coeff) - Get coefficient list in ascending power order\n\nWrite exactly one Scheme definition for `poly-coeffs`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-coeffs p)\n  (doc 'export #t)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-coeffs"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-coeffs`\nSpec: (poly-coeffs p) -> (List Coeff) - Get coefficient list in ascending power order\n\nWrite exactly one Scheme definition for `poly-coeffs`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-coeffs p)\n  ;; TODO: Extract coefficient list from polynomial\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-coeffs`.", "ground_truth": "(define (poly-coeffs p)\n  (doc 'export #t)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-coeffs"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-coeffs p)\n  ;; TODO: Extract coefficient list from polynomial\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-coeffs`."}
{"id": "algebra_poly_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Implement `poly-coeffs` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-coeffs p) -> (List Coeff) - Get coefficient list in ascending power order\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-coeffs p)\n  (doc 'export #t)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-coeffs"], "split": "train", "prompt": "Implement `poly-coeffs` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-coeffs p) -> (List Coeff) - Get coefficient list in ascending power order\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-degree`\nSpec: (poly-degree p) -> Nat - Degree of polynomial (length-1). Zero polynomial has degree -1.\n\nWrite exactly one Scheme definition for `poly-degree`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-degree"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-degree`\nSpec: (poly-degree p) -> Nat - Degree of polynomial (length-1). Zero polynomial has degree -1.\n\nWrite exactly one Scheme definition for `poly-degree`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-degree p)\n  ;; TODO: Compute degree from coefficient list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-degree`.", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-degree"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-degree p)\n  ;; TODO: Compute degree from coefficient list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-degree`."}
{"id": "algebra_poly_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Implement `poly-degree` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-degree p) -> Nat - Degree of polynomial (length-1). Zero polynomial has degree -1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-degree"], "split": "train", "prompt": "Implement `poly-degree` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-degree p) -> Nat - Degree of polynomial (length-1). Zero polynomial has degree -1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-leading-coeff`\nSpec: (poly-leading-coeff p) -> Coeff - Get leading (highest-degree) coefficient\n\nWrite exactly one Scheme definition for `poly-leading-coeff`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-leading-coeff"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-leading-coeff`\nSpec: (poly-leading-coeff p) -> Coeff - Get leading (highest-degree) coefficient\n\nWrite exactly one Scheme definition for `poly-leading-coeff`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-leading-coeff p)\n  ;; TODO: Get last coefficient from list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-leading-coeff`.", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-leading-coeff"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-leading-coeff p)\n  ;; TODO: Get last coefficient from list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-leading-coeff`."}
{"id": "algebra_poly_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Implement `poly-leading-coeff` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-leading-coeff p) -> Coeff - Get leading (highest-degree) coefficient\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-leading-coeff"], "split": "train", "prompt": "Implement `poly-leading-coeff` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-leading-coeff p) -> Coeff - Get leading (highest-degree) coefficient\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-coeff-at`\nSpec: (poly-coeff-at p k) -> Coeff - Get coefficient of x^k\n\nWrite exactly one Scheme definition for `poly-coeff-at`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-coeff-at"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-coeff-at`\nSpec: (poly-coeff-at p k) -> Coeff - Get coefficient of x^k\n\nWrite exactly one Scheme definition for `poly-coeff-at`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-coeff-at p k)\n  ;; TODO: Get k-th coefficient or zero if out of bounds\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-coeff-at`.", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-coeff-at"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-coeff-at p k)\n  ;; TODO: Get k-th coefficient or zero if out of bounds\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-coeff-at`."}
{"id": "algebra_poly_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Implement `poly-coeff-at` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-coeff-at p k) -> Coeff - Get coefficient of x^k\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-coeff-at"], "split": "train", "prompt": "Implement `poly-coeff-at` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-coeff-at p k) -> Coeff - Get coefficient of x^k\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-zero?`\nSpec: (poly-zero? p) -> Boolean - Check if polynomial is the zero polynomial\n\nWrite exactly one Scheme definition for `poly-zero?`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-zero?"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-zero?`\nSpec: (poly-zero? p) -> Boolean - Check if polynomial is the zero polynomial\n\nWrite exactly one Scheme definition for `poly-zero?`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-zero? p)\n  ;; TODO: Check if polynomial has single zero coefficient\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-zero?`.", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-zero?"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-zero? p)\n  ;; TODO: Check if polynomial has single zero coefficient\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-zero?`."}
{"id": "algebra_poly_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Implement `poly-zero?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-zero? p) -> Boolean - Check if polynomial is the zero polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-zero?"], "split": "train", "prompt": "Implement `poly-zero?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-zero? p) -> Boolean - Check if polynomial is the zero polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `make-polynomial`\nSpec: (make-polynomial field coeffs) -> Polynomial - Create a polynomial over field F with given coefficients. Automatically normalizes.\n\nWrite exactly one Scheme definition for `make-polynomial`.\nReturn only code, no explanation.", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "make-polynomial"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `make-polynomial`\nSpec: (make-polynomial field coeffs) -> Polynomial - Create a polynomial over field F with given coefficients. Automatically normalizes.\n\nWrite exactly one Scheme definition for `make-polynomial`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-polynomial field coeffs)\n  ;; TODO: Create polynomial tagged list with normalized coeffs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-polynomial`.", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "make-polynomial"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-polynomial field coeffs)\n  ;; TODO: Create polynomial tagged list with normalized coeffs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-polynomial`."}
{"id": "algebra_poly_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Implement `make-polynomial` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (make-polynomial field coeffs) -> Polynomial - Create a polynomial over field F with given coefficients. Automatically normalizes.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "make-polynomial"], "split": "train", "prompt": "Implement `make-polynomial` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (make-polynomial field coeffs) -> Polynomial - Create a polynomial over field F with given coefficients. Automatically normalizes.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-zero-over`\nSpec: (poly-zero-over field) -> Polynomial - The zero polynomial over field F\n\nWrite exactly one Scheme definition for `poly-zero-over`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-zero-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-zero-over"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-zero-over`\nSpec: (poly-zero-over field) -> Polynomial - The zero polynomial over field F\n\nWrite exactly one Scheme definition for `poly-zero-over`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-zero-over field)\n  ;; TODO: Create zero polynomial over field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-zero-over`.", "ground_truth": "(define (poly-zero-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-zero-over"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-zero-over field)\n  ;; TODO: Create zero polynomial over field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-zero-over`."}
{"id": "algebra_poly_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Implement `poly-zero-over` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-zero-over field) -> Polynomial - The zero polynomial over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-zero-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-zero-over"], "split": "train", "prompt": "Implement `poly-zero-over` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-zero-over field) -> Polynomial - The zero polynomial over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-one-over`\nSpec: (poly-one-over field) -> Polynomial - The constant polynomial 1 over field F\n\nWrite exactly one Scheme definition for `poly-one-over`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-one-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-one-over"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-one-over`\nSpec: (poly-one-over field) -> Polynomial - The constant polynomial 1 over field F\n\nWrite exactly one Scheme definition for `poly-one-over`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-one-over field)\n  ;; TODO: Create constant 1 polynomial over field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-one-over`.", "ground_truth": "(define (poly-one-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-one-over"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-one-over field)\n  ;; TODO: Create constant 1 polynomial over field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-one-over`."}
{"id": "algebra_poly_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Implement `poly-one-over` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-one-over field) -> Polynomial - The constant polynomial 1 over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-one-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-one-over"], "split": "train", "prompt": "Implement `poly-one-over` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-one-over field) -> Polynomial - The constant polynomial 1 over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-constant`\nSpec: (poly-constant field c) -> Polynomial - Create constant polynomial from coefficient c\n\nWrite exactly one Scheme definition for `poly-constant`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-constant field c)\n  (doc 'export #t)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-constant"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-constant`\nSpec: (poly-constant field c) -> Polynomial - Create constant polynomial from coefficient c\n\nWrite exactly one Scheme definition for `poly-constant`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-constant field c)\n  ;; TODO: Create constant polynomial from value c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-constant`.", "ground_truth": "(define (poly-constant field c)\n  (doc 'export #t)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-constant"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-constant field c)\n  ;; TODO: Create constant polynomial from value c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-constant`."}
{"id": "algebra_poly_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Implement `poly-constant` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-constant field c) -> Polynomial - Create constant polynomial from coefficient c\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-constant field c)\n  (doc 'export #t)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-constant"], "split": "train", "prompt": "Implement `poly-constant` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-constant field c) -> Polynomial - Create constant polynomial from coefficient c\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-monomial`\nSpec: (poly-monomial field coeff degree) -> Polynomial - Create monomial c*x^n\n\nWrite exactly one Scheme definition for `poly-monomial`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-monomial"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-monomial`\nSpec: (poly-monomial field coeff degree) -> Polynomial - Create monomial c*x^n\n\nWrite exactly one Scheme definition for `poly-monomial`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_035", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-monomial field coeff degree)\n  ;; TODO: Create c*x^n with leading zeros\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-monomial`.", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-monomial"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-monomial field coeff degree)\n  ;; TODO: Create c*x^n with leading zeros\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-monomial`."}
{"id": "algebra_poly_spec_to_code_036", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Implement `poly-monomial` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-monomial field coeff degree) -> Polynomial - Create monomial c*x^n\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-monomial"], "split": "train", "prompt": "Implement `poly-monomial` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-monomial field coeff degree) -> Polynomial - Create monomial c*x^n\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_037", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-x`\nSpec: (poly-x field) -> Polynomial - The polynomial x (the indeterminate) over field F\n\nWrite exactly one Scheme definition for `poly-x`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-x"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-x`\nSpec: (poly-x field) -> Polynomial - The polynomial x (the indeterminate) over field F\n\nWrite exactly one Scheme definition for `poly-x`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_038", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-x field)\n  ;; TODO: Create polynomial representing the indeterminate x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-x`.", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-x"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-x field)\n  ;; TODO: Create polynomial representing the indeterminate x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-x`."}
{"id": "algebra_poly_spec_to_code_039", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Implement `poly-x` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-x field) -> Polynomial - The polynomial x (the indeterminate) over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-x"], "split": "train", "prompt": "Implement `poly-x` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-x field) -> Polynomial - The polynomial x (the indeterminate) over field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_040", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-add`\nSpec: (poly-add p1 p2) -> Polynomial - Add two polynomials over the same field\n\nWrite exactly one Scheme definition for `poly-add`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-add"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-add`\nSpec: (poly-add p1 p2) -> Polynomial - Add two polynomials over the same field\n\nWrite exactly one Scheme definition for `poly-add`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_041", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-add p1 p2)\n  ;; TODO: Add coefficients pairwise using field addition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-add`.", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-add"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-add p1 p2)\n  ;; TODO: Add coefficients pairwise using field addition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-add`."}
{"id": "algebra_poly_spec_to_code_042", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Implement `poly-add` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-add p1 p2) -> Polynomial - Add two polynomials over the same field\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-add"], "split": "train", "prompt": "Implement `poly-add` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-add p1 p2) -> Polynomial - Add two polynomials over the same field\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_043", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-neg`\nSpec: (poly-neg p) -> Polynomial - Negate a polynomial\n\nWrite exactly one Scheme definition for `poly-neg`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-neg"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-neg`\nSpec: (poly-neg p) -> Polynomial - Negate a polynomial\n\nWrite exactly one Scheme definition for `poly-neg`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_044", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-neg p)\n  ;; TODO: Negate each coefficient using field negation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-neg`.", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-neg"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-neg p)\n  ;; TODO: Negate each coefficient using field negation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-neg`."}
{"id": "algebra_poly_spec_to_code_045", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Implement `poly-neg` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-neg p) -> Polynomial - Negate a polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-neg"], "split": "train", "prompt": "Implement `poly-neg` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-neg p) -> Polynomial - Negate a polynomial\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-sub`\nSpec: (poly-sub p1 p2) -> Polynomial - Subtract polynomials (p1 - p2)\n\nWrite exactly one Scheme definition for `poly-sub`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-sub"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-sub`\nSpec: (poly-sub p1 p2) -> Polynomial - Subtract polynomials (p1 - p2)\n\nWrite exactly one Scheme definition for `poly-sub`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_047", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-sub p1 p2)\n  ;; TODO: Subtract by adding negation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-sub`.", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-sub"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-sub p1 p2)\n  ;; TODO: Subtract by adding negation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-sub`."}
{"id": "algebra_poly_spec_to_code_048", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Implement `poly-sub` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-sub p1 p2) -> Polynomial - Subtract polynomials (p1 - p2)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-sub"], "split": "train", "prompt": "Implement `poly-sub` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-sub p1 p2) -> Polynomial - Subtract polynomials (p1 - p2)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_049", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-scale`\nSpec: (poly-scale p c) -> Polynomial - Multiply polynomial by scalar c\n\nWrite exactly one Scheme definition for `poly-scale`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-scale"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-scale`\nSpec: (poly-scale p c) -> Polynomial - Multiply polynomial by scalar c\n\nWrite exactly one Scheme definition for `poly-scale`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_050", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-scale p c)\n  ;; TODO: Multiply each coefficient by scalar c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-scale`.", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-scale"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-scale p c)\n  ;; TODO: Multiply each coefficient by scalar c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-scale`."}
{"id": "algebra_poly_spec_to_code_051", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Implement `poly-scale` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-scale p c) -> Polynomial - Multiply polynomial by scalar c\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-scale"], "split": "train", "prompt": "Implement `poly-scale` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-scale p c) -> Polynomial - Multiply polynomial by scalar c\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_052", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-mul`\nSpec: (poly-mul p1 p2) -> Polynomial - Multiply two polynomials (convolution)\n\nWrite exactly one Scheme definition for `poly-mul`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-mul"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-mul`\nSpec: (poly-mul p1 p2) -> Polynomial - Multiply two polynomials (convolution)\n\nWrite exactly one Scheme definition for `poly-mul`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_053", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-mul p1 p2)\n  ;; TODO: Convolution of coefficient lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-mul`.", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-mul"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-mul p1 p2)\n  ;; TODO: Convolution of coefficient lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-mul`."}
{"id": "algebra_poly_spec_to_code_054", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Implement `poly-mul` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-mul p1 p2) -> Polynomial - Multiply two polynomials (convolution)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-mul"], "split": "train", "prompt": "Implement `poly-mul` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-mul p1 p2) -> Polynomial - Multiply two polynomials (convolution)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_055", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-power`\nSpec: (poly-power p n) -> Polynomial - Raise polynomial to power n using repeated squaring\n\nWrite exactly one Scheme definition for `poly-power`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-power"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-power`\nSpec: (poly-power p n) -> Polynomial - Raise polynomial to power n using repeated squaring\n\nWrite exactly one Scheme definition for `poly-power`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_056", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-power p n)\n  ;; TODO: Exponentiation by repeated squaring\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-power`.", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-power"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-power p n)\n  ;; TODO: Exponentiation by repeated squaring\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-power`."}
{"id": "algebra_poly_spec_to_code_057", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Implement `poly-power` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-power p n) -> Polynomial - Raise polynomial to power n using repeated squaring\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-power"], "split": "train", "prompt": "Implement `poly-power` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-power p n) -> Polynomial - Raise polynomial to power n using repeated squaring\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_058", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-equal?`\nSpec: (poly-equal? p1 p2) -> Boolean - Check if two polynomials are equal\n\nWrite exactly one Scheme definition for `poly-equal?`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-equal?"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-equal?`\nSpec: (poly-equal? p1 p2) -> Boolean - Check if two polynomials are equal\n\nWrite exactly one Scheme definition for `poly-equal?`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_059", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-equal? p1 p2)\n  ;; TODO: Compare coefficients using field equality\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-equal?`.", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-equal?"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-equal? p1 p2)\n  ;; TODO: Compare coefficients using field equality\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-equal?`."}
{"id": "algebra_poly_spec_to_code_060", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Implement `poly-equal?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-equal? p1 p2) -> Boolean - Check if two polynomials are equal\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-equal?"], "split": "train", "prompt": "Implement `poly-equal?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-equal? p1 p2) -> Boolean - Check if two polynomials are equal\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_061", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-divmod`\nSpec: (poly-divmod p1 p2) -> (Polynomial . Polynomial) - Division with remainder: p1 = q * p2 + r where deg(r) < deg(p2). Returns (quotient . remainder)\n\nWrite exactly one Scheme definition for `poly-divmod`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-divmod"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-divmod`\nSpec: (poly-divmod p1 p2) -> (Polynomial . Polynomial) - Division with remainder: p1 = q * p2 + r where deg(r) < deg(p2). Returns (quotient . remainder)\n\nWrite exactly one Scheme definition for `poly-divmod`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_062", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-divmod p1 p2)\n  ;; TODO: Polynomial long division, return (quotient . remainder)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-divmod`.", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-divmod"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-divmod p1 p2)\n  ;; TODO: Polynomial long division, return (quotient . remainder)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-divmod`."}
{"id": "algebra_poly_spec_to_code_063", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Implement `poly-divmod` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-divmod p1 p2) -> (Polynomial . Polynomial) - Division with remainder: p1 = q * p2 + r where deg(r) < deg(p2). Returns (quotient . remainder)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-divmod"], "split": "train", "prompt": "Implement `poly-divmod` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-divmod p1 p2) -> (Polynomial . Polynomial) - Division with remainder: p1 = q * p2 + r where deg(r) < deg(p2). Returns (quotient . remainder)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_064", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-div`\nSpec: (poly-div p1 p2) -> Polynomial - Get quotient of polynomial division\n\nWrite exactly one Scheme definition for `poly-div`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-div p1 p2)\n  (doc 'export #t)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-div"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-div`\nSpec: (poly-div p1 p2) -> Polynomial - Get quotient of polynomial division\n\nWrite exactly one Scheme definition for `poly-div`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_065", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-div p1 p2)\n  ;; TODO: Return quotient from divmod\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-div`.", "ground_truth": "(define (poly-div p1 p2)\n  (doc 'export #t)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-div"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-div p1 p2)\n  ;; TODO: Return quotient from divmod\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-div`."}
{"id": "algebra_poly_spec_to_code_066", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Implement `poly-div` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-div p1 p2) -> Polynomial - Get quotient of polynomial division\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-div p1 p2)\n  (doc 'export #t)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-div"], "split": "train", "prompt": "Implement `poly-div` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-div p1 p2) -> Polynomial - Get quotient of polynomial division\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_067", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-mod`\nSpec: (poly-mod p1 p2) -> Polynomial - Get remainder of polynomial division\n\nWrite exactly one Scheme definition for `poly-mod`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-mod p1 p2)\n  (doc 'export #t)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-mod"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-mod`\nSpec: (poly-mod p1 p2) -> Polynomial - Get remainder of polynomial division\n\nWrite exactly one Scheme definition for `poly-mod`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_068", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-mod p1 p2)\n  ;; TODO: Return remainder from divmod\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-mod`.", "ground_truth": "(define (poly-mod p1 p2)\n  (doc 'export #t)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-mod"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-mod p1 p2)\n  ;; TODO: Return remainder from divmod\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-mod`."}
{"id": "algebra_poly_spec_to_code_069", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Implement `poly-mod` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-mod p1 p2) -> Polynomial - Get remainder of polynomial division\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-mod p1 p2)\n  (doc 'export #t)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-mod"], "split": "train", "prompt": "Implement `poly-mod` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-mod p1 p2) -> Polynomial - Get remainder of polynomial division\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_070", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-divides?`\nSpec: (poly-divides? p1 p2) -> Boolean - Check if p1 divides p2 (p2 = q * p1 for some q)\n\nWrite exactly one Scheme definition for `poly-divides?`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-divides?"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-divides?`\nSpec: (poly-divides? p1 p2) -> Boolean - Check if p1 divides p2 (p2 = q * p1 for some q)\n\nWrite exactly one Scheme definition for `poly-divides?`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_071", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-divides? p1 p2)\n  ;; TODO: Check if remainder of p2/p1 is zero\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-divides?`.", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-divides?"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-divides? p1 p2)\n  ;; TODO: Check if remainder of p2/p1 is zero\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-divides?`."}
{"id": "algebra_poly_spec_to_code_072", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Implement `poly-divides?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-divides? p1 p2) -> Boolean - Check if p1 divides p2 (p2 = q * p1 for some q)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-divides?"], "split": "train", "prompt": "Implement `poly-divides?` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-divides? p1 p2) -> Boolean - Check if p1 divides p2 (p2 = q * p1 for some q)\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_073", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-gcd`\nSpec: (poly-gcd p1 p2) -> Polynomial - Compute GCD using Euclidean algorithm. Returns monic GCD.\n\nWrite exactly one Scheme definition for `poly-gcd`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-gcd"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-gcd`\nSpec: (poly-gcd p1 p2) -> Polynomial - Compute GCD using Euclidean algorithm. Returns monic GCD.\n\nWrite exactly one Scheme definition for `poly-gcd`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_074", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-gcd p1 p2)\n  ;; TODO: Euclidean algorithm, return monic GCD\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-gcd`.", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-gcd"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-gcd p1 p2)\n  ;; TODO: Euclidean algorithm, return monic GCD\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-gcd`."}
{"id": "algebra_poly_spec_to_code_075", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Implement `poly-gcd` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-gcd p1 p2) -> Polynomial - Compute GCD using Euclidean algorithm. Returns monic GCD.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-gcd"], "split": "train", "prompt": "Implement `poly-gcd` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-gcd p1 p2) -> Polynomial - Compute GCD using Euclidean algorithm. Returns monic GCD.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_082", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-lcm`\nSpec: (poly-lcm p1 p2) -> Polynomial - Least common multiple of polynomials\n\nWrite exactly one Scheme definition for `poly-lcm`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-lcm"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-lcm`\nSpec: (poly-lcm p1 p2) -> Polynomial - Least common multiple of polynomials\n\nWrite exactly one Scheme definition for `poly-lcm`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_083", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-lcm p1 p2)\n  ;; TODO: LCM = (p1 * p2) / GCD(p1, p2)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-lcm`.", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-lcm"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-lcm p1 p2)\n  ;; TODO: LCM = (p1 * p2) / GCD(p1, p2)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-lcm`."}
{"id": "algebra_poly_spec_to_code_084", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Implement `poly-lcm` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-lcm p1 p2) -> Polynomial - Least common multiple of polynomials\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-lcm"], "split": "train", "prompt": "Implement `poly-lcm` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-lcm p1 p2) -> Polynomial - Least common multiple of polynomials\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_085", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-eval`\nSpec: (poly-eval p x) -> Coeff - Evaluate polynomial at point using Horner's method\n\nWrite exactly one Scheme definition for `poly-eval`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-eval"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-eval`\nSpec: (poly-eval p x) -> Coeff - Evaluate polynomial at point using Horner's method\n\nWrite exactly one Scheme definition for `poly-eval`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_086", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-eval p x)\n  ;; TODO: Evaluate using Horner's method\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-eval`.", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-eval"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-eval p x)\n  ;; TODO: Evaluate using Horner's method\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-eval`."}
{"id": "algebra_poly_spec_to_code_087", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Implement `poly-eval` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-eval p x) -> Coeff - Evaluate polynomial at point using Horner's method\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-eval"], "split": "train", "prompt": "Implement `poly-eval` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-eval p x) -> Coeff - Evaluate polynomial at point using Horner's method\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_088", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-derivative`\nSpec: (poly-derivative p) -> Polynomial - Formal derivative: d/dx (sum a_k x^k) = sum k*a_k x^{k-1}\n\nWrite exactly one Scheme definition for `poly-derivative`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-derivative"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-derivative`\nSpec: (poly-derivative p) -> Polynomial - Formal derivative: d/dx (sum a_k x^k) = sum k*a_k x^{k-1}\n\nWrite exactly one Scheme definition for `poly-derivative`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_089", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-derivative p)\n  ;; TODO: Formal derivative: multiply each coeff by its power\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-derivative`.", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-derivative"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-derivative p)\n  ;; TODO: Formal derivative: multiply each coeff by its power\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-derivative`."}
{"id": "algebra_poly_spec_to_code_090", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Implement `poly-derivative` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-derivative p) -> Polynomial - Formal derivative: d/dx (sum a_k x^k) = sum k*a_k x^{k-1}\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-derivative"], "split": "train", "prompt": "Implement `poly-derivative` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-derivative p) -> Polynomial - Formal derivative: d/dx (sum a_k x^k) = sum k*a_k x^{k-1}\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_094", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-square-free-factorization`\nSpec: (poly-square-free-factorization p) -> (List (Polynomial . Nat)) - Yun's algorithm for square-free factorization. Returns list of (factor . multiplicity) pairs.\n\nWrite exactly one Scheme definition for `poly-square-free-factorization`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-square-free-factorization p)\n  (doc 'export #t)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-square-free-factorization"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-square-free-factorization`\nSpec: (poly-square-free-factorization p) -> (List (Polynomial . Nat)) - Yun's algorithm for square-free factorization. Returns list of (factor . multiplicity) pairs.\n\nWrite exactly one Scheme definition for `poly-square-free-factorization`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_095", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-square-free-factorization p)\n  ;; TODO: Yun's algorithm for square-free factorization\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-square-free-factorization`.", "ground_truth": "(define (poly-square-free-factorization p)\n  (doc 'export #t)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-square-free-factorization"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-square-free-factorization p)\n  ;; TODO: Yun's algorithm for square-free factorization\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-square-free-factorization`."}
{"id": "algebra_poly_spec_to_code_096", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Implement `poly-square-free-factorization` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-square-free-factorization p) -> (List (Polynomial . Nat)) - Yun's algorithm for square-free factorization. Returns list of (factor . multiplicity) pairs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-square-free-factorization p)\n  (doc 'export #t)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-square-free-factorization"], "split": "train", "prompt": "Implement `poly-square-free-factorization` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-square-free-factorization p) -> (List (Polynomial . Nat)) - Yun's algorithm for square-free factorization. Returns list of (factor . multiplicity) pairs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_103", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly->string`\nSpec: (poly->string p [var]) -> String - Pretty-print polynomial. Optional variable name (default 'x).\n\nWrite exactly one Scheme definition for `poly->string`.\nReturn only code, no explanation.", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly->string"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly->string`\nSpec: (poly->string p [var]) -> String - Pretty-print polynomial. Optional variable name (default 'x).\n\nWrite exactly one Scheme definition for `poly->string`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_104", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly->string p . opts)\n  ;; TODO: Pretty-print polynomial with variable name\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly->string`.", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly->string"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly->string p . opts)\n  ;; TODO: Pretty-print polynomial with variable name\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly->string`."}
{"id": "algebra_poly_spec_to_code_105", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Implement `poly->string` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly->string p [var]) -> String - Pretty-print polynomial. Optional variable name (default 'x).\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly->string"], "split": "train", "prompt": "Implement `poly->string` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly->string p [var]) -> String - Pretty-print polynomial. Optional variable name (default 'x).\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_109", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-ring`\nSpec: (poly-ring p) -> Field - Alias for poly-field for backwards compatibility\n\nWrite exactly one Scheme definition for `poly-ring`.\nReturn only code, no explanation.", "ground_truth": "(doc poly-ring 'export #t)\n(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-ring"], "split": "train", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-ring`\nSpec: (poly-ring p) -> Field - Alias for poly-field for backwards compatibility\n\nWrite exactly one Scheme definition for `poly-ring`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_110", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-ring p)\n  ;; TODO: Alias for poly-field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-ring`.", "ground_truth": "(doc poly-ring 'export #t)\n(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-ring"], "split": "train", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-ring p)\n  ;; TODO: Alias for poly-field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-ring`."}
{"id": "algebra_poly_spec_to_code_111", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Implement `poly-ring` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-ring p) -> Field - Alias for poly-field for backwards compatibility\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(doc poly-ring 'export #t)\n(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-ring"], "split": "train", "prompt": "Implement `poly-ring` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-ring p) -> Field - Alias for poly-field for backwards compatibility\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `polynomial?`.\nReturn only the Scheme definition.\n\n```python\ndef is_polynomial(p):\n    return isinstance(p, list) and len(p) > 0 and p[0] == 'polynomial'\n```", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "polynomial?"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `polynomial?`.\nReturn only the Scheme definition.\n\n```python\ndef is_polynomial(p):\n    return isinstance(p, list) and len(p) > 0 and p[0] == 'polynomial'\n```"}
{"id": "algebra_poly_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `polynomial?`.\nReturn only the final Fold definition.\n\n```scheme\n(define polynomial?\n  (lambda (p)\n    (if (pair? p)\n        (eq? (car p) 'polynomial)\n        #f)))\n```", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "polynomial?"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `polynomial?`.\nReturn only the final Fold definition.\n\n```scheme\n(define polynomial?\n  (lambda (p)\n    (if (pair? p)\n        (eq? (car p) 'polynomial)\n        #f)))\n```"}
{"id": "algebra_poly_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `polynomial?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'predicates)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define polynomial?\n    (lambda (p)\n      (if (pair? p)\n          (eq? (car p) 'polynomial)\n          #f)))\n\n```", "ground_truth": "(define (polynomial? p)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "polynomial?"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `polynomial?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'predicates)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define polynomial?\n    (lambda (p)\n      (if (pair? p)\n          (eq? (car p) 'polynomial)\n          #f)))\n\n```"}
{"id": "algebra_poly_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-field`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_field(p):\n    return p[1]\n```", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-field"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-field`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_field(p):\n    return p[1]\n```"}
{"id": "algebra_poly_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-field`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-field\n  (lambda (p)\n    (cadr p)))\n```", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-field"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-field`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-field\n  (lambda (p)\n    (cadr p)))\n```"}
{"id": "algebra_poly_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-field`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-field\n    (lambda (p)\n      (cadr p)))\n\n```", "ground_truth": "(define (poly-field p)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-field"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-field`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-field\n    (lambda (p)\n      (cadr p)))\n\n```"}
{"id": "algebra_poly_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-coeffs`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_coeffs(p):\n    return p[2]\n```", "ground_truth": "(define (poly-coeffs p)\n  (doc 'export #t)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-coeffs"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-coeffs`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_coeffs(p):\n    return p[2]\n```"}
{"id": "algebra_poly_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-coeffs`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-coeffs\n  (lambda (p)\n    (caddr p)))\n```", "ground_truth": "(define (poly-coeffs p)\n  (doc 'export #t)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-coeffs"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-coeffs`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-coeffs\n  (lambda (p)\n    (caddr p)))\n```"}
{"id": "algebra_poly_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeffs", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-coeffs`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-coeffs\n    (lambda (p)\n      (caddr p)))\n\n```", "ground_truth": "(define (poly-coeffs p)\n  (caddr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (equal? (poly-coeffs p) '(1 2 3)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-coeffs"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-coeffs`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-coeffs\n    (lambda (p)\n      (caddr p)))\n\n```"}
{"id": "algebra_poly_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-degree`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_degree(p):\n    coeffs = polynomial_coeffs(p)\n    return len(coeffs) - 1\n```", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-degree"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-degree`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_degree(p):\n    coeffs = polynomial_coeffs(p)\n    return len(coeffs) - 1\n```"}
{"id": "algebra_poly_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-degree`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-degree\n  (lambda (p)\n    (let ([cs (poly-coeffs p)])\n      (- (length cs) 1))))\n```", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-degree"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-degree`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-degree\n  (lambda (p)\n    (let ([cs (poly-coeffs p)])\n      (- (length cs) 1))))\n```"}
{"id": "algebra_poly_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-degree`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-degree\n    (lambda (p)\n      (let ([cs (poly-coeffs p)])\n        (- (length cs) 1))))\n\n```", "ground_truth": "(define (poly-degree p)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-degree"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-degree`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-degree\n    (lambda (p)\n      (let ([cs (poly-coeffs p)])\n        (- (length cs) 1))))\n\n```"}
{"id": "algebra_poly_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-leading-coeff`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_leading_coeff(p):\n    coeffs = polynomial_coeffs(p)\n    return coeffs[-1] if coeffs else field_zero(polynomial_field(p))\n```", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-leading-coeff"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-leading-coeff`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_leading_coeff(p):\n    coeffs = polynomial_coeffs(p)\n    return coeffs[-1] if coeffs else field_zero(polynomial_field(p))\n```"}
{"id": "algebra_poly_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-leading-coeff`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-leading-coeff\n  (lambda (p)\n    (let ([cs (poly-coeffs p)])\n      (cond\n        [(null? cs) (field-zero (poly-field p))]\n        [else (list-ref cs (- (length cs) 1))]))))\n```", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-leading-coeff"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-leading-coeff`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-leading-coeff\n  (lambda (p)\n    (let ([cs (poly-coeffs p)])\n      (cond\n        [(null? cs) (field-zero (poly-field p))]\n        [else (list-ref cs (- (length cs) 1))]))))\n```"}
{"id": "algebra_poly_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-leading-coeff`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-leading-coeff\n    (lambda (p)\n      (let ([cs (poly-coeffs p)])\n        (cond\n          [(null? cs) (field-zero (poly-field p))]\n          [else (list-ref cs (- (length cs) 1))]))))\n\n```", "ground_truth": "(define (poly-leading-coeff p)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-leading-coeff"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-leading-coeff`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-leading-coeff\n    (lambda (p)\n      (let ([cs (poly-coeffs p)])\n        (cond\n          [(null? cs) (field-zero (poly-field p))]\n          [else (list-ref cs (- (length cs) 1))]))))\n\n```"}
{"id": "algebra_poly_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-coeff-at`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_coeff_at(p, k):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    return coeffs[k] if k < len(coeffs) else field_zero(F)\n```", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-coeff-at"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-coeff-at`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_coeff_at(p, k):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    return coeffs[k] if k < len(coeffs) else field_zero(F)\n```"}
{"id": "algebra_poly_translation_017", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-coeff-at`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-coeff-at\n  (lambda (p k)\n    (let ([cs (poly-coeffs p)] [F (poly-field p)])\n      (cond\n        [(>= k (length cs)) (field-zero F)]\n        [else (list-ref cs k)])))))\n```", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-coeff-at"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-coeff-at`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-coeff-at\n  (lambda (p k)\n    (let ([cs (poly-coeffs p)] [F (poly-field p)])\n      (cond\n        [(>= k (length cs)) (field-zero F)]\n        [else (list-ref cs k)])))))\n```"}
{"id": "algebra_poly_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-coeff-at`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-coeff-at\n    (lambda (p k)\n      (let ([cs (poly-coeffs p)] [F (poly-field p)])\n        (cond\n          [(>= k (length cs)) (field-zero F)]\n          [else (list-ref cs k)])))))\n\n```", "ground_truth": "(define (poly-coeff-at p k)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-coeff-at"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-coeff-at`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'accessors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-coeff-at\n    (lambda (p k)\n      (let ([cs (poly-coeffs p)] [F (poly-field p)])\n        (cond\n          [(>= k (length cs)) (field-zero F)]\n          [else (list-ref cs k)])))))\n\n```"}
{"id": "algebra_poly_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-zero?`.\nReturn only the Scheme definition.\n\n```python\ndef is_zero_polynomial(p):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    return len(coeffs) == 1 and field_equal(F, coeffs[0], field_zero(F))\n```", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-zero?"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-zero?`.\nReturn only the Scheme definition.\n\n```python\ndef is_zero_polynomial(p):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    return len(coeffs) == 1 and field_equal(F, coeffs[0], field_zero(F))\n```"}
{"id": "algebra_poly_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-zero?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-zero?\n  (lambda (p)\n    (let ([F (poly-field p)] [cs (poly-coeffs p)])\n      (and (= (length cs) 1)\n           ((field-equal-fn F) (car cs) (field-zero F))))))\n```", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-zero?"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-zero?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-zero?\n  (lambda (p)\n    (let ([F (poly-field p)] [cs (poly-coeffs p)])\n      (and (= (length cs) 1)\n           ((field-equal-fn F) (car cs) (field-zero F))))))\n```"}
{"id": "algebra_poly_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-zero?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'predicates)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-zero?\n    (lambda (p)\n      (let ([F (poly-field p)] [cs (poly-coeffs p)])\n        (and (= (length cs) 1)\n             ((field-equal-fn F) (car cs) (field-zero F))))))\n\n```", "ground_truth": "(define (poly-zero? p)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-zero?"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-zero?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'predicates)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-zero?\n    (lambda (p)\n      (let ([F (poly-field p)] [cs (poly-coeffs p)])\n        (and (= (length cs) 1)\n             ((field-equal-fn F) (car cs) (field-zero F))))))\n\n```"}
{"id": "algebra_poly_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-polynomial`.\nReturn only the Scheme definition.\n\n```python\ndef make_polynomial(field, coeffs):\n    # Normalize by stripping trailing zeros\n    while len(coeffs) > 1 and field_equal(field, coeffs[-1], field_zero(field)):\n        coeffs = coeffs[:-1]\n    return ['polynomial', field, coeffs]\n```", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "make-polynomial"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-polynomial`.\nReturn only the Scheme definition.\n\n```python\ndef make_polynomial(field, coeffs):\n    # Normalize by stripping trailing zeros\n    while len(coeffs) > 1 and field_equal(field, coeffs[-1], field_zero(field)):\n        coeffs = coeffs[:-1]\n    return ['polynomial', field, coeffs]\n```"}
{"id": "algebra_poly_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-polynomial`.\nReturn only the final Fold definition.\n\n```scheme\n(define make-polynomial\n  (lambda (fld coeffs)\n    (list 'polynomial fld (poly-normalize-coeffs fld coeffs))))\n```", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "make-polynomial"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-polynomial`.\nReturn only the final Fold definition.\n\n```scheme\n(define make-polynomial\n  (lambda (fld coeffs)\n    (list 'polynomial fld (poly-normalize-coeffs fld coeffs))))\n```"}
{"id": "algebra_poly_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-polynomial`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define make-polynomial\n    (lambda (fld coeffs)\n      (list 'polynomial fld (poly-normalize-coeffs fld coeffs))))\n\n```", "ground_truth": "(define (make-polynomial field coeffs)\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "make-polynomial"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-polynomial`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define make-polynomial\n    (lambda (fld coeffs)\n      (list 'polynomial fld (poly-normalize-coeffs fld coeffs))))\n\n```"}
{"id": "algebra_poly_translation_025", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-zero-over`.\nReturn only the Scheme definition.\n\n```python\ndef zero_polynomial_over(field):\n    return make_polynomial(field, [field_zero(field)])\n```", "ground_truth": "(define (poly-zero-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-zero-over"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-zero-over`.\nReturn only the Scheme definition.\n\n```python\ndef zero_polynomial_over(field):\n    return make_polynomial(field, [field_zero(field)])\n```"}
{"id": "algebra_poly_translation_026", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-zero-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-zero-over\n  (lambda (fld)\n    (make-polynomial fld (list (field-zero fld)))))\n```", "ground_truth": "(define (poly-zero-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-zero-over"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-zero-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-zero-over\n  (lambda (fld)\n    (make-polynomial fld (list (field-zero fld)))))\n```"}
{"id": "algebra_poly_translation_027", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero-over", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-zero-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-zero-over\n    (lambda (fld)\n      (make-polynomial fld (list (field-zero fld)))))\n\n```", "ground_truth": "(define (poly-zero-over field)\n  (make-polynomial field (list (field-zero field))))", "verify_expr": "(let ([z (poly-zero-over Q-field)]) (and (polynomial? z) (poly-zero? z) (= (poly-degree z) 0)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-zero-over"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-zero-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-zero-over\n    (lambda (fld)\n      (make-polynomial fld (list (field-zero fld)))))\n\n```"}
{"id": "algebra_poly_translation_028", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-one-over`.\nReturn only the Scheme definition.\n\n```python\ndef one_polynomial_over(field):\n    return make_polynomial(field, [field_one(field)])\n```", "ground_truth": "(define (poly-one-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-one-over"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-one-over`.\nReturn only the Scheme definition.\n\n```python\ndef one_polynomial_over(field):\n    return make_polynomial(field, [field_one(field)])\n```"}
{"id": "algebra_poly_translation_029", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-one-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-one-over\n  (lambda (fld)\n    (make-polynomial fld (list (field-one fld)))))\n```", "ground_truth": "(define (poly-one-over field)\n  (doc 'export #t)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-one-over"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-one-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-one-over\n  (lambda (fld)\n    (make-polynomial fld (list (field-one fld)))))\n```"}
{"id": "algebra_poly_translation_030", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-one-over", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-one-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-one-over\n    (lambda (fld)\n      (make-polynomial fld (list (field-one fld)))))\n\n```", "ground_truth": "(define (poly-one-over field)\n  (make-polynomial field (list (field-one field))))", "verify_expr": "(let ([one (poly-one-over Q-field)]) (and (polynomial? one) (= (poly-degree one) 0) (= (poly-leading-coeff one) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-one-over"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-one-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-one-over\n    (lambda (fld)\n      (make-polynomial fld (list (field-one fld)))))\n\n```"}
{"id": "algebra_poly_translation_031", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-constant`.\nReturn only the Scheme definition.\n\n```python\ndef constant_polynomial(field, c):\n    return make_polynomial(field, [c])\n```", "ground_truth": "(define (poly-constant field c)\n  (doc 'export #t)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-constant"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-constant`.\nReturn only the Scheme definition.\n\n```python\ndef constant_polynomial(field, c):\n    return make_polynomial(field, [c])\n```"}
{"id": "algebra_poly_translation_032", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-constant`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-constant\n  (lambda (fld c)\n    (make-polynomial fld (list c))))\n```", "ground_truth": "(define (poly-constant field c)\n  (doc 'export #t)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-constant"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-constant`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-constant\n  (lambda (fld c)\n    (make-polynomial fld (list c))))\n```"}
{"id": "algebra_poly_translation_033", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-constant", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-constant`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-constant\n    (lambda (fld c)\n      (make-polynomial fld (list c))))\n\n```", "ground_truth": "(define (poly-constant field c)\n  (make-polynomial field (list c)))", "verify_expr": "(let ([c (poly-constant Q-field 5)]) (and (= (poly-degree c) 0) (= (poly-leading-coeff c) 5)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-constant"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-constant`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-constant\n    (lambda (fld c)\n      (make-polynomial fld (list c))))\n\n```"}
{"id": "algebra_poly_translation_034", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-monomial`.\nReturn only the Scheme definition.\n\n```python\ndef monomial(field, coeff, degree):\n    zero = field_zero(field)\n    if field_equal(field, coeff, zero):\n        return zero_polynomial_over(field)\n    coeffs = [zero] * degree + [coeff]\n    return make_polynomial(field, coeffs)\n```", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-monomial"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-monomial`.\nReturn only the Scheme definition.\n\n```python\ndef monomial(field, coeff, degree):\n    zero = field_zero(field)\n    if field_equal(field, coeff, zero):\n        return zero_polynomial_over(field)\n    coeffs = [zero] * degree + [coeff]\n    return make_polynomial(field, coeffs)\n```"}
{"id": "algebra_poly_translation_035", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-monomial`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-monomial\n  (lambda (fld coeff deg)\n    (let ([z (field-zero fld)])\n      (if ((field-equal-fn fld) coeff z)\n          (poly-zero-over fld)\n          (make-polynomial fld\n            (append (make-list deg z) (list coeff)))))))\n```", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-monomial"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-monomial`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-monomial\n  (lambda (fld coeff deg)\n    (let ([z (field-zero fld)])\n      (if ((field-equal-fn fld) coeff z)\n          (poly-zero-over fld)\n          (make-polynomial fld\n            (append (make-list deg z) (list coeff)))))))\n```"}
{"id": "algebra_poly_translation_036", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-monomial`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-monomial\n    (lambda (fld coeff deg)\n      (let ([z (field-zero fld)])\n        (if ((field-equal-fn fld) coeff z)\n            (poly-zero-over fld)\n            (make-polynomial fld\n              (append (make-list deg z) (list coeff)))))))\n\n```", "ground_truth": "(define (poly-monomial field coeff degree)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-monomial"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-monomial`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-monomial\n    (lambda (fld coeff deg)\n      (let ([z (field-zero fld)])\n        (if ((field-equal-fn fld) coeff z)\n            (poly-zero-over fld)\n            (make-polynomial fld\n              (append (make-list deg z) (list coeff)))))))\n\n```"}
{"id": "algebra_poly_translation_037", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-x`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_x(field):\n    return monomial(field, field_one(field), 1)\n```", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-x"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-x`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_x(field):\n    return monomial(field, field_one(field), 1)\n```"}
{"id": "algebra_poly_translation_038", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-x`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-x\n  (lambda (fld)\n    (poly-monomial fld (field-one fld) 1)))\n```", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-x"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-x`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-x\n  (lambda (fld)\n    (poly-monomial fld (field-one fld) 1)))\n```"}
{"id": "algebra_poly_translation_039", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-x`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-x\n    (lambda (fld)\n      (poly-monomial fld (field-one fld) 1)))\n\n```", "ground_truth": "(define (poly-x field)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-x"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-x`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'constructors)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-x\n    (lambda (fld)\n      (poly-monomial fld (field-one fld) 1)))\n\n```"}
{"id": "algebra_poly_translation_040", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-add`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_add(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    result = []\n    for i in range(max(len(c1), len(c2))):\n        a = c1[i] if i < len(c1) else field_zero(F)\n        b = c2[i] if i < len(c2) else field_zero(F)\n        result.append(field_add(F, a, b))\n    return make_polynomial(F, result)\n```", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-add"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-add`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_add(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    result = []\n    for i in range(max(len(c1), len(c2))):\n        a = c1[i] if i < len(c1) else field_zero(F)\n        b = c2[i] if i < len(c2) else field_zero(F)\n        result.append(field_add(F, a, b))\n    return make_polynomial(F, result)\n```"}
{"id": "algebra_poly_translation_041", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-add`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-add\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)]\n           [plus (field-add-op F)])\n      (make-polynomial F (poly-add-coeffs plus as bs (field-zero F))))))\n```", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-add"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-add`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-add\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)]\n           [plus (field-add-op F)])\n      (make-polynomial F (poly-add-coeffs plus as bs (field-zero F))))))\n```"}
{"id": "algebra_poly_translation_042", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-add`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-add\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)]\n             [plus (field-add-op F)])\n        (make-polynomial F (poly-add-coeffs plus as bs (field-zero F))))))\n\n```", "ground_truth": "(define (poly-add p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-add"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-add`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-add\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)]\n             [plus (field-add-op F)])\n        (make-polynomial F (poly-add-coeffs plus as bs (field-zero F))))))\n\n```"}
{"id": "algebra_poly_translation_043", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-neg`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_neg(p):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    return make_polynomial(F, [field_neg(F, c) for c in coeffs])\n```", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-neg"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-neg`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_neg(p):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    return make_polynomial(F, [field_neg(F, c) for c in coeffs])\n```"}
{"id": "algebra_poly_translation_044", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-neg`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-neg\n  (lambda (p)\n    (let* ([F (poly-field p)]\n           [negate (field-neg-fn F)])\n      (make-polynomial F (map negate (poly-coeffs p))))))\n```", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-neg"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-neg`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-neg\n  (lambda (p)\n    (let* ([F (poly-field p)]\n           [negate (field-neg-fn F)])\n      (make-polynomial F (map negate (poly-coeffs p))))))\n```"}
{"id": "algebra_poly_translation_045", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-neg`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-neg\n    (lambda (p)\n      (let* ([F (poly-field p)]\n             [negate (field-neg-fn F)])\n        (make-polynomial F (map negate (poly-coeffs p))))))\n\n```", "ground_truth": "(define (poly-neg p)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-neg"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-neg`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-neg\n    (lambda (p)\n      (let* ([F (poly-field p)]\n             [negate (field-neg-fn F)])\n        (make-polynomial F (map negate (poly-coeffs p))))))\n\n```"}
{"id": "algebra_poly_translation_046", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-sub`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_sub(p1, p2):\n    return polynomial_add(p1, polynomial_neg(p2))\n```", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-sub"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-sub`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_sub(p1, p2):\n    return polynomial_add(p1, polynomial_neg(p2))\n```"}
{"id": "algebra_poly_translation_047", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-sub`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-sub\n  (lambda (a b)\n    (poly-add a (poly-neg b))))\n```", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-sub"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-sub`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-sub\n  (lambda (a b)\n    (poly-add a (poly-neg b))))\n```"}
{"id": "algebra_poly_translation_048", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-sub`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-sub\n    (lambda (a b)\n      (poly-add a (poly-neg b))))\n\n```", "ground_truth": "(define (poly-sub p1 p2)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-sub"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-sub`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-sub\n    (lambda (a b)\n      (poly-add a (poly-neg b))))\n\n```"}
{"id": "algebra_poly_translation_049", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-scale`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_scale(p, scalar):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    return make_polynomial(F, [field_mul(F, scalar, c) for c in coeffs])\n```", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-scale"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-scale`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_scale(p, scalar):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    return make_polynomial(F, [field_mul(F, scalar, c) for c in coeffs])\n```"}
{"id": "algebra_poly_translation_050", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-scale\n  (lambda (p scalar)\n    (let* ([F (poly-field p)]\n           [times (field-mul-op F)])\n      (make-polynomial F\n        (map (lambda (x) (times scalar x)) (poly-coeffs p))))))\n```", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-scale"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-scale\n  (lambda (p scalar)\n    (let* ([F (poly-field p)]\n           [times (field-mul-op F)])\n      (make-polynomial F\n        (map (lambda (x) (times scalar x)) (poly-coeffs p))))))\n```"}
{"id": "algebra_poly_translation_051", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-scale`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-scale\n    (lambda (p scalar)\n      (let* ([F (poly-field p)]\n             [times (field-mul-op F)])\n        (make-polynomial F\n          (map (lambda (x) (times scalar x)) (poly-coeffs p))))))\n\n```", "ground_truth": "(define (poly-scale p c)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-scale"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-scale`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-scale\n    (lambda (p scalar)\n      (let* ([F (poly-field p)]\n             [times (field-mul-op F)])\n        (make-polynomial F\n          (map (lambda (x) (times scalar x)) (poly-coeffs p))))))\n\n```"}
{"id": "algebra_poly_translation_052", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-mul`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_mul(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    if is_zero_polynomial(p1) or is_zero_polynomial(p2):\n        return zero_polynomial_over(F)\n    n = len(c1) + len(c2) - 1\n    result = [field_zero(F)] * n\n    for k in range(n):\n        s = field_zero(F)\n        for i in range(min(k + 1, len(c1))):\n            j = k - i\n            if j < len(c2):\n                s = field_add(F, s, field_mul(F, c1[i], c2[j]))\n        result[k] = s\n    return make_polynomial(F, result)\n```", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-mul"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-mul`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_mul(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    if is_zero_polynomial(p1) or is_zero_polynomial(p2):\n        return zero_polynomial_over(F)\n    n = len(c1) + len(c2) - 1\n    result = [field_zero(F)] * n\n    for k in range(n):\n        s = field_zero(F)\n        for i in range(min(k + 1, len(c1))):\n            j = k - i\n            if j < len(c2):\n                s = field_add(F, s, field_mul(F, c1[i], c2[j]))\n        result[k] = s\n    return make_polynomial(F, result)\n```"}
{"id": "algebra_poly_translation_053", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-mul`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-mul\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)]\n           [z (field-zero F)]\n           [plus (field-add-op F)]\n           [times (field-mul-op F)]\n           [n1 (length as)]\n           [n2 (length bs)]\n           [n (+ n1 n2 -1)])\n      (if (or (poly-zero? a) (poly-zero? b))\n          (poly-zero-over F)\n          (make-polynomial F\n            (let iterate ([k 0] [acc '()])\n              (if (= k n)\n                  (reverse acc)\n                  (iterate (+ k 1)\n                           (cons (poly-mul-coeff-at plus times as bs k n1 n2 z)\n                                 acc))))))))))\n```", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-mul"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-mul`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-mul\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)]\n           [z (field-zero F)]\n           [plus (field-add-op F)]\n           [times (field-mul-op F)]\n           [n1 (length as)]\n           [n2 (length bs)]\n           [n (+ n1 n2 -1)])\n      (if (or (poly-zero? a) (poly-zero? b))\n          (poly-zero-over F)\n          (make-polynomial F\n            (let iterate ([k 0] [acc '()])\n              (if (= k n)\n                  (reverse acc)\n                  (iterate (+ k 1)\n                           (cons (poly-mul-coeff-at plus times as bs k n1 n2 z)\n                                 acc))))))))))\n```"}
{"id": "algebra_poly_translation_054", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-mul`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-mul\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)]\n             [z (field-zero F)]\n             [plus (field-add-op F)]\n             [times (field-mul-op F)]\n             [n1 (length as)]\n             [n2 (length bs)]\n             [n (+ n1 n2 -1)])\n        (if (or (poly-zero? a) (poly-zero? b))\n            (poly-zero-over F)\n            (make-polynomial F\n              (let iterate ([k 0] [acc '()])\n                (if (= k n)\n                    (reverse acc)\n                    (iterate (+ k 1)\n                             (cons (poly-mul-coeff-at plus times as bs k n1 n2 z)\n                                   acc))))))))))\n\n```", "ground_truth": "(define (poly-mul p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-mul"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-mul`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-mul\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)]\n             [z (field-zero F)]\n             [plus (field-add-op F)]\n             [times (field-mul-op F)]\n             [n1 (length as)]\n             [n2 (length bs)]\n             [n (+ n1 n2 -1)])\n        (if (or (poly-zero? a) (poly-zero? b))\n            (poly-zero-over F)\n            (make-polynomial F\n              (let iterate ([k 0] [acc '()])\n                (if (= k n)\n                    (reverse acc)\n                    (iterate (+ k 1)\n                             (cons (poly-mul-coeff-at plus times as bs k n1 n2 z)\n                                   acc))))))))))\n\n```"}
{"id": "algebra_poly_translation_055", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-power`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_power(p, n):\n    if n == 0:\n        return one_polynomial_over(polynomial_field(p))\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        half = polynomial_power(p, n // 2)\n        return polynomial_mul(half, half)\n    return polynomial_mul(p, polynomial_power(p, n - 1))\n```", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-power"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-power`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_power(p, n):\n    if n == 0:\n        return one_polynomial_over(polynomial_field(p))\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        half = polynomial_power(p, n // 2)\n        return polynomial_mul(half, half)\n    return polynomial_mul(p, polynomial_power(p, n - 1))\n```"}
{"id": "algebra_poly_translation_056", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-power`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-power\n  (lambda (p n)\n    (cond\n      [(= n 0) (poly-one-over (poly-field p))]\n      [(= n 1) p]\n      [(even? n)\n       (let ([h (poly-power p (quotient n 2))])\n         (poly-mul h h))]\n      [else (poly-mul p (poly-power p (- n 1)))]))))\n```", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-power"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-power`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-power\n  (lambda (p n)\n    (cond\n      [(= n 0) (poly-one-over (poly-field p))]\n      [(= n 1) p]\n      [(even? n)\n       (let ([h (poly-power p (quotient n 2))])\n         (poly-mul h h))]\n      [else (poly-mul p (poly-power p (- n 1)))]))))\n```"}
{"id": "algebra_poly_translation_057", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-power`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-power\n    (lambda (p n)\n      (cond\n        [(= n 0) (poly-one-over (poly-field p))]\n        [(= n 1) p]\n        [(even? n)\n         (let ([h (poly-power p (quotient n 2))])\n           (poly-mul h h))]\n        [else (poly-mul p (poly-power p (- n 1)))]))))\n\n```", "ground_truth": "(define (poly-power p n)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-power"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-power`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'arithmetic)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-power\n    (lambda (p n)\n      (cond\n        [(= n 0) (poly-one-over (poly-field p))]\n        [(= n 1) p]\n        [(even? n)\n         (let ([h (poly-power p (quotient n 2))])\n           (poly-mul h h))]\n        [else (poly-mul p (poly-power p (- n 1)))]))))\n\n```"}
{"id": "algebra_poly_translation_058", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-equal?`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_equal(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    if len(c1) != len(c2):\n        return False\n    return all(field_equal(F, a, b) for a, b in zip(c1, c2))\n```", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-equal?"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-equal?`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_equal(p1, p2):\n    F = polynomial_field(p1)\n    c1 = polynomial_coeffs(p1)\n    c2 = polynomial_coeffs(p2)\n    if len(c1) != len(c2):\n        return False\n    return all(field_equal(F, a, b) for a, b in zip(c1, c2))\n```"}
{"id": "algebra_poly_translation_059", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-equal?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-equal?\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [eq (field-equal-fn F)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)])\n      (and (= (length as) (length bs))\n           (let check ([xs as] [ys bs])\n             (or (null? xs)\n                 (and (eq (car xs) (car ys))\n                      (check (cdr xs) (cdr ys))))))))\n```", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-equal?"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-equal?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-equal?\n  (lambda (a b)\n    (let* ([F (poly-field a)]\n           [eq (field-equal-fn F)]\n           [as (poly-coeffs a)]\n           [bs (poly-coeffs b)])\n      (and (= (length as) (length bs))\n           (let check ([xs as] [ys bs])\n             (or (null? xs)\n                 (and (eq (car xs) (car ys))\n                      (check (cdr xs) (cdr ys))))))))\n```"}
{"id": "algebra_poly_translation_060", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-equal?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'equality)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-equal?\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [eq (field-equal-fn F)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)])\n        (and (= (length as) (length bs))\n             (let check ([xs as] [ys bs])\n               (or (null? xs)\n                   (and (eq (car xs) (car ys))\n                        (check (cdr xs) (cdr ys))))))))\n\n```", "ground_truth": "(define (poly-equal? p1 p2)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-equal?"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-equal?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'equality)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-equal?\n    (lambda (a b)\n      (let* ([F (poly-field a)]\n             [eq (field-equal-fn F)]\n             [as (poly-coeffs a)]\n             [bs (poly-coeffs b)])\n        (and (= (length as) (length bs))\n             (let check ([xs as] [ys bs])\n               (or (null? xs)\n                   (and (eq (car xs) (car ys))\n                        (check (cdr xs) (cdr ys))))))))\n\n```"}
{"id": "algebra_poly_translation_061", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-divmod`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_divmod(p1, p2):\n    F = polynomial_field(p1)\n    if is_zero_polynomial(p2):\n        raise ValueError(\"Division by zero\")\n    quotient = zero_polynomial_over(F)\n    remainder = p1\n    d2 = polynomial_degree(p2)\n    lc2 = polynomial_leading_coeff(p2)\n    while not is_zero_polynomial(remainder) and polynomial_degree(remainder) >= d2:\n        d_diff = polynomial_degree(remainder) - d2\n        coeff = field_div(F, polynomial_leading_coeff(remainder), lc2)\n        term = monomial(F, coeff, d_diff)\n        quotient = polynomial_add(quotient, term)\n        subtrahend = polynomial_mul(term, p2)\n        remainder = polynomial_sub(remainder, subtrahend)\n    return (quotient, remainder)\n```", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-divmod"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-divmod`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_divmod(p1, p2):\n    F = polynomial_field(p1)\n    if is_zero_polynomial(p2):\n        raise ValueError(\"Division by zero\")\n    quotient = zero_polynomial_over(F)\n    remainder = p1\n    d2 = polynomial_degree(p2)\n    lc2 = polynomial_leading_coeff(p2)\n    while not is_zero_polynomial(remainder) and polynomial_degree(remainder) >= d2:\n        d_diff = polynomial_degree(remainder) - d2\n        coeff = field_div(F, polynomial_leading_coeff(remainder), lc2)\n        term = monomial(F, coeff, d_diff)\n        quotient = polynomial_add(quotient, term)\n        subtrahend = polynomial_mul(term, p2)\n        remainder = polynomial_sub(remainder, subtrahend)\n    return (quotient, remainder)\n```"}
{"id": "algebra_poly_translation_062", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-divmod`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-divmod\n  (lambda (n d)\n    (let* ([F (poly-field n)]\n           [dd (poly-degree d)])\n      (if (poly-zero? d)\n          (error 'poly-divmod \"division by zero\")\n          (poly-divmod-loop n d (poly-zero-over F) F)))))\n```", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-divmod"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-divmod`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-divmod\n  (lambda (n d)\n    (let* ([F (poly-field n)]\n           [dd (poly-degree d)])\n      (if (poly-zero? d)\n          (error 'poly-divmod \"division by zero\")\n          (poly-divmod-loop n d (poly-zero-over F) F)))))\n```"}
{"id": "algebra_poly_translation_063", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-divmod`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-divmod\n    (lambda (n d)\n      (let* ([F (poly-field n)]\n             [dd (poly-degree d)])\n        (if (poly-zero? d)\n            (error 'poly-divmod \"division by zero\")\n            (poly-divmod-loop n d (poly-zero-over F) F)))))\n\n```", "ground_truth": "(define (poly-divmod p1 p2)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-divmod"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-divmod`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-divmod\n    (lambda (n d)\n      (let* ([F (poly-field n)]\n             [dd (poly-degree d)])\n        (if (poly-zero? d)\n            (error 'poly-divmod \"division by zero\")\n            (poly-divmod-loop n d (poly-zero-over F) F)))))\n\n```"}
{"id": "algebra_poly_translation_064", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-div`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_div(p1, p2):\n    return polynomial_divmod(p1, p2)[0]\n```", "ground_truth": "(define (poly-div p1 p2)\n  (doc 'export #t)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-div"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-div`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_div(p1, p2):\n    return polynomial_divmod(p1, p2)[0]\n```"}
{"id": "algebra_poly_translation_065", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-div`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-div\n  (lambda (n d)\n    (car (poly-divmod n d))))\n```", "ground_truth": "(define (poly-div p1 p2)\n  (doc 'export #t)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-div"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-div`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-div\n  (lambda (n d)\n    (car (poly-divmod n d))))\n```"}
{"id": "algebra_poly_translation_066", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-div", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-div`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-div\n    (lambda (n d)\n      (car (poly-divmod n d))))\n\n```", "ground_truth": "(define (poly-div p1 p2)\n  (car (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(0 0 1))] [p2 (make-polynomial Q-field '(0 1))] [q (poly-div p1 p2)]) (and (= (poly-degree q) 1) (= (poly-coeff-at q 0) 0) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-div"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-div`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-div\n    (lambda (n d)\n      (car (poly-divmod n d))))\n\n```"}
{"id": "algebra_poly_translation_067", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-mod`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_mod(p1, p2):\n    return polynomial_divmod(p1, p2)[1]\n```", "ground_truth": "(define (poly-mod p1 p2)\n  (doc 'export #t)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-mod"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-mod`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_mod(p1, p2):\n    return polynomial_divmod(p1, p2)[1]\n```"}
{"id": "algebra_poly_translation_068", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-mod`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-mod\n  (lambda (n d)\n    (cdr (poly-divmod n d))))\n```", "ground_truth": "(define (poly-mod p1 p2)\n  (doc 'export #t)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-mod"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-mod`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-mod\n  (lambda (n d)\n    (cdr (poly-divmod n d))))\n```"}
{"id": "algebra_poly_translation_069", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mod", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-mod`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-mod\n    (lambda (n d)\n      (cdr (poly-divmod n d))))\n\n```", "ground_truth": "(define (poly-mod p1 p2)\n  (cdr (poly-divmod p1 p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(0 1))] [r (poly-mod p1 p2)]) (and (= (poly-degree r) 0) (= (poly-leading-coeff r) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-mod"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-mod`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-mod\n    (lambda (n d)\n      (cdr (poly-divmod n d))))\n\n```"}
{"id": "algebra_poly_translation_070", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-divides?`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_divides(p1, p2):\n    return is_zero_polynomial(polynomial_mod(p2, p1))\n```", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-divides?"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-divides?`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_divides(p1, p2):\n    return is_zero_polynomial(polynomial_mod(p2, p1))\n```"}
{"id": "algebra_poly_translation_071", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-divides?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-divides?\n  (lambda (d n)\n    (poly-zero? (poly-mod n d))))\n```", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-divides?"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-divides?`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-divides?\n  (lambda (d n)\n    (poly-zero? (poly-mod n d))))\n```"}
{"id": "algebra_poly_translation_072", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-divides?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-divides?\n    (lambda (d n)\n      (poly-zero? (poly-mod n d))))\n\n```", "ground_truth": "(define (poly-divides? p1 p2)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-divides?"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-divides?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'division)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-divides?\n    (lambda (d n)\n      (poly-zero? (poly-mod n d))))\n\n```"}
{"id": "algebra_poly_translation_073", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-gcd`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_gcd(p1, p2):\n    F = polynomial_field(p1)\n    if is_zero_polynomial(p2):\n        return make_monic(p1)\n    return polynomial_gcd(p2, polynomial_mod(p1, p2))\n```", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-gcd"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-gcd`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_gcd(p1, p2):\n    F = polynomial_field(p1)\n    if is_zero_polynomial(p2):\n        return make_monic(p1)\n    return polynomial_gcd(p2, polynomial_mod(p1, p2))\n```"}
{"id": "algebra_poly_translation_074", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-gcd`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-gcd\n  (lambda (a b)\n    (let ([F (poly-field a)])\n      (if (poly-zero? b)\n          (poly-make-monic a)\n          (poly-gcd b (poly-mod a b))))))\n```", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-gcd"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-gcd`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-gcd\n  (lambda (a b)\n    (let ([F (poly-field a)])\n      (if (poly-zero? b)\n          (poly-make-monic a)\n          (poly-gcd b (poly-mod a b))))))\n```"}
{"id": "algebra_poly_translation_075", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-gcd`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-gcd\n    (lambda (a b)\n      (let ([F (poly-field a)])\n        (if (poly-zero? b)\n            (poly-make-monic a)\n            (poly-gcd b (poly-mod a b))))))\n\n```", "ground_truth": "(define (poly-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-gcd"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-gcd`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-gcd\n    (lambda (a b)\n      (let ([F (poly-field a)])\n        (if (poly-zero? b)\n            (poly-make-monic a)\n            (poly-gcd b (poly-mod a b))))))\n\n```"}
{"id": "algebra_poly_translation_082", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-lcm`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_lcm(p1, p2):\n    if is_zero_polynomial(p1) or is_zero_polynomial(p2):\n        return zero_polynomial_over(polynomial_field(p1))\n    return polynomial_div(polynomial_mul(p1, p2), polynomial_gcd(p1, p2))\n```", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-lcm"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-lcm`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_lcm(p1, p2):\n    if is_zero_polynomial(p1) or is_zero_polynomial(p2):\n        return zero_polynomial_over(polynomial_field(p1))\n    return polynomial_div(polynomial_mul(p1, p2), polynomial_gcd(p1, p2))\n```"}
{"id": "algebra_poly_translation_083", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-lcm`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-lcm\n  (lambda (a b)\n    (if (or (poly-zero? a) (poly-zero? b))\n        (poly-zero-over (poly-field a))\n        (poly-div (poly-mul a b) (poly-gcd a b)))))\n```", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-lcm"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-lcm`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-lcm\n  (lambda (a b)\n    (if (or (poly-zero? a) (poly-zero? b))\n        (poly-zero-over (poly-field a))\n        (poly-div (poly-mul a b) (poly-gcd a b)))))\n```"}
{"id": "algebra_poly_translation_084", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-lcm`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-lcm\n    (lambda (a b)\n      (if (or (poly-zero? a) (poly-zero? b))\n          (poly-zero-over (poly-field a))\n          (poly-div (poly-mul a b) (poly-gcd a b)))))\n\n```", "ground_truth": "(define (poly-lcm p1 p2)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-lcm"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-lcm`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-lcm\n    (lambda (a b)\n      (if (or (poly-zero? a) (poly-zero? b))\n          (poly-zero-over (poly-field a))\n          (poly-div (poly-mul a b) (poly-gcd a b)))))\n\n```"}
{"id": "algebra_poly_translation_085", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-eval`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_eval(p, x):\n    F = polynomial_field(p)\n    coeffs = list(reversed(polynomial_coeffs(p)))\n    if not coeffs:\n        return field_zero(F)\n    result = coeffs[0]\n    for c in coeffs[1:]:\n        result = field_add(F, field_mul(F, result, x), c)\n    return result\n```", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-eval"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-eval`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_eval(p, x):\n    F = polynomial_field(p)\n    coeffs = list(reversed(polynomial_coeffs(p)))\n    if not coeffs:\n        return field_zero(F)\n    result = coeffs[0]\n    for c in coeffs[1:]:\n        result = field_add(F, field_mul(F, result, x), c)\n    return result\n```"}
{"id": "algebra_poly_translation_086", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-eval`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-eval\n  (lambda (p x)\n    (let* ([F (poly-field p)]\n           [cs (reverse (poly-coeffs p))]\n           [plus (field-add-op F)]\n           [times (field-mul-op F)])\n      (if (null? cs)\n          (field-zero F)\n          (let eval-loop ([rest (cdr cs)] [acc (car cs)])\n            (if (null? rest)\n                acc\n                (eval-loop (cdr rest) (plus (times acc x) (car rest))))))))))\n```", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-eval"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-eval`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-eval\n  (lambda (p x)\n    (let* ([F (poly-field p)]\n           [cs (reverse (poly-coeffs p))]\n           [plus (field-add-op F)]\n           [times (field-mul-op F)])\n      (if (null? cs)\n          (field-zero F)\n          (let eval-loop ([rest (cdr cs)] [acc (car cs)])\n            (if (null? rest)\n                acc\n                (eval-loop (cdr rest) (plus (times acc x) (car rest))))))))))\n```"}
{"id": "algebra_poly_translation_087", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-eval`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'evaluation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-eval\n    (lambda (p x)\n      (let* ([F (poly-field p)]\n             [cs (reverse (poly-coeffs p))]\n             [plus (field-add-op F)]\n             [times (field-mul-op F)])\n        (if (null? cs)\n            (field-zero F)\n            (let eval-loop ([rest (cdr cs)] [acc (car cs)])\n              (if (null? rest)\n                  acc\n                  (eval-loop (cdr rest) (plus (times acc x) (car rest))))))))))\n\n```", "ground_truth": "(define (poly-eval p x)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-eval"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-eval`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'evaluation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-eval\n    (lambda (p x)\n      (let* ([F (poly-field p)]\n             [cs (reverse (poly-coeffs p))]\n             [plus (field-add-op F)]\n             [times (field-mul-op F)])\n        (if (null? cs)\n            (field-zero F)\n            (let eval-loop ([rest (cdr cs)] [acc (car cs)])\n              (if (null? rest)\n                  acc\n                  (eval-loop (cdr rest) (plus (times acc x) (car rest))))))))))\n\n```"}
{"id": "algebra_poly_translation_088", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-derivative`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_derivative(p):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    if len(coeffs) <= 1:\n        return zero_polynomial_over(F)\n    result = []\n    for i, c in enumerate(coeffs[1:], 1):\n        result.append(field_mul_int(F, c, i))\n    return make_polynomial(F, result)\n```", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-derivative"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-derivative`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_derivative(p):\n    F = polynomial_field(p)\n    coeffs = polynomial_coeffs(p)\n    if len(coeffs) <= 1:\n        return zero_polynomial_over(F)\n    result = []\n    for i, c in enumerate(coeffs[1:], 1):\n        result.append(field_mul_int(F, c, i))\n    return make_polynomial(F, result)\n```"}
{"id": "algebra_poly_translation_089", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-derivative`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-derivative\n  (lambda (p)\n    (let* ([F (poly-field p)]\n           [cs (poly-coeffs p)])\n      (if (<= (length cs) 1)\n          (poly-zero-over F)\n          (make-polynomial F\n            (let deriv-loop ([xs (cdr cs)] [k 1] [acc '()])\n              (if (null? xs)\n                  (reverse acc)\n                  (deriv-loop (cdr xs) (+ k 1)\n                              (cons (poly-scalar-mul-int F (car xs) k) acc))))))))))\n```", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-derivative"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-derivative`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-derivative\n  (lambda (p)\n    (let* ([F (poly-field p)]\n           [cs (poly-coeffs p)])\n      (if (<= (length cs) 1)\n          (poly-zero-over F)\n          (make-polynomial F\n            (let deriv-loop ([xs (cdr cs)] [k 1] [acc '()])\n              (if (null? xs)\n                  (reverse acc)\n                  (deriv-loop (cdr xs) (+ k 1)\n                              (cons (poly-scalar-mul-int F (car xs) k) acc))))))))))\n```"}
{"id": "algebra_poly_translation_090", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-derivative`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'calculus)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-derivative\n    (lambda (p)\n      (let* ([F (poly-field p)]\n             [cs (poly-coeffs p)])\n        (if (<= (length cs) 1)\n            (poly-zero-over F)\n            (make-polynomial F\n              (let deriv-loop ([xs (cdr cs)] [k 1] [acc '()])\n                (if (null? xs)\n                    (reverse acc)\n                    (deriv-loop (cdr xs) (+ k 1)\n                                (cons (poly-scalar-mul-int F (car xs) k) acc))))))))))\n\n```", "ground_truth": "(define (poly-derivative p)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-derivative"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-derivative`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'calculus)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-derivative\n    (lambda (p)\n      (let* ([F (poly-field p)]\n             [cs (poly-coeffs p)])\n        (if (<= (length cs) 1)\n            (poly-zero-over F)\n            (make-polynomial F\n              (let deriv-loop ([xs (cdr cs)] [k 1] [acc '()])\n                (if (null? xs)\n                    (reverse acc)\n                    (deriv-loop (cdr xs) (+ k 1)\n                                (cons (poly-scalar-mul-int F (car xs) k) acc))))))))))\n\n```"}
{"id": "algebra_poly_translation_094", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-square-free-factorization`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_square_free_factorization(p):\n    F = polynomial_field(p)\n    if is_zero_polynomial(p):\n        return []\n    p_prime = polynomial_derivative(p)\n    a0 = polynomial_gcd(p, p_prime)\n    b0 = polynomial_div(p, a0)\n    c0 = polynomial_div(p_prime, a0)\n    # Yun's algorithm loop would continue here\n    result = []\n    if not polynomial_equal(a0, one_polynomial_over(F)):\n        result.append((a0, 1))\n    return result\n```", "ground_truth": "(define (poly-square-free-factorization p)\n  (doc 'export #t)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-square-free-factorization"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-square-free-factorization`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_square_free_factorization(p):\n    F = polynomial_field(p)\n    if is_zero_polynomial(p):\n        return []\n    p_prime = polynomial_derivative(p)\n    a0 = polynomial_gcd(p, p_prime)\n    b0 = polynomial_div(p, a0)\n    c0 = polynomial_div(p_prime, a0)\n    # Yun's algorithm loop would continue here\n    result = []\n    if not polynomial_equal(a0, one_polynomial_over(F)):\n        result.append((a0, 1))\n    return result\n```"}
{"id": "algebra_poly_translation_095", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-square-free-factorization`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-square-free-factorization\n  (lambda (p)\n    (let ([F (poly-field p)])\n      (if (poly-zero? p)\n          '()\n          (let* ([dp (poly-derivative p)]\n                 [a0 (poly-gcd p dp)]\n                 [b0 (poly-div p a0)]\n                 [c0 (poly-div dp a0)])\n            (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F))))))\n```", "ground_truth": "(define (poly-square-free-factorization p)\n  (doc 'export #t)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-square-free-factorization"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-square-free-factorization`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-square-free-factorization\n  (lambda (p)\n    (let ([F (poly-field p)])\n      (if (poly-zero? p)\n          '()\n          (let* ([dp (poly-derivative p)]\n                 [a0 (poly-gcd p dp)]\n                 [b0 (poly-div p a0)]\n                 [c0 (poly-div dp a0)])\n            (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F))))))\n```"}
{"id": "algebra_poly_translation_096", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free-factorization", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-square-free-factorization`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'factorization)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-square-free-factorization\n    (lambda (p)\n      (let ([F (poly-field p)])\n        (if (poly-zero? p)\n            '()\n            (let* ([dp (poly-derivative p)]\n                   [a0 (poly-gcd p dp)]\n                   [b0 (poly-div p a0)]\n                   [c0 (poly-div dp a0)])\n              (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F))))))\n\n```", "ground_truth": "(define (poly-square-free-factorization p)\n  (let ([F (poly-field p)])\n    (if (poly-zero? p)\n        '()\n        (let* ([p-prime (poly-derivative p)]\n               [a0 (poly-gcd p p-prime)]\n               [b0 (poly-div p a0)]\n               [c0 (poly-div p-prime a0)])\n          (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [factors (poly-square-free-factorization p)]) (= (length factors) 2))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-square-free-factorization"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-square-free-factorization`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'factorization)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-square-free-factorization\n    (lambda (p)\n      (let ([F (poly-field p)])\n        (if (poly-zero? p)\n            '()\n            (let* ([dp (poly-derivative p)]\n                   [a0 (poly-gcd p dp)]\n                   [b0 (poly-div p a0)]\n                   [c0 (poly-div dp a0)])\n              (poly-sqf-loop b0 (poly-sub c0 (poly-derivative b0)) 1 '() F))))))\n\n```"}
{"id": "algebra_poly_translation_103", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly->string`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_to_string(p, var='x'):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    if len(coeffs) == 1 and field_equal(F, coeffs[0], field_zero(F)):\n        return \"0\"\n    parts = []\n    for i in range(len(coeffs) - 1, -1, -1):\n        c = coeffs[i]\n        if field_equal(F, c, field_zero(F)):\n            continue\n        term = \"\"\n        if i == 0:\n            term = str(c)\n        elif i == 1:\n            term = f\"{c}{var}\" if c != 1 else var\n        else:\n            term = f\"{c}{var}^{i}\" if c != 1 else f\"{var}^{i}\"\n        parts.append(term)\n    return \" + \".join(parts)\n```", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly->string"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly->string`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_to_string(p, var='x'):\n    coeffs = polynomial_coeffs(p)\n    F = polynomial_field(p)\n    if len(coeffs) == 1 and field_equal(F, coeffs[0], field_zero(F)):\n        return \"0\"\n    parts = []\n    for i in range(len(coeffs) - 1, -1, -1):\n        c = coeffs[i]\n        if field_equal(F, c, field_zero(F)):\n            continue\n        term = \"\"\n        if i == 0:\n            term = str(c)\n        elif i == 1:\n            term = f\"{c}{var}\" if c != 1 else var\n        else:\n            term = f\"{c}{var}^{i}\" if c != 1 else f\"{var}^{i}\"\n        parts.append(term)\n    return \" + \".join(parts)\n```"}
{"id": "algebra_poly_translation_104", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly->string`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly->string\n  (lambda (p . args)\n    (let* ([v (if (null? args) 'x (car args))]\n           [F (poly-field p)]\n           [cs (poly-coeffs p)]\n           [n (length cs)])\n      (if (and (= n 1) ((field-equal-fn F) (car cs) (field-zero F)))\n          \"0\"\n          (let str-loop ([i (- n 1)] [first #t] [res \"\"])\n            (if (< i 0)\n                res\n                (let* ([c (list-ref cs i)]\n                       [term (poly-term->string c i v first F)])\n                  (str-loop (- i 1)\n                            (and first (string=? term \"\"))\n                            (string-append res term))))))))))\n```", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly->string"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly->string`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly->string\n  (lambda (p . args)\n    (let* ([v (if (null? args) 'x (car args))]\n           [F (poly-field p)]\n           [cs (poly-coeffs p)]\n           [n (length cs)])\n      (if (and (= n 1) ((field-equal-fn F) (car cs) (field-zero F)))\n          \"0\"\n          (let str-loop ([i (- n 1)] [first #t] [res \"\"])\n            (if (< i 0)\n                res\n                (let* ([c (list-ref cs i)]\n                       [term (poly-term->string c i v first F)])\n                  (str-loop (- i 1)\n                            (and first (string=? term \"\"))\n                            (string-append res term))))))))))\n```"}
{"id": "algebra_poly_translation_105", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly->string`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'display)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly->string\n    (lambda (p . args)\n      (let* ([v (if (null? args) 'x (car args))]\n             [F (poly-field p)]\n             [cs (poly-coeffs p)]\n             [n (length cs)])\n        (if (and (= n 1) ((field-equal-fn F) (car cs) (field-zero F)))\n            \"0\"\n            (let str-loop ([i (- n 1)] [first #t] [res \"\"])\n              (if (< i 0)\n                  res\n                  (let* ([c (list-ref cs i)]\n                         [term (poly-term->string c i v first F)])\n                    (str-loop (- i 1)\n                              (and first (string=? term \"\"))\n                              (string-append res term))))))))))\n\n```", "ground_truth": "(define (poly->string p . opts)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly->string"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly->string`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'display)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly->string\n    (lambda (p . args)\n      (let* ([v (if (null? args) 'x (car args))]\n             [F (poly-field p)]\n             [cs (poly-coeffs p)]\n             [n (length cs)])\n        (if (and (= n 1) ((field-equal-fn F) (car cs) (field-zero F)))\n            \"0\"\n            (let str-loop ([i (- n 1)] [first #t] [res \"\"])\n              (if (< i 0)\n                  res\n                  (let* ([c (list-ref cs i)]\n                         [term (poly-term->string c i v first F)])\n                    (str-loop (- i 1)\n                              (and first (string=? term \"\"))\n                              (string-append res term))))))))))\n\n```"}
{"id": "algebra_poly_translation_109", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-ring`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_ring(p):\n    return polynomial_field(p)\n```", "ground_truth": "(doc poly-ring 'export #t)\n(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-ring"], "split": "train", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-ring`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_ring(p):\n    return polynomial_field(p)\n```"}
{"id": "algebra_poly_translation_110", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-ring`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-ring poly-field)\n```", "ground_truth": "(doc poly-ring 'export #t)\n(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-ring"], "split": "train", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-ring`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-ring poly-field)\n```"}
{"id": "algebra_poly_translation_111", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-ring`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'compatibility)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-ring poly-field)\n\n```", "ground_truth": "(define poly-ring poly-field)", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-ring p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-ring"], "split": "train", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-ring`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'compatibility)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-ring poly-field)\n\n```"}
{"id": "algebra_poly_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `polynomial?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong tag symbol - checks for 'poly instead of 'polynomial.\n\n```scheme\n(define (polynomial? p)\n  (and (pair? p)\n       (eq? (car p) 'poly)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (polynomial? p)\n  (doc 'export #t)\n  (and (pair? p)\n       (eq? (car p) 'polynomial)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (polynomial? p) (not (polynomial? 'not-a-poly)) (not (polynomial? 42))))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "polynomial?"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `polynomial?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong tag symbol - checks for 'poly instead of 'polynomial.\n\n```scheme\n(define (polynomial? p)\n  (and (pair? p)\n       (eq? (car p) 'poly)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-field` in `lattice/algebra/polynomial.ss`.\nKnown issue: Field is the second element (cadr), not the first (car).\n\n```scheme\n(define (poly-field p)\n  (car p))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-field p)\n  (doc 'export #t)\n  (cadr p))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2))]) (eq? (poly-field p) Q-field))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-field"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-field` in `lattice/algebra/polynomial.ss`.\nKnown issue: Field is the second element (cadr), not the first (car).\n\n```scheme\n(define (poly-field p)\n  (car p))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-degree` in `lattice/algebra/polynomial.ss`.\nKnown issue: Degree is length-1, not length. Off-by-one error.\n\n```scheme\n(define (poly-degree p)\n  (length (poly-coeffs p)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-degree p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (- (length coeffs) 1)))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(1))] [p2 (make-polynomial Q-field '(1 2))] [p3 (make-polynomial Q-field '(1 2 3 4))]) (and (= (poly-degree p1) 0) (= (poly-degree p2) 1) (= (poly-degree p3) 3)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-degree"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-degree` in `lattice/algebra/polynomial.ss`.\nKnown issue: Degree is length-1, not length. Off-by-one error.\n\n```scheme\n(define (poly-degree p)\n  (length (poly-coeffs p)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-leading-coeff` in `lattice/algebra/polynomial.ss`.\nKnown issue: Should get last element (list-ref (- len 1)), not first (car).\n\n```scheme\n(define (poly-leading-coeff p)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (car coeffs))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-leading-coeff p)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (list-ref coeffs (- (length coeffs) 1)))))", "verify_expr": "(let ([p (make-polynomial Q-field '(3 2 5))]) (= (poly-leading-coeff p) 5))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-leading-coeff"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-leading-coeff` in `lattice/algebra/polynomial.ss`.\nKnown issue: Should get last element (list-ref (- len 1)), not first (car).\n\n```scheme\n(define (poly-leading-coeff p)\n  (let ([coeffs (poly-coeffs p)])\n    (if (null? coeffs)\n        (field-zero (poly-field p))\n        (car coeffs))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-coeff-at", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-coeff-at` in `lattice/algebra/polynomial.ss`.\nKnown issue: Comparison should be >= not >. When k equals length, should return zero.\n\n```scheme\n(define (poly-coeff-at p k)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (> k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-coeff-at p k)\n  (doc 'export #t)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (>= k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 3))]) (and (= (poly-coeff-at p 0) 1) (= (poly-coeff-at p 1) 2) (= (poly-coeff-at p 2) 3) (= (poly-coeff-at p 3) 0) (= (poly-coeff-at p 5) 0)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-coeff-at"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-coeff-at` in `lattice/algebra/polynomial.ss`.\nKnown issue: Comparison should be >= not >. When k equals length, should return zero.\n\n```scheme\n(define (poly-coeff-at p k)\n  (let ([coeffs (poly-coeffs p)]\n        [F (poly-field p)])\n    (if (> k (length coeffs))\n        (field-zero F)\n        (list-ref coeffs k))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-zero?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing length check. A polynomial with multiple zeros is still zero, but this only checks first coeff.\n\n```scheme\n(define (poly-zero? p)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    ((field-equal-fn F) (car coeffs) (field-zero F))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-zero? p)\n  (doc 'export #t)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    (and (= (length coeffs) 1)\n         ((field-equal-fn F) (car coeffs) (field-zero F)))))", "verify_expr": "(let ([zero (poly-zero-over Q-field)] [nonzero (make-polynomial Q-field '(1 2))] [tricky (make-polynomial Q-field '(0 2))]) (and (poly-zero? zero) (not (poly-zero? nonzero)) (not (poly-zero? tricky))))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-zero?"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-zero?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing length check. A polynomial with multiple zeros is still zero, but this only checks first coeff.\n\n```scheme\n(define (poly-zero? p)\n  (let ([F (poly-field p)]\n        [coeffs (poly-coeffs p)])\n    ((field-equal-fn F) (car coeffs) (field-zero F))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing normalization - must call poly-normalize-coeffs to strip trailing zeros.\n\n```scheme\n(define (make-polynomial field coeffs)\n  (list 'polynomial field coeffs))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "make-polynomial"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing normalization - must call poly-normalize-coeffs to strip trailing zeros.\n\n```scheme\n(define (make-polynomial field coeffs)\n  (list 'polynomial field coeffs))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments to list are in wrong order - should be ('polynomial field coeffs).\n\n```scheme\n(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (list 'polynomial (poly-normalize-coeffs field coeffs) field))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (doc 'type '(-> Field (List Coeff) Polynomial))\n  (doc 'description \"Create a polynomial over field F with given coefficients\")\n  (doc 'description \"Automatically normalizes (strips trailing zeros)\")\n  (list 'polynomial field (poly-normalize-coeffs field coeffs)))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 0 2 0))]) (and (polynomial? p) (equal? (poly-coeffs p) '(1 0 2)) (= (poly-degree p) 2)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "make-polynomial"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments to list are in wrong order - should be ('polynomial field coeffs).\n\n```scheme\n(define (make-polynomial field coeffs)\n  (doc 'export #t)\n  (list 'polynomial (poly-normalize-coeffs field coeffs) field))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-monomial", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-monomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Off-by-one in degree padding - uses (+ degree 1) zeros instead of degree zeros, making degree one too high.\n\n```scheme\n(define (poly-monomial field coeff degree)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list (+ degree 1) zero) (list coeff))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-monomial field coeff degree)\n  (doc 'export #t)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list degree zero) (list coeff))))))", "verify_expr": "(let ([m (poly-monomial Q-field 3 4)]) (and (= (poly-degree m) 4) (= (poly-leading-coeff m) 3) (= (poly-coeff-at m 0) 0)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-monomial"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-monomial` in `lattice/algebra/polynomial.ss`.\nKnown issue: Off-by-one in degree padding - uses (+ degree 1) zeros instead of degree zeros, making degree one too high.\n\n```scheme\n(define (poly-monomial field coeff degree)\n  (let ([zero (field-zero field)])\n    (if ((field-equal-fn field) coeff zero)\n        (poly-zero-over field)\n        (make-polynomial field\n          (append (make-list (+ degree 1) zero) (list coeff))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-x` in `lattice/algebra/polynomial.ss`.\nKnown issue: Degree should be 1 for x, not 0 (which would be constant 1).\n\n```scheme\n(define (poly-x field)\n  (poly-monomial field (field-one field) 0))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-x field)\n  (doc 'export #t)\n  (poly-monomial field (field-one field) 1))", "verify_expr": "(let ([x (poly-x Q-field)]) (and (= (poly-degree x) 1) (= (poly-coeff-at x 0) 0) (= (poly-coeff-at x 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-x"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-x` in `lattice/algebra/polynomial.ss`.\nKnown issue: Degree should be 1 for x, not 0 (which would be constant 1).\n\n```scheme\n(define (poly-x field)\n  (poly-monomial field (field-one field) 0))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-add` in `lattice/algebra/polynomial.ss`.\nKnown issue: Second make-polynomial shadows the first - returns p1 instead of sum.\n\n```scheme\n(define (poly-add p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))\n    (make-polynomial F c1)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-add"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-add` in `lattice/algebra/polynomial.ss`.\nKnown issue: Second make-polynomial shadows the first - returns p1 instead of sum.\n\n```scheme\n(define (poly-add p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))\n    (make-polynomial F c1)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-add` in `lattice/algebra/polynomial.ss`.\nKnown issue: Using field-mul-op instead of field-add-op - multiplies coefficients pairwise instead of adding.\n\n```scheme\n(define (poly-add p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-mul-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-add p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-add-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(3 0 1))] [sum (poly-add p1 p2)]) (and (= (poly-degree sum) 2) (= (poly-coeff-at sum 0) 4) (= (poly-coeff-at sum 1) 2) (= (poly-coeff-at sum 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-add"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-add` in `lattice/algebra/polynomial.ss`.\nKnown issue: Using field-mul-op instead of field-add-op - multiplies coefficients pairwise instead of adding.\n\n```scheme\n(define (poly-add p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [add (field-mul-op F)])\n    (make-polynomial F (poly-add-coeffs add c1 c2 (field-zero F)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-neg", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-neg` in `lattice/algebra/polynomial.ss`.\nKnown issue: Returns raw list instead of polynomial - missing make-polynomial wrapper.\n\n```scheme\n(define (poly-neg p)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (map neg (poly-coeffs p))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-neg p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (make-polynomial F (map neg (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 -2 3))] [np (poly-neg p)]) (and (= (poly-coeff-at np 0) -1) (= (poly-coeff-at np 1) 2) (= (poly-coeff-at np 2) -3)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-neg"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-neg` in `lattice/algebra/polynomial.ss`.\nKnown issue: Returns raw list instead of polynomial - missing make-polynomial wrapper.\n\n```scheme\n(define (poly-neg p)\n  (let* ([F (poly-field p)]\n         [neg (field-neg-fn F)])\n    (map neg (poly-coeffs p))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-sub", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-sub` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped - should be (poly-add p1 (poly-neg p2)) for p1 - p2.\n\n```scheme\n(define (poly-sub p1 p2)\n  (poly-add p2 (poly-neg p1)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-sub p1 p2)\n  (doc 'export #t)\n  (poly-add p1 (poly-neg p2)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(3 0 1))] [p2 (make-polynomial Q-field '(1 2))] [diff (poly-sub p1 p2)]) (and (= (poly-degree diff) 2) (= (poly-coeff-at diff 0) 2) (= (poly-coeff-at diff 1) -2) (= (poly-coeff-at diff 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-sub"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-sub` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped - should be (poly-add p1 (poly-neg p2)) for p1 - p2.\n\n```scheme\n(define (poly-sub p1 p2)\n  (poly-add p2 (poly-neg p1)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-scale` in `lattice/algebra/polynomial.ss`.\nKnown issue: Uses field-add-op instead of field-mul-op - adds scalar to each coefficient instead of multiplying.\n\n```scheme\n(define (poly-scale p c)\n  (let* ([F (poly-field p)]\n         [add (field-add-op F)])\n    (make-polynomial F (map (lambda (a) (add c a)) (poly-coeffs p)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-scale"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-scale` in `lattice/algebra/polynomial.ss`.\nKnown issue: Uses field-add-op instead of field-mul-op - adds scalar to each coefficient instead of multiplying.\n\n```scheme\n(define (poly-scale p c)\n  (let* ([F (poly-field p)]\n         [add (field-add-op F)])\n    (make-polynomial F (map (lambda (a) (add c a)) (poly-coeffs p)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-scale` in `lattice/algebra/polynomial.ss`.\nKnown issue: Multiplies scalar by itself instead of by each coefficient - all coefficients become c*c.\n\n```scheme\n(define (poly-scale p c)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c c)) (poly-coeffs p)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-scale p c)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c a)) (poly-coeffs p)))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 2))] [sp (poly-scale p 3)]) (and (= (poly-coeff-at sp 0) 3) (= (poly-coeff-at sp 1) 6)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-scale"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-scale` in `lattice/algebra/polynomial.ss`.\nKnown issue: Multiplies scalar by itself instead of by each coefficient - all coefficients become c*c.\n\n```scheme\n(define (poly-scale p c)\n  (let* ([F (poly-field p)]\n         [mul (field-mul-op F)])\n    (make-polynomial F (map (lambda (a) (mul c c)) (poly-coeffs p)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-equal?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing length check - polynomials of different lengths can pass if shorter is prefix.\n\n```scheme\n(define (poly-equal? p1 p2)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (let loop ([l1 c1] [l2 c2])\n      (or (null? l1)\n          (and (eq-fn (car l1) (car l2))\n               (loop (cdr l1) (cdr l2)))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-equal?"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-equal?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing length check - polynomials of different lengths can pass if shorter is prefix.\n\n```scheme\n(define (poly-equal? p1 p2)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (let loop ([l1 c1] [l2 c2])\n      (or (null? l1)\n          (and (eq-fn (car l1) (car l2))\n               (loop (cdr l1) (cdr l2)))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-equal?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-equal?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Only checks coefficient list lengths, not actual values - any two same-degree polynomials would compare equal.\n\n```scheme\n(define (poly-equal? p1 p2)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (= (length c1) (length c2))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-equal? p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (and (= (length c1) (length c2))\n         (let loop ([l1 c1] [l2 c2])\n           (or (null? l1)\n               (and (eq-fn (car l1) (car l2))\n                    (loop (cdr l1) (cdr l2))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(1 2 3))] [p3 (make-polynomial Q-field '(1 2 4))] [p4 (make-polynomial Q-field '(1 2))]) (and (poly-equal? p1 p2) (not (poly-equal? p1 p3)) (not (poly-equal? p1 p4))))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-equal?"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-equal?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Only checks coefficient list lengths, not actual values - any two same-degree polynomials would compare equal.\n\n```scheme\n(define (poly-equal? p1 p2)\n  (let* ([F (poly-field p1)]\n         [eq-fn (field-equal-fn F)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)])\n    (= (length c1) (length c2))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-eval` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing reverse - Horner's method needs descending order but coeffs are ascending.\n\n```scheme\n(define (poly-eval p x)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-eval"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-eval` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing reverse - Horner's method needs descending order but coeffs are ascending.\n\n```scheme\n(define (poly-eval p x)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-eval` in `lattice/algebra/polynomial.ss`.\nKnown issue: Swapped add and mul in Horner step - should be (add (mul acc x) c), not (mul (add acc x) c).\n\n```scheme\n(define (poly-eval p x)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (mul (add acc x) (car cs))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-eval p x)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (add (mul acc x) (car cs))))))))", "verify_expr": "(let ([p1 (make-polynomial Q-field '(2 3))] [p2 (make-polynomial Q-field '(1 1 1))]) (and (= (poly-eval p1 4) 14) (= (poly-eval p2 2) 7)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-eval"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-eval` in `lattice/algebra/polynomial.ss`.\nKnown issue: Swapped add and mul in Horner step - should be (add (mul acc x) c), not (mul (add acc x) c).\n\n```scheme\n(define (poly-eval p x)\n  (let* ([F (poly-field p)]\n         [coeffs (reverse (poly-coeffs p))]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)])\n    (if (null? coeffs)\n        (field-zero F)\n        (let loop ([cs (cdr coeffs)] [acc (car coeffs)])\n          (if (null? cs)\n              acc\n              (loop (cdr cs) (mul (add acc x) (car cs))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-derivative` in `lattice/algebra/polynomial.ss`.\nKnown issue: Starting k at 0 instead of 1 - derivative of constant should be 0, but this includes it.\n\n```scheme\n(define (poly-derivative p)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs coeffs] [k 0] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-derivative p)\n  (doc 'export #t)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [add (field-add-op F)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs (cdr coeffs)] [k 1] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(0 1 2 1))] [dp (poly-derivative p)]) (and (= (poly-degree dp) 2) (= (poly-coeff-at dp 0) 1) (= (poly-coeff-at dp 1) 4) (= (poly-coeff-at dp 2) 3)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-derivative"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-derivative` in `lattice/algebra/polynomial.ss`.\nKnown issue: Starting k at 0 instead of 1 - derivative of constant should be 0, but this includes it.\n\n```scheme\n(define (poly-derivative p)\n  (let* ([F (poly-field p)]\n         [coeffs (poly-coeffs p)])\n    (if (<= (length coeffs) 1)\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([cs coeffs] [k 0] [result '()])\n            (if (null? cs)\n                (reverse result)\n                (loop (cdr cs) (+ k 1)\n                      (cons (poly-scalar-mul-int F (car cs) k) result))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-power` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong recursion in odd case - should be (- n 1) not (+ n 1), causes infinite loop.\n\n```scheme\n(define (poly-power p n)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (+ n 1)))]))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-power p n)\n  (doc 'export #t)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (- n 1)))]))", "verify_expr": "(let* ([p (make-polynomial Q-field '(1 1))] [p3 (poly-power p 3)]) (and (= (poly-degree p3) 3) (= (poly-coeff-at p3 0) 1) (= (poly-coeff-at p3 1) 3) (= (poly-coeff-at p3 2) 3) (= (poly-coeff-at p3 3) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-power"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-power` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong recursion in odd case - should be (- n 1) not (+ n 1), causes infinite loop.\n\n```scheme\n(define (poly-power p n)\n  (cond\n    [(= n 0) (poly-one-over (poly-field p))]\n    [(= n 1) p]\n    [(even? n)\n     (let ([half (poly-power p (/ n 2))])\n       (poly-mul half half))]\n    [else\n     (poly-mul p (poly-power p (+ n 1)))]))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly->string` in `lattice/algebra/polynomial.ss`.\nKnown issue: Iterating in wrong direction - should go from high degree to low for proper formatting.\n\n```scheme\n(define (poly->string p . opts)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i 0] [first? #t] [result \"\"])\n          (if (>= i n)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (+ i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly->string p . opts)\n  (doc 'export #t)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i (- n 1)] [first? #t] [result \"\"])\n          (if (< i 0)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (- i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))", "verify_expr": "(let ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly->string"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly->string` in `lattice/algebra/polynomial.ss`.\nKnown issue: Iterating in wrong direction - should go from high degree to low for proper formatting.\n\n```scheme\n(define (poly->string p . opts)\n  (let* ([var (if (null? opts) 'x (car opts))]\n         [F (poly-field p)]\n         [coeffs (poly-coeffs p)]\n         [n (length coeffs)])\n    (if (and (= n 1) ((field-equal-fn F) (car coeffs) (field-zero F)))\n        \"0\"\n        (let loop ([i 0] [first? #t] [result \"\"])\n          (if (>= i n)\n              result\n              (let* ([c (list-ref coeffs i)]\n                     [term (poly-term->string c i var first? F)])\n                (loop (+ i 1)\n                      (and first? (string=? term \"\"))\n                      (string-append result term))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-mul` in `lattice/algebra/polynomial.ss`.\nKnown issue: Off-by-one in degree: uses (+ n1 n2 -2) instead of (+ n1 n2 -1), truncating the highest-degree term.\n\n```scheme\n(define (poly-mul p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -2)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-mul"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-mul` in `lattice/algebra/polynomial.ss`.\nKnown issue: Off-by-one in degree: uses (+ n1 n2 -2) instead of (+ n1 n2 -1), truncating the highest-degree term.\n\n```scheme\n(define (poly-mul p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -2)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-mul` in `lattice/algebra/polynomial.ss`.\nKnown issue: Uses c1 and n1 for both operands - squares p1 instead of multiplying p1*p2.\n\n```scheme\n(define (poly-mul p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k (+ n1 n1 -1))\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c1 k n1 n1 zero)\n                            result))))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-mul p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)]\n         [n2 (length c2)]\n         [n (+ n1 n2 -1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k n)\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c2 k n1 n2 zero)\n                            result))))))))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(1 -1))] [prod (poly-mul p1 p2)]) (and (= (poly-degree prod) 2) (= (poly-coeff-at prod 0) 1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) -1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-mul"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-mul` in `lattice/algebra/polynomial.ss`.\nKnown issue: Uses c1 and n1 for both operands - squares p1 instead of multiplying p1*p2.\n\n```scheme\n(define (poly-mul p1 p2)\n  (let* ([F (poly-field p1)]\n         [c1 (poly-coeffs p1)]\n         [c2 (poly-coeffs p2)]\n         [zero (field-zero F)]\n         [add (field-add-op F)]\n         [mul (field-mul-op F)]\n         [n1 (length c1)])\n    (if (or (poly-zero? p1) (poly-zero? p2))\n        (poly-zero-over F)\n        (make-polynomial F\n          (let loop ([k 0] [result '()])\n            (if (= k (+ n1 n1 -1))\n                (reverse result)\n                (loop (+ k 1)\n                      (cons (poly-mul-coeff-at add mul c1 c1 k n1 n1 zero)\n                            result))))))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_026", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divmod` in `lattice/algebra/polynomial.ss`.\nKnown issue: Initializes quotient accumulator to 1 instead of 0 - adds spurious constant to quotient.\n\n```scheme\n(define (poly-divmod p1 p2)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-one-over F) F))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-divmod"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divmod` in `lattice/algebra/polynomial.ss`.\nKnown issue: Initializes quotient accumulator to 1 instead of 0 - adds spurious constant to quotient.\n\n```scheme\n(define (poly-divmod p1 p2)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-one-over F) F))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_027", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divmod` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped in loop call - should be (poly-divmod-loop p1 p2 ...) not (p2 p1).\n\n```scheme\n(define (poly-divmod p1 p2)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p2 p1 (poly-zero-over F) F))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-divmod p1 p2)\n  (doc 'export #t)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p1 p2 (poly-zero-over F) F))))", "verify_expr": "(let* ([dividend (make-polynomial Q-field '(-1 0 1))] [divisor (make-polynomial Q-field '(-1 1))] [result (poly-divmod dividend divisor)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-divmod"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divmod` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped in loop call - should be (poly-divmod-loop p1 p2 ...) not (p2 p1).\n\n```scheme\n(define (poly-divmod p1 p2)\n  (let* ([F (poly-field p1)]\n         [d2 (poly-degree p2)])\n    (if (poly-zero? p2)\n        (error 'poly-divmod \"division by zero polynomial\")\n        (poly-divmod-loop p2 p1 (poly-zero-over F) F))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_028", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Not making result monic - should call (poly-make-monic p1) in base case.\n\n```scheme\n(define (poly-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        p1\n        (poly-gcd p2 (poly-mod p1 p2)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-gcd"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Not making result monic - should call (poly-make-monic p1) in base case.\n\n```scheme\n(define (poly-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        p1\n        (poly-gcd p2 (poly-mod p1 p2)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_029", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong base case - should check p2 not p1, and return monic of p1 not p2.\n\n```scheme\n(define (poly-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p1)\n        (poly-make-monic p2)\n        (poly-gcd p2 (poly-mod p1 p2)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p2)\n        (poly-make-monic p1)\n        (poly-gcd p2 (poly-mod p1 p2)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [g (poly-gcd p1 p2)]) (and (= (poly-degree g) 1) (= (poly-leading-coeff g) 1) (= (poly-coeff-at g 0) 1) (= (poly-coeff-at g 1) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-gcd"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Wrong base case - should check p2 not p1, and return monic of p1 not p2.\n\n```scheme\n(define (poly-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (if (poly-zero? p1)\n        (poly-make-monic p2)\n        (poly-gcd p2 (poly-mod p1 p2)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_034", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divides?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divides?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped - should be (poly-mod p2 p1) for checking if p1 divides p2.\n\n```scheme\n(define (poly-divides? p1 p2)\n  (poly-zero? (poly-mod p1 p2)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-divides? p1 p2)\n  (doc 'export #t)\n  (poly-zero? (poly-mod p2 p1)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(-1 1))] [p2 (make-polynomial Q-field '(-1 0 1))]) (and (poly-divides? p1 p2) (not (poly-divides? p2 p1))))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-divides?"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-divides?` in `lattice/algebra/polynomial.ss`.\nKnown issue: Arguments swapped - should be (poly-mod p2 p1) for checking if p1 divides p2.\n\n```scheme\n(define (poly-divides? p1 p2)\n  (poly-zero? (poly-mod p1 p2)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_035", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lcm", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lcm` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing division by GCD - LCM should be (p1*p2)/gcd(p1,p2), not just p1*p2.\n\n```scheme\n(define (poly-lcm p1 p2)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-mul p1 p2)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-lcm p1 p2)\n  (doc 'export #t)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-div (poly-mul p1 p2) (poly-gcd p1 p2))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p1 (poly-mul xp1 xp1)] [p2 (poly-mul xp1 xm1)] [l (poly-lcm p1 p2)] [prod (poly-mul p1 p2)] [g (poly-gcd p1 p2)]) (poly-equal? l (poly-div prod g)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-lcm"], "split": "train", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lcm` in `lattice/algebra/polynomial.ss`.\nKnown issue: Missing division by GCD - LCM should be (p1*p2)/gcd(p1,p2), not just p1*p2.\n\n```scheme\n(define (poly-lcm p1 p2)\n  (if (or (poly-zero? p1) (poly-zero? p2))\n      (poly-zero-over (poly-field p1))\n      (poly-mul p1 p2)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Create a polynomial from '(1 0 2 0 0) and verify normalization stripped trailing zeros.\n\nEnsure `make-polynomial` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let ([p (make-polynomial Q-field '(1 0 2 0 0))]) (equal? (poly-coeffs p) '(1 0 2)))", "verify_expr": "(equal? (let ([p (make-polynomial Q-field '(1 0 2 0 0))]) (equal? (poly-coeffs p) '(1 0 2))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "make-polynomial"], "split": "train", "prompt": "Create a polynomial from '(1 0 2 0 0) and verify normalization stripped trailing zeros.\n\nEnsure `make-polynomial` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "polynomial?", "prompt_body": "Create polynomials using different constructors and verify all satisfy polynomial?.\n\nEnsure `polynomial?` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (poly-x Q-field)] [p3 (poly-constant Q-field 5)]) (and (polynomial? p1) (polynomial? p2) (polynomial? p3)))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (poly-x Q-field)] [p3 (poly-constant Q-field 5)]) (and (polynomial? p1) (polynomial? p2) (polynomial? p3))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "polynomial?"], "split": "train", "prompt": "Create polynomials using different constructors and verify all satisfy polynomial?.\n\nEnsure `polynomial?` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-field", "prompt_body": "Create polynomials over Q and verify they all have Q-field as their coefficient field.\n\nEnsure `poly-field` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1))] [p2 (poly-monomial Q-field 3 5)] [p3 (poly-add p1 p2)]) (and (eq? (poly-field p1) Q-field) (eq? (poly-field p2) Q-field) (eq? (poly-field p3) Q-field)))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1))] [p2 (poly-monomial Q-field 3 5)] [p3 (poly-add p1 p2)]) (and (eq? (poly-field p1) Q-field) (eq? (poly-field p2) Q-field) (eq? (poly-field p3) Q-field))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-field"], "split": "train", "prompt": "Create polynomials over Q and verify they all have Q-field as their coefficient field.\n\nEnsure `poly-field` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Create (x+1)^3 by multiplication and verify degree is 3.\n\nEnsure `poly-degree` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([x+1 (make-polynomial Q-field '(1 1))] [cubed (poly-mul (poly-mul x+1 x+1) x+1)]) (= (poly-degree cubed) 3))", "verify_expr": "(equal? (let* ([x+1 (make-polynomial Q-field '(1 1))] [cubed (poly-mul (poly-mul x+1 x+1) x+1)]) (= (poly-degree cubed) 3)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-degree"], "split": "train", "prompt": "Create (x+1)^3 by multiplication and verify degree is 3.\n\nEnsure `poly-degree` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-degree", "prompt_body": "Compute degree of derivative of x^4 + 2x^2 + 1.\n\nEnsure `poly-degree` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(1 0 2 0 1))] [dp (poly-derivative p)]) (= (poly-degree dp) 3))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(1 0 2 0 1))] [dp (poly-derivative p)]) (= (poly-degree dp) 3)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-degree"], "split": "train", "prompt": "Compute degree of derivative of x^4 + 2x^2 + 1.\n\nEnsure `poly-degree` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-zero?", "prompt_body": "Verify that p - p = zero for any polynomial p.\n\nEnsure `poly-zero?` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(1 2 3 4))]) (poly-zero? (poly-sub p p)))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(1 2 3 4))]) (poly-zero? (poly-sub p p))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-zero?"], "split": "train", "prompt": "Verify that p - p = zero for any polynomial p.\n\nEnsure `poly-zero?` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-x", "prompt_body": "Verify that evaluating x at point a returns a.\n\nEnsure `poly-x` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([x (poly-x Q-field)]) (= (poly-eval x 5) 5))", "verify_expr": "(equal? (let* ([x (poly-x Q-field)]) (= (poly-eval x 5) 5)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-x"], "split": "train", "prompt": "Verify that evaluating x at point a returns a.\n\nEnsure `poly-x` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Verify (x^2 + 1) + (x + 2) = x^2 + x + 3 by checking coefficients.\n\nEnsure `poly-add` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(2 1))] [sum (poly-add p1 p2)]) (and (= (poly-coeff-at sum 0) 3) (= (poly-coeff-at sum 1) 1) (= (poly-coeff-at sum 2) 1)))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 0 1))] [p2 (make-polynomial Q-field '(2 1))] [sum (poly-add p1 p2)]) (and (= (poly-coeff-at sum 0) 3) (= (poly-coeff-at sum 1) 1) (= (poly-coeff-at sum 2) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-add"], "split": "train", "prompt": "Verify (x^2 + 1) + (x + 2) = x^2 + x + 3 by checking coefficients.\n\nEnsure `poly-add` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-add", "prompt_body": "Verify addition is commutative: p1 + p2 = p2 + p1 for random polynomials.\n\nEnsure `poly-add` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(4 5))]) (poly-equal? (poly-add p1 p2) (poly-add p2 p1)))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 2 3))] [p2 (make-polynomial Q-field '(4 5))]) (poly-equal? (poly-add p1 p2) (poly-add p2 p1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-add"], "split": "train", "prompt": "Verify addition is commutative: p1 + p2 = p2 + p1 for random polynomials.\n\nEnsure `poly-add` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Verify (x-1)(x+1) = x^2 - 1 by checking all coefficients.\n\nEnsure `poly-mul` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([xm1 (make-polynomial Q-field '(-1 1))] [xp1 (make-polynomial Q-field '(1 1))] [prod (poly-mul xm1 xp1)]) (and (= (poly-coeff-at prod 0) -1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) 1)))", "verify_expr": "(equal? (let* ([xm1 (make-polynomial Q-field '(-1 1))] [xp1 (make-polynomial Q-field '(1 1))] [prod (poly-mul xm1 xp1)]) (and (= (poly-coeff-at prod 0) -1) (= (poly-coeff-at prod 1) 0) (= (poly-coeff-at prod 2) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-mul"], "split": "train", "prompt": "Verify (x-1)(x+1) = x^2 - 1 by checking all coefficients.\n\nEnsure `poly-mul` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-power", "prompt_body": "Verify (x+1)^4 has correct coefficients using binomial theorem.\n\nEnsure `poly-power` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [p4 (poly-power xp1 4)]) (and (= (poly-coeff-at p4 0) 1) (= (poly-coeff-at p4 1) 4) (= (poly-coeff-at p4 2) 6) (= (poly-coeff-at p4 3) 4) (= (poly-coeff-at p4 4) 1)))", "verify_expr": "(equal? (let* ([xp1 (make-polynomial Q-field '(1 1))] [p4 (poly-power xp1 4)]) (and (= (poly-coeff-at p4 0) 1) (= (poly-coeff-at p4 1) 4) (= (poly-coeff-at p4 2) 6) (= (poly-coeff-at p4 3) 4) (= (poly-coeff-at p4 4) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-power"], "split": "train", "prompt": "Verify (x+1)^4 has correct coefficients using binomial theorem.\n\nEnsure `poly-power` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Divide x^3 - 1 by x - 1 and verify remainder is zero and quotient is x^2 + x + 1.\n\nEnsure `poly-divmod` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(-1 0 0 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-divmod p1 p2)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-degree q) 2) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1) (= (poly-coeff-at q 2) 1)))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(-1 0 0 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-divmod p1 p2)] [q (car result)] [r (cdr result)]) (and (poly-zero? r) (= (poly-degree q) 2) (= (poly-coeff-at q 0) 1) (= (poly-coeff-at q 1) 1) (= (poly-coeff-at q 2) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-divmod"], "split": "train", "prompt": "Divide x^3 - 1 by x - 1 and verify remainder is zero and quotient is x^2 + x + 1.\n\nEnsure `poly-divmod` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-divmod", "prompt_body": "Verify division algorithm: for random p1, p2, we have p1 = q*p2 + r with deg(r) < deg(p2).\n\nEnsure `poly-divmod` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 2 3 4))] [p2 (make-polynomial Q-field '(1 1))] [result (poly-divmod p1 p2)] [q (car result)] [r (cdr result)] [reconstructed (poly-add (poly-mul q p2) r)]) (and (poly-equal? p1 reconstructed) (< (poly-degree r) (poly-degree p2))))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 2 3 4))] [p2 (make-polynomial Q-field '(1 1))] [result (poly-divmod p1 p2)] [q (car result)] [r (cdr result)] [reconstructed (poly-add (poly-mul q p2) r)]) (and (poly-equal? p1 reconstructed) (< (poly-degree r) (poly-degree p2)))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-divmod"], "split": "train", "prompt": "Verify division algorithm: for random p1, p2, we have p1 = q*p2 + r with deg(r) < deg(p2).\n\nEnsure `poly-divmod` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Verify GCD of (x+1)^2*(x+2) and (x+1)*(x+2)^2 is (x+1)*(x+2) up to monic scaling.\n\nEnsure `poly-gcd` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xp2 (make-polynomial Q-field '(2 1))] [p1 (poly-mul (poly-mul xp1 xp1) xp2)] [p2 (poly-mul xp1 (poly-mul xp2 xp2))] [g (poly-gcd p1 p2)] [expected (poly-mul xp1 xp2)]) (poly-equal? g (poly-make-monic expected)))", "verify_expr": "(equal? (let* ([xp1 (make-polynomial Q-field '(1 1))] [xp2 (make-polynomial Q-field '(2 1))] [p1 (poly-mul (poly-mul xp1 xp1) xp2)] [p2 (poly-mul xp1 (poly-mul xp2 xp2))] [g (poly-gcd p1 p2)] [expected (poly-mul xp1 xp2)]) (poly-equal? g (poly-make-monic expected))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-gcd"], "split": "train", "prompt": "Verify GCD of (x+1)^2*(x+2) and (x+1)*(x+2)^2 is (x+1)*(x+2) up to monic scaling.\n\nEnsure `poly-gcd` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-gcd", "prompt_body": "Verify GCD of any polynomial with itself is the monic version of itself.\n\nEnsure `poly-gcd` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(2 4 2))] [g (poly-gcd p p)]) (poly-equal? g (poly-make-monic p)))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(2 4 2))] [g (poly-gcd p p)]) (poly-equal? g (poly-make-monic p))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-gcd"], "split": "train", "prompt": "Verify GCD of any polynomial with itself is the monic version of itself.\n\nEnsure `poly-gcd` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Verify evaluation of (x+1)^3 at x=2 equals 27.\n\nEnsure `poly-eval` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [cubed (poly-power xp1 3)]) (= (poly-eval cubed 2) 27))", "verify_expr": "(equal? (let* ([xp1 (make-polynomial Q-field '(1 1))] [cubed (poly-power xp1 3)]) (= (poly-eval cubed 2) 27)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-eval"], "split": "train", "prompt": "Verify evaluation of (x+1)^3 at x=2 equals 27.\n\nEnsure `poly-eval` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-eval", "prompt_body": "Verify polynomial evaluation is homomorphism: eval(p1*p2, a) = eval(p1,a) * eval(p2,a).\n\nEnsure `poly-eval` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(2 3))] [prod (poly-mul p1 p2)] [a 5]) (= (poly-eval prod a) (* (poly-eval p1 a) (poly-eval p2 a))))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(2 3))] [prod (poly-mul p1 p2)] [a 5]) (= (poly-eval prod a) (* (poly-eval p1 a) (poly-eval p2 a)))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-eval"], "split": "train", "prompt": "Verify polynomial evaluation is homomorphism: eval(p1*p2, a) = eval(p1,a) * eval(p2,a).\n\nEnsure `poly-eval` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Verify product rule: d/dx(p1*p2) = p1'*p2 + p1*p2'.\n\nEnsure `poly-derivative` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(2 3))] [prod (poly-mul p1 p2)] [d-prod (poly-derivative prod)] [lhs (poly-add (poly-mul (poly-derivative p1) p2) (poly-mul p1 (poly-derivative p2)))]) (poly-equal? d-prod lhs))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(2 3))] [prod (poly-mul p1 p2)] [d-prod (poly-derivative prod)] [lhs (poly-add (poly-mul (poly-derivative p1) p2) (poly-mul p1 (poly-derivative p2)))]) (poly-equal? d-prod lhs)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-derivative"], "split": "train", "prompt": "Verify product rule: d/dx(p1*p2) = p1'*p2 + p1*p2'.\n\nEnsure `poly-derivative` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-derivative", "prompt_body": "Verify derivative of constant is zero.\n\nEnsure `poly-derivative` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([c (poly-constant Q-field 42)]) (poly-zero? (poly-derivative c)))", "verify_expr": "(equal? (let* ([c (poly-constant Q-field 42)]) (poly-zero? (poly-derivative c))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-derivative"], "split": "train", "prompt": "Verify derivative of constant is zero.\n\nEnsure `poly-derivative` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Verify square-free part of (x+1)^3 is (x+1).\n\nEnsure `poly-square-free` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [cubed (poly-power xp1 3)] [sf (poly-square-free cubed)]) (poly-equal? sf (poly-make-monic xp1)))", "verify_expr": "(equal? (let* ([xp1 (make-polynomial Q-field '(1 1))] [cubed (poly-power xp1 3)] [sf (poly-square-free cubed)]) (poly-equal? sf (poly-make-monic xp1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-square-free"], "split": "train", "prompt": "Verify square-free part of (x+1)^3 is (x+1).\n\nEnsure `poly-square-free` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Interpolate linear function through two points and verify linearity.\n\nEnsure `poly-lagrange-interpolate` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([points '((0 . 3) (1 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-degree p) 1) (= (poly-eval p 0) 3) (= (poly-eval p 1) 5) (= (poly-eval p 2) 7)))", "verify_expr": "(equal? (let* ([points '((0 . 3) (1 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-degree p) 1) (= (poly-eval p 0) 3) (= (poly-eval p 1) 5) (= (poly-eval p 2) 7))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-lagrange-interpolate"], "split": "train", "prompt": "Interpolate linear function through two points and verify linearity.\n\nEnsure `poly-lagrange-interpolate` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Newton interpolate through (0,1), (1,2), (2,3), (3,5) and verify all points.\n\nEnsure `poly-newton-interpolate` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([points '((0 . 1) (1 . 2) (2 . 3) (3 . 5))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 3) (= (poly-eval p 3) 5)))", "verify_expr": "(equal? (let* ([points '((0 . 1) (1 . 2) (2 . 3) (3 . 5))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 3) (= (poly-eval p 3) 5))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-newton-interpolate"], "split": "train", "prompt": "Newton interpolate through (0,1), (1,2), (2,3), (3,5) and verify all points.\n\nEnsure `poly-newton-interpolate` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly->string", "prompt_body": "Convert x^2 + 2x + 1 to string and verify format.\n\nEnsure `poly->string` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\"))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(1 2 1))]) (string=? (poly->string p) \"x^2 + 2x + 1\")) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly->string"], "split": "train", "prompt": "Convert x^2 + 2x + 1 to string and verify format.\n\nEnsure `poly->string` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Create Q[x] polynomial ring and verify ring axioms: a + 0 = a, a * 1 = a.\n\nEnsure `make-polynomial-ring` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([R (make-polynomial-ring Q-field)] [a (make-polynomial Q-field '(2 3 1))] [zero (ring-zero R)] [one (ring-one R)]) (and (poly-equal? (ring-add R a zero) a) (poly-equal? (ring-mul R a one) a)))", "verify_expr": "(equal? (let* ([R (make-polynomial-ring Q-field)] [a (make-polynomial Q-field '(2 3 1))] [zero (ring-zero R)] [one (ring-one R)]) (and (poly-equal? (ring-add R a zero) a) (poly-equal? (ring-mul R a one) a))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "make-polynomial-ring"], "split": "train", "prompt": "Create Q[x] polynomial ring and verify ring axioms: a + 0 = a, a * 1 = a.\n\nEnsure `make-polynomial-ring` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Verify polynomial ring has correct additive inverses.\n\nEnsure `make-polynomial-ring` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([R (make-polynomial-ring Q-field)] [a (make-polynomial Q-field '(1 2 3))]) (poly-zero? (ring-add R a (ring-neg R a))))", "verify_expr": "(equal? (let* ([R (make-polynomial-ring Q-field)] [a (make-polynomial Q-field '(1 2 3))]) (poly-zero? (ring-add R a (ring-neg R a)))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "make-polynomial-ring"], "split": "train", "prompt": "Verify polynomial ring has correct additive inverses.\n\nEnsure `make-polynomial-ring` is part of the composed solution.\nReturn only the final Fold expression."}
