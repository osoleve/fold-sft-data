{"id": "fp_parsing_fsm_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-literal`\nSpec: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nWrite exactly one Scheme function definition for `fsm-literal`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-literal`\nSpec: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nWrite exactly one Scheme function definition for `fsm-literal`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-literal str)\n  ;; TODO: fold concatenation of char-machines; handle empty string\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-literal`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-literal str)\n  ;; TODO: fold concatenation of char-machines; handle empty string\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-literal`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `fsm-literal` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-literal`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `fsm-literal` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-literal`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-literal`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-literal`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-literal`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (literal-fsm s)\n  (let ([chs (string->list s)])\n    (if (null? chs)\n        (fsm-epsilon-lang)\n        (fold-left fsm-concat\n                   (fsm-char (car chs))\n                   (map fsm-char (cdr chs))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-literal`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (literal-fsm s)\n  (let ([chs (string->list s)])\n    (if (null? chs)\n        (fsm-epsilon-lang)\n        (fold-left fsm-concat\n                   (fsm-char (car chs))\n                   (map fsm-char (cdr chs))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-literal`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-literal`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-literal`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-literal`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Literal construction requires concatenation, not union.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-union\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Literal construction requires concatenation, not union.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-union\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Empty literal must accept only empty string via fsm-epsilon-lang.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-char #\\space)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty literal must accept only empty string via fsm-epsilon-lang.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Empty literal must accept only empty string via fsm-epsilon-lang.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-char #\\space)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty literal must accept only empty string via fsm-epsilon-lang.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```"}
{"id": "fp_parsing_fsm_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a 2-state DFA and return delta(q0,'a').\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a))", "verify_expr": "(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-delta", "direct"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild a 2-state DFA and return delta(q0,'a').\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether epsilon-closure handles epsilon cycles without duplicating states.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2))", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "epsilon-closure", "cycle"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether epsilon-closure handles epsilon cycles without duplicating states.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether move from empty state-set is empty.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '()))", "verify_expr": "(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-move", "empty-input"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether move from empty state-set is empty.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck acceptance of literal \"ab\" machine on input \"ab\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\"))", "verify_expr": "(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-accepts?", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCheck acceptance of literal \"ab\" machine on input \"ab\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether fsm-char('a) and fsm-literal(\"a\") agree on \"a\" and \"aa\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\"))))", "verify_expr": "(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-char", "consistency"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether fsm-char('a) and fsm-literal(\"a\") agree on \"a\" and \"aa\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: small integration task across module primitives.\n\nDeterminize a+b machine and test acceptance of \"aaab\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\"))", "verify_expr": "(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "nfa->dfa", "acceptance"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nDeterminize a+b machine and test acceptance of \"aaab\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of empty string.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\"))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "empty"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of empty string.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of \"aa\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\"))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "other-string"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of \"aa\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether complement operation is involutive on probe strings for literal-\"a\" machine.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\"))))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "involution"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether complement operation is involutive on probe strings for literal-\"a\" machine.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
