{"id": "fp_parsing_fsm_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-delta`\nSpec: Return outgoing target states for a single (state,input) transition key, else empty list.\n\nWrite exactly one Scheme function definition for `fsm-delta`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1)) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-delta"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-delta`\nSpec: Return outgoing target states for a single (state,input) transition key, else empty list.\n\nWrite exactly one Scheme function definition for `fsm-delta`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-delta fsm state input)\n  ;; TODO: find transitions for (state,input), return target-state list or empty list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-delta`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '()) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-delta"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-delta fsm state input)\n  ;; TODO: find transitions for (state,input), return target-state list or empty list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-delta`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `fsm-delta` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Return outgoing target states for a single (state,input) transition key, else empty list.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-delta`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '()))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-delta"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `fsm-delta` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Return outgoing target states for a single (state,input) transition key, else empty list.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-delta`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```"}
{"id": "fp_parsing_fsm_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `epsilon-closure`\nSpec: Compute epsilon-reachable states from a start state using graph traversal without revisits.\n\nWrite exactly one Scheme function definition for `epsilon-closure`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `epsilon-closure`\nSpec: Compute epsilon-reachable states from a start state using graph traversal without revisits.\n\nWrite exactly one Scheme function definition for `epsilon-closure`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```"}
{"id": "fp_parsing_fsm_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (epsilon-closure fsm state)\n  ;; TODO: DFS/BFS over epsilon transitions with visited tracking\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `epsilon-closure`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (epsilon-closure fsm state)\n  ;; TODO: DFS/BFS over epsilon transitions with visited tracking\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `epsilon-closure`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `epsilon-closure` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Compute epsilon-reachable states from a start state using graph traversal without revisits.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `epsilon-closure`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1)) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `epsilon-closure` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Compute epsilon-reachable states from a start state using graph traversal without revisits.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `epsilon-closure`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-move`\nSpec: Move from a set of states on one symbol and then epsilon-close the result set.\n\nWrite exactly one Scheme function definition for `fsm-move`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q1) '())] [res (fsm-move m '(q1) #\\a)]) res) '())\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q1) '())] [res (fsm-move m '(q1) #\\a)]) res) '()))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-move"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-move`\nSpec: Move from a set of states on one symbol and then epsilon-close the result set.\n\nWrite exactly one Scheme function definition for `fsm-move`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q1) '())] [res (fsm-move m '(q1) #\\a)]) res) '())\n```"}
{"id": "fp_parsing_fsm_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-move fsm states input)\n  ;; TODO: collect direct transitions from each state then epsilon-close\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-move`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-move"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-move fsm states input)\n  ;; TODO: collect direct transitions from each state then epsilon-close\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-move`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```"}
{"id": "fp_parsing_fsm_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `fsm-move` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Move from a set of states on one symbol and then epsilon-close the result set.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-move`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t)) (equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-move"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `fsm-move` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Move from a set of states on one symbol and then epsilon-close the result set.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-move`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-accepts?`\nSpec: Return boolean acceptance; delegate to assertion-aware run when assertions are present.\n\nWrite exactly one Scheme function definition for `fsm-accepts?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-optional (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t) (equal? (let ([m (fsm-optional (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-accepts?`\nSpec: Return boolean acceptance; delegate to assertion-aware run when assertions are present.\n\nWrite exactly one Scheme function definition for `fsm-accepts?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-optional (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  ;; TODO: use fsm-run or fsm-run-with-assertions depending on assertion presence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-accepts?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f) (equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  ;; TODO: use fsm-run or fsm-run-with-assertions depending on assertion presence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-accepts?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `fsm-accepts?` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Return boolean acceptance; delegate to assertion-aware run when assertions are present.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-accepts?`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `fsm-accepts?` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Return boolean acceptance; delegate to assertion-aware run when assertions are present.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-accepts?`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-char`\nSpec: Build an FSM that accepts exactly one character and nothing else.\n\nWrite exactly one Scheme function definition for `fsm-char`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-char"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-char`\nSpec: Build an FSM that accepts exactly one character and nothing else.\n\nWrite exactly one Scheme function definition for `fsm-char`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-char c)\n  ;; TODO: construct two-state FSM that accepts exactly char c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-char`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t) (equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-char"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-char c)\n  ;; TODO: construct two-state FSM that accepts exactly char c\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-char`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `fsm-char` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly one character and nothing else.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-char`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-char"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `fsm-char` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly one character and nothing else.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-char`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-literal`\nSpec: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nWrite exactly one Scheme function definition for `fsm-literal`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-literal`\nSpec: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nWrite exactly one Scheme function definition for `fsm-literal`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-literal str)\n  ;; TODO: fold concatenation of char-machines; handle empty string\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-literal`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-literal str)\n  ;; TODO: fold concatenation of char-machines; handle empty string\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-literal`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `fsm-literal` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-literal`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `fsm-literal` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Build an FSM that accepts exactly a literal string (empty literal accepts empty only).\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-literal`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `nfa->dfa`\nSpec: Convert assertion-free NFA to DFA via subset construction while preserving language.\n\nWrite exactly one Scheme function definition for `nfa->dfa`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `nfa->dfa`\nSpec: Convert assertion-free NFA to DFA via subset construction while preserving language.\n\nWrite exactly one Scheme function definition for `nfa->dfa`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (nfa->dfa nfa)\n  ;; TODO: subset construction over epsilon-closed state-sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `nfa->dfa`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (nfa->dfa nfa)\n  ;; TODO: subset construction over epsilon-closed state-sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `nfa->dfa`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `nfa->dfa` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Convert assertion-free NFA to DFA via subset construction while preserving language.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `nfa->dfa`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `nfa->dfa` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Convert assertion-free NFA to DFA via subset construction while preserving language.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `nfa->dfa`.\n3. Return only one complete definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-complement`\nSpec: Complement a language by determinizing/completing the machine then flipping accepting states.\n\nWrite exactly one Scheme function definition for `fsm-complement`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "spec-to-code", "fsm-complement"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this FSM utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/fsm.ss\nFunction: `fsm-complement`\nSpec: Complement a language by determinizing/completing the machine then flipping accepting states.\n\nWrite exactly one Scheme function definition for `fsm-complement`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-complement dfa)\n  ;; TODO: determinize+complete then flip accepting states\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-complement`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f) (equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "skeleton-completion", "fsm-complement"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fsm-complement dfa)\n  ;; TODO: determinize+complete then flip accepting states\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fsm-complement`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```"}
{"id": "fp_parsing_fsm_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `fsm-complement` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Complement a language by determinizing/completing the machine then flipping accepting states.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-complement`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "contract-implementation", "fsm-complement"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `fsm-complement` from this FSM contract.\n\nModule: `lattice/fp/parsing/fsm.ss`\nContract focus: Complement a language by determinizing/completing the machine then flipping accepting states.\n\nRequirements:\n1. Preserve transition/acceptance semantics precisely.\n2. Keep exact function name/signature for `fsm-complement`.\n3. Return only one complete definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-delta`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_delta(fsm, state, inp):\n    key = (state, inp)\n    found = fsm.transitions.get(key)\n    return found if found is not None else []\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1)) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-delta"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-delta`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_delta(fsm, state, inp):\n    key = (state, inp)\n    found = fsm.transitions.get(key)\n    return found if found is not None else []\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-delta`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delta m s ch)\n  (let ([k (cons s ch)])\n    (let ([p (assoc k (fsm-transitions m))])\n      (if p (cdr p) '()))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '()) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-delta"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-delta`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delta m s ch)\n  (let ([k (cons s ch)])\n    (let ([p (assoc k (fsm-transitions m))])\n      (if p (cdr p) '()))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-delta`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-delta`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_delta(fsm, state, inp):\n    key = (state, inp)\n    found = fsm.transitions.get(key)\n    return found if found is not None else []\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t) (equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1)))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-delta"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-delta`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-delta`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_delta(fsm, state, inp):\n    key = (state, inp)\n    found = fsm.transitions.get(key)\n    return found if found is not None else []\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))\n```"}
{"id": "fp_parsing_fsm_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `epsilon-closure`.\nReturn only the Scheme definition.\n\n```python\ndef epsilon_closure(fsm, state):\n    frontier = [state]\n    visited = []\n    while frontier:\n        s = frontier.pop(0)\n        if s in visited:\n            continue\n        visited.append(s)\n        frontier = fsm.epsilon_targets(s) + frontier\n    return visited\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `epsilon-closure`.\nReturn only the Scheme definition.\n\n```python\ndef epsilon_closure(fsm, state):\n    frontier = [state]\n    visited = []\n    while frontier:\n        s = frontier.pop(0)\n        if s in visited:\n            continue\n        visited.append(s)\n        frontier = fsm.epsilon_targets(s) + frontier\n    return visited\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```"}
{"id": "fp_parsing_fsm_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `epsilon-closure`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (eps-close m s)\n  (let loop ([frontier (list s)] [seen '()])\n    (if (null? frontier)\n        seen\n        (let ([x (car frontier)])\n          (if (member x seen)\n              (loop (cdr frontier) seen)\n              (let* ([eps (get-all-epsilon-targets m x)]\n                     [next (append eps (cdr frontier))])\n                (loop next (cons x seen))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `epsilon-closure`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (eps-close m s)\n  (let loop ([frontier (list s)] [seen '()])\n    (if (null? frontier)\n        seen\n        (let ([x (car frontier)])\n          (if (member x seen)\n              (loop (cdr frontier) seen)\n              (let* ([eps (get-all-epsilon-targets m x)]\n                     [next (append eps (cdr frontier))])\n                (loop next (cons x seen))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```"}
{"id": "fp_parsing_fsm_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `epsilon-closure`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `epsilon-closure`.\nReturn only the final Scheme definition.\n\n```python\ndef epsilon_closure(fsm, state):\n    frontier = [state]\n    visited = []\n    while frontier:\n        s = frontier.pop(0)\n        if s in visited:\n            continue\n        visited.append(s)\n        frontier = fsm.epsilon_targets(s) + frontier\n    return visited\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1)) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `epsilon-closure`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `epsilon-closure`.\nReturn only the final Scheme definition.\n\n```python\ndef epsilon_closure(fsm, state):\n    frontier = [state]\n    visited = []\n    while frontier:\n        s = frontier.pop(0)\n        if s in visited:\n            continue\n        visited.append(s)\n        frontier = fsm.epsilon_targets(s) + frontier\n    return visited\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q0 c))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)\n```"}
{"id": "fp_parsing_fsm_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-move`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_move(fsm, states, inp):\n    direct = []\n    for s in states:\n        direct = union(direct, fsm_delta(fsm, s, inp))\n    return epsilon_closure_set(fsm, direct)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-move"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-move`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_move(fsm, states, inp):\n    direct = []\n    for s in states:\n        direct = union(direct, fsm_delta(fsm, s, inp))\n    return epsilon_closure_set(fsm, direct)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```"}
{"id": "fp_parsing_fsm_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-move`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (move m states ch)\n  (let* ([targets\n          (fold-left (lambda (acc s)\n                       (union equal? acc (fsm-delta m s ch)))\n                     '()\n                     states)])\n    (epsilon-closure-set m targets)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-move"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-move`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (move m states ch)\n  (let* ([targets\n          (fold-left (lambda (acc s)\n                       (union equal? acc (fsm-delta m s ch)))\n                     '()\n                     states)])\n    (epsilon-closure-set m targets)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```"}
{"id": "fp_parsing_fsm_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-move`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-move`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_move(fsm, states, inp):\n    direct = []\n    for s in states:\n        direct = union(direct, fsm_delta(fsm, s, inp))\n    return epsilon_closure_set(fsm, direct)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t)) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-move"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-move`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-move`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_move(fsm, states, inp):\n    direct = []\n    for s in states:\n        direct = union(direct, fsm_delta(fsm, s, inp))\n    return epsilon_closure_set(fsm, direct)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-accepts?`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_accepts_q(fsm, inp):\n    if not fsm.assertions:\n        return is_just(fsm_run(fsm, inp))\n    return is_just(fsm_run_with_assertions(fsm, inp))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t) (equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-accepts?`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_accepts_q(fsm, inp):\n    if not fsm.assertions:\n        return is_just(fsm_run(fsm, inp))\n    return is_just(fsm_run_with_assertions(fsm, inp))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-accepts?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (accepts? m inp)\n  (if (null? (fsm-assertions m))\n      (just? (fsm-run m inp))\n      (just? (fsm-run-with-assertions m inp))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f) (equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-accepts?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (accepts? m inp)\n  (if (null? (fsm-assertions m))\n      (just? (fsm-run m inp))\n      (just? (fsm-run-with-assertions m inp))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-accepts?`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-accepts?`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_accepts_q(fsm, inp):\n    if not fsm.assertions:\n        return is_just(fsm_run(fsm, inp))\n    return is_just(fsm_run_with_assertions(fsm, inp))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-accepts?`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-accepts?`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_accepts_q(fsm, inp):\n    if not fsm.assertions:\n        return is_just(fsm_run(fsm, inp))\n    return is_just(fsm_run_with_assertions(fsm, inp))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-char`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_char(c):\n    s0 = fsm_fresh_state('q')\n    s1 = fsm_fresh_state('q')\n    return make_fsm([s0, s1], [c], [((s0, c), [s1])], s0, [s1])\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-char"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-char`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_char(c):\n    s0 = fsm_fresh_state('q')\n    s1 = fsm_fresh_state('q')\n    return make_fsm([s0, s1], [c], [((s0, c), [s1])], s0, [s1])\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-char`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (char-fsm c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n    (make-fsm (list s0 s1)\n              (list c)\n              (list (cons (cons s0 c) (list s1)))\n              s0\n              (list s1))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-char"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-char`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (char-fsm c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n    (make-fsm (list s0 s1)\n              (list c)\n              (list (cons (cons s0 c) (list s1)))\n              s0\n              (list s1))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```"}
{"id": "fp_parsing_fsm_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-char`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-char`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_char(c):\n    s0 = fsm_fresh_state('q')\n    s1 = fsm_fresh_state('q')\n    return make_fsm([s0, s1], [c], [((s0, c), [s1])], s0, [s1])\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-char"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-char`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-char`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_char(c):\n    s0 = fsm_fresh_state('q')\n    s1 = fsm_fresh_state('q')\n    return make_fsm([s0, s1], [c], [((s0, c), [s1])], s0, [s1])\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```"}
{"id": "fp_parsing_fsm_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-literal`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-literal`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-literal`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (literal-fsm s)\n  (let ([chs (string->list s)])\n    (if (null? chs)\n        (fsm-epsilon-lang)\n        (fold-left fsm-concat\n                   (fsm-char (car chs))\n                   (map fsm-char (cdr chs))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-literal`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (literal-fsm s)\n  (let ([chs (string->list s)])\n    (if (null? chs)\n        (fsm-epsilon-lang)\n        (fold-left fsm-concat\n                   (fsm-char (car chs))\n                   (map fsm-char (cdr chs))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-literal`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-literal`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-literal`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-literal`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_literal(s):\n    chars = list(s)\n    if not chars:\n        return fsm_epsilon_lang()\n    acc = fsm_char(chars[0])\n    for c in chars[1:]:\n        acc = fsm_concat(acc, fsm_char(c))\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `nfa->dfa`.\nReturn only the Scheme definition.\n\n```python\ndef nfa_to_dfa(nfa):\n    if nfa.assertions:\n        return nfa\n    alphabet = nfa.alphabet\n    start_set = epsilon_closure(nfa, nfa.start)\n    start_name = state_set_to_name(start_set)\n    worklist = [start_set]\n    visited = []\n    dfa_states = [start_name]\n    dfa_trans = []\n    dfa_accepting = []\n    while worklist:\n        current = worklist.pop(0)\n        if current in visited:\n            continue\n        visited.append(current)\n        current_name = state_set_to_name(current)\n        if any(s in nfa.accepting for s in current):\n            dfa_accepting.append(current_name)\n        for sym in alphabet:\n            target_set = fsm_move(nfa, current, sym)\n            if not target_set:\n                continue\n            target_name = state_set_to_name(target_set)\n            dfa_trans.append(((current_name, sym), [target_name]))\n            dfa_states = union(dfa_states, [target_name])\n            worklist.append(target_set)\n    return make_fsm(dfa_states, alphabet, dfa_trans, start_name, dfa_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `nfa->dfa`.\nReturn only the Scheme definition.\n\n```python\ndef nfa_to_dfa(nfa):\n    if nfa.assertions:\n        return nfa\n    alphabet = nfa.alphabet\n    start_set = epsilon_closure(nfa, nfa.start)\n    start_name = state_set_to_name(start_set)\n    worklist = [start_set]\n    visited = []\n    dfa_states = [start_name]\n    dfa_trans = []\n    dfa_accepting = []\n    while worklist:\n        current = worklist.pop(0)\n        if current in visited:\n            continue\n        visited.append(current)\n        current_name = state_set_to_name(current)\n        if any(s in nfa.accepting for s in current):\n            dfa_accepting.append(current_name)\n        for sym in alphabet:\n            target_set = fsm_move(nfa, current, sym)\n            if not target_set:\n                continue\n            target_name = state_set_to_name(target_set)\n            dfa_trans.append(((current_name, sym), [target_name]))\n            dfa_states = union(dfa_states, [target_name])\n            worklist.append(target_set)\n    return make_fsm(dfa_states, alphabet, dfa_trans, start_name, dfa_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```"}
{"id": "fp_parsing_fsm_translation_020", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `nfa->dfa`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (subset-construct nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n          (if (null? worklist)\n              (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n              (let ([current (car worklist)])\n                (if (member current visited)\n                    (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                    (let* ([current-name (state-set->name current)]\n                           [accepting? (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                           [triples\n                            (map (lambda (sym)\n                                   (let* ([target-set (fsm-move nfa current sym)]\n                                          [target-name (if (null? target-set)\n                                                           'dead\n                                                           (state-set->name target-set))])\n                                     (list sym target-set target-name)))\n                                 alphabet)]\n                           [valid (filter (lambda (t) (not (null? (cadr t)))) triples)]\n                           [new-trans\n                            (map (lambda (t)\n                                   (cons (cons current-name (car t))\n                                         (list (caddr t))))\n                                 valid)]\n                           [new-sets (map cadr valid)]\n                           [new-names (map caddr valid)])\n                      (loop (append new-sets (cdr worklist))\n                            (cons current visited)\n                            (union equal? new-names dfa-states)\n                            (append new-trans dfa-trans)\n                            (if accepting?\n                                (cons current-name dfa-accepting)\n                                dfa-accepting))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `nfa->dfa`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (subset-construct nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n          (if (null? worklist)\n              (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n              (let ([current (car worklist)])\n                (if (member current visited)\n                    (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                    (let* ([current-name (state-set->name current)]\n                           [accepting? (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                           [triples\n                            (map (lambda (sym)\n                                   (let* ([target-set (fsm-move nfa current sym)]\n                                          [target-name (if (null? target-set)\n                                                           'dead\n                                                           (state-set->name target-set))])\n                                     (list sym target-set target-name)))\n                                 alphabet)]\n                           [valid (filter (lambda (t) (not (null? (cadr t)))) triples)]\n                           [new-trans\n                            (map (lambda (t)\n                                   (cons (cons current-name (car t))\n                                         (list (caddr t))))\n                                 valid)]\n                           [new-sets (map cadr valid)]\n                           [new-names (map caddr valid)])\n                      (loop (append new-sets (cdr worklist))\n                            (cons current visited)\n                            (union equal? new-names dfa-states)\n                            (append new-trans dfa-trans)\n                            (if accepting?\n                                (cons current-name dfa-accepting)\n                                dfa-accepting))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```"}
{"id": "fp_parsing_fsm_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `nfa->dfa`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `nfa->dfa`.\nReturn only the final Scheme definition.\n\n```python\ndef nfa_to_dfa(nfa):\n    if nfa.assertions:\n        return nfa\n    alphabet = nfa.alphabet\n    start_set = epsilon_closure(nfa, nfa.start)\n    start_name = state_set_to_name(start_set)\n    worklist = [start_set]\n    visited = []\n    dfa_states = [start_name]\n    dfa_trans = []\n    dfa_accepting = []\n    while worklist:\n        current = worklist.pop(0)\n        if current in visited:\n            continue\n        visited.append(current)\n        current_name = state_set_to_name(current)\n        if any(s in nfa.accepting for s in current):\n            dfa_accepting.append(current_name)\n        for sym in alphabet:\n            target_set = fsm_move(nfa, current, sym)\n            if not target_set:\n                continue\n            target_name = state_set_to_name(target_set)\n            dfa_trans.append(((current_name, sym), [target_name]))\n            dfa_states = union(dfa_states, [target_name])\n            worklist.append(target_set)\n    return make_fsm(dfa_states, alphabet, dfa_trans, start_name, dfa_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `nfa->dfa`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `nfa->dfa`.\nReturn only the final Scheme definition.\n\n```python\ndef nfa_to_dfa(nfa):\n    if nfa.assertions:\n        return nfa\n    alphabet = nfa.alphabet\n    start_set = epsilon_closure(nfa, nfa.start)\n    start_name = state_set_to_name(start_set)\n    worklist = [start_set]\n    visited = []\n    dfa_states = [start_name]\n    dfa_trans = []\n    dfa_accepting = []\n    while worklist:\n        current = worklist.pop(0)\n        if current in visited:\n            continue\n        visited.append(current)\n        current_name = state_set_to_name(current)\n        if any(s in nfa.accepting for s in current):\n            dfa_accepting.append(current_name)\n        for sym in alphabet:\n            target_set = fsm_move(nfa, current, sym)\n            if not target_set:\n                continue\n            target_name = state_set_to_name(target_set)\n            dfa_trans.append(((current_name, sym), [target_name]))\n            dfa_states = union(dfa_states, [target_name])\n            worklist.append(target_set)\n    return make_fsm(dfa_states, alphabet, dfa_trans, start_name, dfa_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t)\n```"}
{"id": "fp_parsing_fsm_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-complement`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_complement(dfa):\n    m0 = dfa if fsm_deterministic_q(dfa) else nfa_to_dfa(dfa)\n    m = fsm_complete(m0)\n    non_accepting = [s for s in m.states if s not in m.accepting]\n    return make_fsm(m.states, m.alphabet, m.transitions, m.start, non_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "python-to-scheme", "fsm-complement"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fsm-complement`.\nReturn only the Scheme definition.\n\n```python\ndef fsm_complement(dfa):\n    m0 = dfa if fsm_deterministic_q(dfa) else nfa_to_dfa(dfa)\n    m = fsm_complete(m0)\n    non_accepting = [s for s in m.states if s not in m.accepting]\n    return make_fsm(m.states, m.alphabet, m.transitions, m.start, non_accepting)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```"}
{"id": "fp_parsing_fsm_translation_023", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-complement`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (complement-fsm dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [na (filter (lambda (s) (not (member s (fsm-accepting m))))\n                     (fsm-states m))])\n    (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n              (fsm-start m) na)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "chez-to-fold", "fsm-complement"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `fsm-complement`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (complement-fsm dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [na (filter (lambda (s) (not (member s (fsm-accepting m))))\n                     (fsm-states m))])\n    (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n              (fsm-start m) na)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```"}
{"id": "fp_parsing_fsm_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-complement`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-complement`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_complement(dfa):\n    m0 = dfa if fsm_deterministic_q(dfa) else nfa_to_dfa(dfa)\n    m = fsm_complete(m0)\n    non_accepting = [s for s in m.states if s not in m.accepting]\n    return make_fsm(m.states, m.alphabet, m.transitions, m.start, non_accepting)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "reference-translation", "fsm-complement"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `fsm-complement`.\n\nPreserve observable FSM behavior exactly.\nKeep the target function name/signature as `fsm-complement`.\nReturn only the final Scheme definition.\n\n```python\ndef fsm_complement(dfa):\n    m0 = dfa if fsm_deterministic_q(dfa) else nfa_to_dfa(dfa)\n    m = fsm_complete(m0)\n    non_accepting = [s for s in m.states if s not in m.accepting]\n    return make_fsm(m.states, m.alphabet, m.transitions, m.start, non_accepting)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-delta` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: On hit, fsm-delta must return the target-state list (cdr), not the key pair.\n\n```scheme\n(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (car found) '()))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-delta"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-delta` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: On hit, fsm-delta must return the target-state list (cdr), not the key pair.\n\n```scheme\n(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (car found) '()))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-delta` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Missing transition should return empty list, not a singleton with current state.\n\n```scheme\n(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) (list state)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```", "ground_truth": "(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) '()))))", "verify_expr": "(and (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q0 #\\a) '(q1)) (equal? (fsm-delta m 'q1 #\\a) '()))) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t) (equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-delta"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-delta` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Missing transition should return empty list, not a singleton with current state.\n\n```scheme\n(define (fsm-delta fsm state input)\n  (let ([key (cons state input)])\n       (let ([found (assoc key (fsm-transitions fsm))])\n            (if found (cdr found) (list state)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q0 #\\a) '(q1)))\n(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (equal? (fsm-delta m 'q1 #\\a) '()))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `epsilon-closure` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: epsilon-closure must include recursively epsilon-reachable states, not only start state.\n\n```scheme\n(define (epsilon-closure fsm state)\n  (list state))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: epsilon-closure must include recursively epsilon-reachable states, not only start state.\n\nExpected behavior after patch:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1)))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `epsilon-closure` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: epsilon-closure must include recursively epsilon-reachable states, not only start state.\n\n```scheme\n(define (epsilon-closure fsm state)\n  (list state))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: epsilon-closure must include recursively epsilon-reachable states, not only start state.\n\nExpected behavior after patch:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (= (length c) 3))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```"}
{"id": "fp_parsing_fsm_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `epsilon-closure` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: epsilon-closure must be transitive across epsilon edges, not just one hop from the start state.\n\n```scheme\n(define (epsilon-closure fsm state)\n  (cons state (get-all-epsilon-targets fsm state)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```", "ground_truth": "(define (epsilon-closure fsm state)\n  (let loop ([frontier (list state)] [visited '()])\n       (if (null? frontier)\n           visited\n           (let ([s (car frontier)])\n                (if (member s visited)\n                    (loop (cdr frontier) visited)\n                    (let* ([eps-targets (get-all-epsilon-targets fsm s)]\n                           [new-frontier (append eps-targets (cdr frontier))])\n                          (loop new-frontier (cons s visited))))))))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (= (length c) 3) (not (not (member 'q0 c))) (not (not (member 'q1 c))) (not (not (member 'q2 c))))) (equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1)) (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t)))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "epsilon-closure"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `epsilon-closure` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: epsilon-closure must be transitive across epsilon edges, not just one hop from the start state.\n\n```scheme\n(define (epsilon-closure fsm state)\n  (cons state (get-all-epsilon-targets fsm state)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))\n```\n\nCheck 2:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))\n```"}
{"id": "fp_parsing_fsm_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-move` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: fsm-move must epsilon-close the direct targets before returning.\n\n```scheme\n(define (fsm-move fsm states input)\n  (fold-left (lambda (acc s)\n               (union equal? acc (fsm-delta fsm s input)))\n             '()\n             states))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: fsm-move must epsilon-close the direct targets before returning.\n\nExpected behavior after patch:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t) (equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-move"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-move` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: fsm-move must epsilon-close the direct targets before returning.\n\n```scheme\n(define (fsm-move fsm states input)\n  (fold-left (lambda (acc s)\n               (union equal? acc (fsm-delta fsm s input)))\n             '()\n             states))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: fsm-move must epsilon-close the direct targets before returning.\n\nExpected behavior after patch:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-move` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Returning direct targets only misses epsilon transitions reachable after consuming input.\n\n```scheme\n(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        direct-targets))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```", "ground_truth": "(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        (epsilon-closure-set fsm direct-targets)))", "verify_expr": "(and (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (not (not (member 'q1 res))) (not (not (member 'q2 res))))) (equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t) (equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-move"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-move` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Returning direct targets only misses epsilon transitions reachable after consuming input.\n\n```scheme\n(define (fsm-move fsm states input)\n  (let* ([direct-targets\n          (fold-left (lambda (acc s)\n                             (union equal? acc (fsm-delta fsm s input)))\n                     '()\n                     states)])\n        direct-targets))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (= (length res) 2))\n(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (not (not (member 'q1 res))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-accepts?` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Assertion-bearing FSMs must route through fsm-run-with-assertions.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  (just? (fsm-run fsm input)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-accepts?` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Assertion-bearing FSMs must route through fsm-run-with-assertions.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  (just? (fsm-run fsm input)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (fsm-accepts? plain \"ab\"))\n(let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (not (fsm-accepts? plain \"a\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```"}
{"id": "fp_parsing_fsm_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-accepts?` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: The assertion/no-assertion branch is inverted.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run-with-assertions fsm input))\n      (just? (fsm-run fsm input))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```", "ground_truth": "(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run fsm input))\n      (just? (fsm-run-with-assertions fsm input))))", "verify_expr": "(and (let* ([plain (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [anchored (make-fsm-with-assertions '(q0 q1) '() '() 'q0 '(q1) '() '((q0 anchor start q1)))]) (and (fsm-accepts? plain \"ab\") (not (fsm-accepts? plain \"a\")) (not (fsm-accepts? plain \"b\")) (not (fsm-accepts? plain \"\")) (fsm-accepts? anchored \"\") (not (fsm-accepts? anchored \"a\")))) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f) (equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-accepts?"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-accepts?` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: The assertion/no-assertion branch is inverted.\n\n```scheme\n(define (fsm-accepts? fsm input)\n  (if (null? (fsm-assertions fsm))\n      (just? (fsm-run-with-assertions fsm input))\n      (just? (fsm-run fsm input))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-char` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Accepting state must be the target state s1, not the start state.\n\n```scheme\n(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s0))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f) (equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-char"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-char` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Accepting state must be the target state s1, not the start state.\n\n```scheme\n(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s0))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-char` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Start state must be s0 so one input symbol is required.\n\n```scheme\n(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s1\n                 (list s1))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Start state must be s0 so one input symbol is required.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```", "ground_truth": "(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s0\n                 (list s1))))", "verify_expr": "(and (let ([m (fsm-char #\\x)]) (and (fsm-accepts? m \"x\") (not (fsm-accepts? m \"\")) (not (fsm-accepts? m \"y\")) (not (fsm-accepts? m \"xx\")))) (equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f) (equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-char"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-char` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Start state must be s0 so one input symbol is required.\n\n```scheme\n(define (fsm-char c)\n  (let ([s0 (fsm-fresh-state \"q\")]\n        [s1 (fsm-fresh-state \"q\")])\n       (make-fsm (list s0 s1)\n                 (list c)\n                 (list (cons (cons s0 c) (list s1)))\n                 s1\n                 (list s1))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Start state must be s0 so one input symbol is required.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))\n(let ([m (fsm-char #\\x)]) (not (fsm-accepts? m \"\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Literal construction requires concatenation, not union.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-union\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t) (equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Literal construction requires concatenation, not union.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-union\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Empty literal must accept only empty string via fsm-epsilon-lang.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-char #\\space)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty literal must accept only empty string via fsm-epsilon-lang.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```", "ground_truth": "(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-epsilon-lang)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))", "verify_expr": "(and (let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (and (fsm-accepts? m \"hello\") (not (fsm-accepts? m \"hell\")) (not (fsm-accepts? m \"helloo\")) (not (fsm-accepts? m \"\")) (fsm-accepts? e \"\") (not (fsm-accepts? e \"a\")))) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t) (equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-literal"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-literal` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Empty literal must accept only empty string via fsm-epsilon-lang.\n\n```scheme\n(define (fsm-literal str)\n  (let ([chars (string->list str)])\n       (if (null? chars)\n           (fsm-char #\\space)\n           (fold-left fsm-concat\n                      (fsm-char (car chars))\n                      (map fsm-char (cdr chars))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty literal must accept only empty string via fsm-epsilon-lang.\n\nExpected behavior after patch:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (fsm-accepts? m \"hello\"))\n(let ([m (fsm-literal \"hello\")] [e (fsm-literal \"\")]) (not (fsm-accepts? m \"hell\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)\n```"}
{"id": "fp_parsing_fsm_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nfa->dfa` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Subset construction must start from epsilon-closure and explore reachable subsets/transitions.\n\n```scheme\n(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (list (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (make-fsm (list start-name) alphabet '() start-name '()))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nfa->dfa` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Subset construction must start from epsilon-closure and explore reachable subsets/transitions.\n\n```scheme\n(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (list (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (make-fsm (list start-name) alphabet '() start-name '()))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nfa->dfa` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Initial DFA state is not always accepting; accepting subsets must be computed from NFA accepting membership.\n\n```scheme\n(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (make-fsm (list start-name) alphabet '() start-name (list start-name)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Initial DFA state is not always accepting; accepting subsets must be computed from NFA accepting membership.\n\nExpected behavior after patch:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (equal? (fsm-accepts? nfa-m \"ab\") (fsm-accepts? dfa-m \"ab\")) (equal? (fsm-accepts? nfa-m \"aab\") (fsm-accepts? dfa-m \"aab\")) (equal? (fsm-accepts? nfa-m \"a\") (fsm-accepts? dfa-m \"a\")))) #t)\n```", "ground_truth": "(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (let loop ([worklist (list start-set)]\n                   [visited '()]\n                   [dfa-states (list start-name)]\n                   [dfa-trans '()]\n                   [dfa-accepting '()])\n             (if (null? worklist)\n                 (make-fsm dfa-states alphabet dfa-trans start-name dfa-accepting)\n                 (let ([current (car worklist)])\n                      (if (member current visited)\n                          (loop (cdr worklist) visited dfa-states dfa-trans dfa-accepting)\n                          (let* ([current-name (state-set->name current)]\n                                 [is-accepting\n                                  (exists (lambda (s) (member s (fsm-accepting nfa))) current)]\n                                 [new-trans-and-states\n                                  (map (lambda (sym)\n                                               (let* ([target-set (fsm-move nfa current sym)]\n                                                      [target-name (if (null? target-set)\n                                                                       'dead\n                                                                       (state-set->name target-set))])\n                                                     (list sym target-set target-name)))\n                                       alphabet)]\n                                 [valid-trans (filter (lambda (x) (not (null? (cadr x))))\n                                                      new-trans-and-states)]\n                                 [new-trans (map (lambda (x)\n                                                         (cons (cons current-name (car x))\n                                                               (list (caddr x))))\n                                                 valid-trans)]\n                                 [new-state-sets (map cadr valid-trans)]\n                                 [new-state-names (map caddr valid-trans)])\n                                (loop (append new-state-sets (cdr worklist))\n                                      (cons current visited)\n                                      (union equal? new-state-names dfa-states)\n                                      (append new-trans dfa-trans)\n                                      (if is-accepting\n                                          (cons current-name dfa-accepting)\n                                          dfa-accepting))))))))))", "verify_expr": "(and (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (fsm-deterministic? dfa-m) (fsm-accepts? dfa-m \"ab\") (fsm-accepts? dfa-m \"aab\") (fsm-accepts? dfa-m \"aaab\") (not (fsm-accepts? dfa-m \"\")) (not (fsm-accepts? dfa-m \"a\")) (not (fsm-accepts? dfa-m \"b\")))) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f) (equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (equal? (fsm-accepts? nfa-m \"ab\") (fsm-accepts? dfa-m \"ab\")) (equal? (fsm-accepts? nfa-m \"aab\") (fsm-accepts? dfa-m \"aab\")) (equal? (fsm-accepts? nfa-m \"a\") (fsm-accepts? dfa-m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "nfa->dfa"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nfa->dfa` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Initial DFA state is not always accepting; accepting subsets must be computed from NFA accepting membership.\n\n```scheme\n(define (nfa->dfa nfa)\n  (if (not (null? (fsm-assertions nfa)))\n      nfa\n      (let* ([alphabet (fsm-alphabet nfa)]\n             [start-set (epsilon-closure nfa (fsm-start nfa))]\n             [start-name (state-set->name start-set)])\n        (make-fsm (list start-name) alphabet '() start-name (list start-name)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Initial DFA state is not always accepting; accepting subsets must be computed from NFA accepting membership.\n\nExpected behavior after patch:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))\n(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (equal? (fsm-accepts? nfa-m \"ab\") (fsm-accepts? dfa-m \"ab\")) (equal? (fsm-accepts? nfa-m \"aab\") (fsm-accepts? dfa-m \"aab\")) (equal? (fsm-accepts? nfa-m \"a\") (fsm-accepts? dfa-m \"a\")))) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-complement` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Complement requires completion before flipping acceptance, otherwise missing transitions break semantics.\n\n```scheme\n(define (fsm-complement dfa)\n  (let* ([m (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Complement requires completion before flipping acceptance, otherwise missing transitions break semantics.\n\nExpected behavior after patch:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-complement"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-complement` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Complement requires completion before flipping acceptance, otherwise missing transitions break semantics.\n\n```scheme\n(define (fsm-complement dfa)\n  (let* ([m (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Complement requires completion before flipping acceptance, otherwise missing transitions break semantics.\n\nExpected behavior after patch:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)\n```"}
{"id": "fp_parsing_fsm_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-complement` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Complement must flip to non-accepting states, not keep original accepting set.\n\n```scheme\n(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [accepting (fsm-accepting m)])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) accepting)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```", "ground_truth": "(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [non-accepting (filter (lambda (s) (not (member s (fsm-accepting m))))\n                                (fsm-states m))])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) non-accepting)))", "verify_expr": "(and (let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (and (not (fsm-accepts? comp \"a\")) (fsm-accepts? comp \"\") (fsm-accepts? comp \"aa\"))) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f) (equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "bugfix", "fsm-complement"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fsm-complement` in `lattice/fp/parsing/fsm.ss`.\nKnown issue: Complement must flip to non-accepting states, not keep original accepting set.\n\n```scheme\n(define (fsm-complement dfa)\n  (let* ([m0 (if (fsm-deterministic? dfa) dfa (nfa->dfa dfa))]\n         [m (fsm-complete m0)]\n         [accepting (fsm-accepting m)])\n        (make-fsm (fsm-states m) (fsm-alphabet m) (fsm-transitions m)\n                  (fsm-start m) accepting)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (not (fsm-accepts? comp \"a\")))\n(let* ([accepts-a (fsm-literal \"a\")] [comp (fsm-complement accepts-a)]) (fsm-accepts? comp \"\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)\n```"}
{"id": "fp_parsing_fsm_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a 2-state DFA and return delta(q0,'a').\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a))", "verify_expr": "(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q0 #\\a)) '(q1))", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-delta", "direct"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild a 2-state DFA and return delta(q0,'a').\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a 2-state DFA and return delta(q1,'a') for a missing transition.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a))", "verify_expr": "(equal? (let ([m (dfa '(q0 q1) '(#\\a #\\b) '((q0 #\\a q1) (q1 #\\b q0)) 'q0 '(q1))]) (fsm-delta m 'q1 #\\a)) '())", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-delta", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nBuild a 2-state DFA and return delta(q1,'a') for a missing transition.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether delta result is list-valued for present transition.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a)))", "verify_expr": "(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (list? (fsm-delta m 'q0 #\\a))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-delta", "shape"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether delta result is list-valued for present transition.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-delta", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether two missing transitions both yield empty lists.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '())))", "verify_expr": "(equal? (let ([m (dfa '(q0 q1) '(#\\a) '((q0 #\\a q1)) 'q0 '(q1))]) (and (equal? (fsm-delta m 'q1 #\\a) '()) (equal? (fsm-delta m 'q1 #\\z) '()))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-delta", "missing"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether two missing transitions both yield empty lists.\n\nEnsure `fsm-delta` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute epsilon-closure from q0 in q0->q1->q2 epsilon chain.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (list (member 'q0 c) (member 'q1 c) (member 'q2 c)))", "verify_expr": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (and (member 'q0 c) (member 'q1 c) (member 'q2 c) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "epsilon-closure", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute epsilon-closure from q0 in q0->q1->q2 epsilon chain.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: small integration task across module primitives.\n\nCompute epsilon-closure of state with no epsilon edges.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c)", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '())] [c (epsilon-closure m 'q1)]) c) '(q1))", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "epsilon-closure", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute epsilon-closure of state with no epsilon edges.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether epsilon-closure handles epsilon cycles without duplicating states.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2))", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) '() 'q0 '(q1) '((q0 q1) (q1 q0)))] [c (epsilon-closure m 'q0)]) (= (length c) 2)) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "epsilon-closure", "cycle"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether epsilon-closure handles epsilon cycles without duplicating states.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "epsilon-closure", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether q0 epsilon-closure includes q2 in transitive chain q0->q1->q2.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (member 'q2 c))", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) '() 'q0 '(q2) '((q0 q1) (q1 q2)))] [c (epsilon-closure m 'q0)]) (not (not (member 'q2 c)))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "epsilon-closure", "transitive"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether q0 epsilon-closure includes q2 in transitive chain q0->q1->q2.\n\nEnsure `epsilon-closure` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: small integration task across module primitives.\n\nMove from {q0} on 'a' then epsilon-close q1->q2.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) res)", "verify_expr": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q2) '((q1 q2)))] [res (fsm-move m '(q0) #\\a)]) (and (= (length res) 2) (member 'q1 res) (member 'q2 res) #t))", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-move", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMove from {q0} on 'a' then epsilon-close q1->q2.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn move result for symbol with no outgoing edges.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (make-fsm '(q0 q1) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q1) '())] [res (fsm-move m '(q1) #\\a)]) res)", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1) '(#\\a) (list (cons (cons 'q0 #\\a) '(q1))) 'q0 '(q1) '())] [res (fsm-move m '(q1) #\\a)]) res) '())", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-move", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn move result for symbol with no outgoing edges.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMove from multiple states and return whether union behavior includes both branches.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2))))", "verify_expr": "(equal? (let* ([m (make-fsm '(q0 q1 q2) '(#\\a) (list (cons (cons 'q0 #\\a) '(q2)) (cons (cons 'q1 #\\a) '(q2))) 'q0 '(q2) '())] [res (fsm-move m '(q0 q1) #\\a)]) (and (= (length res) 1) (equal? res '(q2)))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-move", "set-union"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nMove from multiple states and return whether union behavior includes both branches.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-move", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether move from empty state-set is empty.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '()))", "verify_expr": "(equal? (let* ([m (fsm-char #\\a)] [res (fsm-move m '() #\\a)]) (equal? res '())) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-move", "empty-input"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether move from empty state-set is empty.\n\nEnsure `fsm-move` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck acceptance of literal \"ab\" machine on input \"ab\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\"))", "verify_expr": "(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"ab\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-accepts?", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCheck acceptance of literal \"ab\" machine on input \"ab\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck rejection of literal \"ab\" machine on input \"a\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\"))", "verify_expr": "(equal? (let ([m (fsm-concat (fsm-char #\\a) (fsm-char #\\b))]) (fsm-accepts? m \"a\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-accepts?", "rejection"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCheck rejection of literal \"ab\" machine on input \"a\".\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether star machine accepts empty string and repeated symbol.\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\")))", "verify_expr": "(equal? (let ([m (fsm-star (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"aaa\"))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-accepts?", "star"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether star machine accepts empty string and repeated symbol.\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-accepts?`\n- `fsm-char`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-accepts?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether optional machine accepts empty and single symbol but rejects double symbol.\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (fsm-optional (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\"))))", "verify_expr": "(equal? (let ([m (fsm-optional (fsm-char #\\a))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-accepts?", "optional"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether optional machine accepts empty and single symbol but rejects double symbol.\n\nEnsure `fsm-accepts?` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: small integration task across module primitives.\n\nBuild fsm-char for 'x and check acceptance of \"x\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\"))", "verify_expr": "(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"x\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-char", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild fsm-char for 'x and check acceptance of \"x\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: small integration task across module primitives.\n\nBuild fsm-char for 'x and check rejection of empty string.\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\"))", "verify_expr": "(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-char", "empty"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild fsm-char for 'x and check rejection of empty string.\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild fsm-char for 'x and check rejection of \"xx\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\"))", "verify_expr": "(equal? (let ([m (fsm-char #\\x)]) (fsm-accepts? m \"xx\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-char", "exact-length"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild fsm-char for 'x and check rejection of \"xx\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-char", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether fsm-char('a) and fsm-literal(\"a\") agree on \"a\" and \"aa\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\"))))", "verify_expr": "(equal? (let ([m1 (fsm-char #\\a)] [m2 (fsm-literal \"a\")]) (and (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")) (equal? (fsm-accepts? m1 \"aa\") (fsm-accepts? m2 \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-char", "consistency"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether fsm-char('a) and fsm-literal(\"a\") agree on \"a\" and \"aa\".\n\nEnsure `fsm-char` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild literal machine for \"hello\" and test acceptance of exact literal.\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\"))", "verify_expr": "(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hello\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-literal", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nBuild literal machine for \"hello\" and test acceptance of exact literal.\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild literal machine for \"hello\" and test rejection of prefix \"hell\".\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\"))", "verify_expr": "(equal? (let ([m (fsm-literal \"hello\")]) (fsm-accepts? m \"hell\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-literal", "prefix"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nBuild literal machine for \"hello\" and test rejection of prefix \"hell\".\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: small integration task across module primitives.\n\nBuild literal machine for empty string and test empty acceptance plus non-empty rejection.\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\"))))", "verify_expr": "(equal? (let ([m (fsm-literal \"\")]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-literal", "empty-literal"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild literal machine for empty string and test empty acceptance plus non-empty rejection.\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-literal", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether concatenating fsm-char('a) and fsm-char('b) matches fsm-literal(\"ab\").\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-literal`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\"))))", "verify_expr": "(equal? (let ([m1 (fsm-concat (fsm-char #\\a) (fsm-char #\\b))] [m2 (fsm-literal \"ab\")]) (and (equal? (fsm-accepts? m1 \"ab\") (fsm-accepts? m2 \"ab\")) (equal? (fsm-accepts? m1 \"a\") (fsm-accepts? m2 \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-literal", "consistency"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether concatenating fsm-char('a) and fsm-char('b) matches fsm-literal(\"ab\").\n\nEnsure `fsm-literal` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-literal`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: compose existing APIs into one expression.\n\nDeterminize machine for a+b and return whether resulting machine is deterministic.\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m))", "verify_expr": "(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-deterministic? dfa-m)) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "nfa->dfa", "determinization"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nDeterminize machine for a+b and return whether resulting machine is deterministic.\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: small integration task across module primitives.\n\nDeterminize a+b machine and test acceptance of \"aaab\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\"))", "verify_expr": "(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"aaab\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "nfa->dfa", "acceptance"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nDeterminize a+b machine and test acceptance of \"aaab\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: compose existing APIs into one expression.\n\nDeterminize a+b machine and verify rejection of \"b\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\"))", "verify_expr": "(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (fsm-accepts? dfa-m \"b\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "nfa->dfa", "rejection"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nDeterminize a+b machine and verify rejection of \"b\".\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_fsm_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "nfa->dfa", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether NFA and determinized DFA agree on three probe strings.\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (equal? (fsm-accepts? nfa-m \"ab\") (fsm-accepts? dfa-m \"ab\")) (equal? (fsm-accepts? nfa-m \"aab\") (fsm-accepts? dfa-m \"aab\")) (equal? (fsm-accepts? nfa-m \"a\") (fsm-accepts? dfa-m \"a\"))))", "verify_expr": "(equal? (let* ([nfa-m (fsm-concat (fsm-plus (fsm-char #\\a)) (fsm-char #\\b))] [dfa-m (nfa->dfa nfa-m)]) (and (equal? (fsm-accepts? nfa-m \"ab\") (fsm-accepts? dfa-m \"ab\")) (equal? (fsm-accepts? nfa-m \"aab\") (fsm-accepts? dfa-m \"aab\")) (equal? (fsm-accepts? nfa-m \"a\") (fsm-accepts? dfa-m \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "nfa->dfa", "equivalence"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether NFA and determinized DFA agree on three probe strings.\n\nEnsure `nfa->dfa` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `nfa->dfa`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: small integration task across module primitives.\n\nComplement literal-\"a\" machine and check rejection of \"a\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\"))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"a\")) #f)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nComplement literal-\"a\" machine and check rejection of \"a\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of empty string.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\"))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "empty"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of empty string.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_fsm_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of \"aa\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\"))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [comp (fsm-complement m)]) (fsm-accepts? comp \"aa\")) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "other-string"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nComplement literal-\"a\" machine and check acceptance of \"aa\".\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `fsm-complement`\n- `fsm-literal`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_fsm_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/fsm.ss", "source_test": "lattice/fp/parsing/test-fsm.ss", "source_function": "fsm-complement", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether complement operation is involutive on probe strings for literal-\"a\" machine.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\"))))", "verify_expr": "(equal? (let* ([m (fsm-literal \"a\")] [c1 (fsm-complement m)] [c2 (fsm-complement c1)]) (and (equal? (fsm-accepts? m \"\") (fsm-accepts? c2 \"\")) (equal? (fsm-accepts? m \"a\") (fsm-accepts? c2 \"a\")) (equal? (fsm-accepts? m \"aa\") (fsm-accepts? c2 \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "fsm", "composition", "fsm-complement", "involution"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether complement operation is involutive on probe strings for literal-\"a\" machine.\n\nEnsure `fsm-complement` is part of the composed solution.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
