{"id": "info_model_selection_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `log-likelihood-gaussian`\nSpec: Compute maximized Gaussian log-likelihood from a residual list via sigma^2 = mean squared residual.\n\nWrite exactly one Scheme function definition for `log-likelihood-gaussian`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "log-likelihood-gaussian"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `log-likelihood-gaussian`\nSpec: Compute maximized Gaussian log-likelihood from a residual list via sigma^2 = mean squared residual.\n\nWrite exactly one Scheme function definition for `log-likelihood-gaussian`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  ;; TODO: compute maximized Gaussian log-likelihood from list residuals\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `log-likelihood-gaussian`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "log-likelihood-gaussian"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  ;; TODO: compute maximized Gaussian log-likelihood from list residuals\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `log-likelihood-gaussian`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `log-likelihood-gaussian-vec`\nSpec: Vector variant of Gaussian log-likelihood; must match list behavior for equivalent residuals.\n\nWrite exactly one Scheme function definition for `log-likelihood-gaussian-vec`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "log-likelihood-gaussian-vec"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `log-likelihood-gaussian-vec`\nSpec: Vector variant of Gaussian log-likelihood; must match list behavior for equivalent residuals.\n\nWrite exactly one Scheme function definition for `log-likelihood-gaussian-vec`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  ;; TODO: compute maximized Gaussian log-likelihood from vector residuals\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `log-likelihood-gaussian-vec`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "log-likelihood-gaussian-vec"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  ;; TODO: compute maximized Gaussian log-likelihood from vector residuals\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `log-likelihood-gaussian-vec`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aic`\nSpec: Compute Akaike Information Criterion: AIC = -2*logL + 2*k.\n\nWrite exactly one Scheme function definition for `aic`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "aic"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aic`\nSpec: Compute Akaike Information Criterion: AIC = -2*logL + 2*k.\n\nWrite exactly one Scheme function definition for `aic`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aic log-lik k)\n  ;; TODO: AIC = -2*logL + 2*k\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aic`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "aic"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aic log-lik k)\n  ;; TODO: AIC = -2*logL + 2*k\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aic`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `bic`\nSpec: Compute Bayesian Information Criterion: BIC = -2*logL + k*log(n).\n\nWrite exactly one Scheme function definition for `bic`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "bic"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `bic`\nSpec: Compute Bayesian Information Criterion: BIC = -2*logL + k*log(n).\n\nWrite exactly one Scheme function definition for `bic`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bic log-lik k n)\n  ;; TODO: BIC = -2*logL + k*log(n)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bic`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "bic"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bic log-lik k n)\n  ;; TODO: BIC = -2*logL + k*log(n)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bic`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aicc`\nSpec: Compute corrected AIC for small samples; return +inf.0 when n <= k+1.\n\nWrite exactly one Scheme function definition for `aicc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "aicc"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aicc`\nSpec: Compute corrected AIC for small samples; return +inf.0 when n <= k+1.\n\nWrite exactly one Scheme function definition for `aicc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aicc log-lik k n)\n  ;; TODO: corrected AIC with +inf.0 when n <= k+1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aicc`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "aicc"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aicc log-lik k n)\n  ;; TODO: corrected AIC with +inf.0 when n <= k+1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aicc`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aic-weights`\nSpec: Convert a list of AIC scores to normalized Akaike weights that sum to 1.\n\nWrite exactly one Scheme function definition for `aic-weights`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "aic-weights"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `aic-weights`\nSpec: Convert a list of AIC scores to normalized Akaike weights that sum to 1.\n\nWrite exactly one Scheme function definition for `aic-weights`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aic-weights aic-values)\n  ;; TODO: delta-shift by min AIC, exponentiate, and normalize to sum 1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aic-weights`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "aic-weights"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aic-weights aic-values)\n  ;; TODO: delta-shift by min AIC, exponentiate, and normalize to sum 1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aic-weights`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_model_selection_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `evidence-ratio`\nSpec: Compute relative support w_i / w_j with +inf.0 when denominator weight is non-positive.\n\nWrite exactly one Scheme function definition for `evidence-ratio`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "evidence-ratio"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `evidence-ratio`\nSpec: Compute relative support w_i / w_j with +inf.0 when denominator weight is non-positive.\n\nWrite exactly one Scheme function definition for `evidence-ratio`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_model_selection_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  ;; TODO: return w-i / w-j with +inf.0 guard for non-positive denominator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `evidence-ratio`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "evidence-ratio"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  ;; TODO: return w-i / w-j with +inf.0 guard for non-positive denominator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `evidence-ratio`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_model_selection_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `residual-entropy-bits`\nSpec: Estimate Gaussian differential entropy in bits from residual variance; return -inf.0 for zero variance.\n\nWrite exactly one Scheme function definition for `residual-entropy-bits`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "residual-entropy-bits"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `residual-entropy-bits`\nSpec: Estimate Gaussian differential entropy in bits from residual variance; return -inf.0 for zero variance.\n\nWrite exactly one Scheme function definition for `residual-entropy-bits`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_model_selection_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (residual-entropy-bits residuals)\n  ;; TODO: convert residual variance to Gaussian entropy in bits\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `residual-entropy-bits`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "skeleton-completion", "residual-entropy-bits"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (residual-entropy-bits residuals)\n  ;; TODO: convert residual variance to Gaussian entropy in bits\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `residual-entropy-bits`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_model_selection_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `log-likelihood-gaussian`.\nReturn only the Scheme definition.\n\n```python\ndef log_likelihood_gaussian(residuals):\n    n = len(residuals)\n    ss = sum(r * r for r in residuals)\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return 0\n    return -0.5 * n * (1 + log(2 * pi * sigma2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "log-likelihood-gaussian"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `log-likelihood-gaussian`.\nReturn only the Scheme definition.\n\n```python\ndef log_likelihood_gaussian(residuals):\n    n = len(residuals)\n    ss = sum(r * r for r in residuals)\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return 0\n    return -0.5 * n * (1 + log(2 * pi * sigma2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_model_selection_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `log-likelihood-gaussian`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (gaussian-ll residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "log-likelihood-gaussian"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `log-likelihood-gaussian`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (gaussian-ll residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `log-likelihood-gaussian-vec`.\nReturn only the Scheme definition.\n\n```python\ndef log_likelihood_gaussian_vec(residuals_vec):\n    n = len(residuals_vec)\n    ss = 0.0\n    for r in residuals_vec:\n        ss += r * r\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return 0\n    return -0.5 * n * (1 + log(2 * pi * sigma2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "log-likelihood-gaussian-vec"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `log-likelihood-gaussian-vec`.\nReturn only the Scheme definition.\n\n```python\ndef log_likelihood_gaussian_vec(residuals_vec):\n    n = len(residuals_vec)\n    ss = 0.0\n    for r in residuals_vec:\n        ss += r * r\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return 0\n    return -0.5 * n * (1 + log(2 * pi * sigma2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `log-likelihood-gaussian-vec`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (gaussian-ll-vec residuals)\n  (let* ([n (vector-length residuals)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "log-likelihood-gaussian-vec"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `log-likelihood-gaussian-vec`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (gaussian-ll-vec residuals)\n  (let* ([n (vector-length residuals)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_model_selection_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aic`.\nReturn only the Scheme definition.\n\n```python\ndef aic(log_lik, k):\n    return -2 * log_lik + 2 * k\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "aic"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aic`.\nReturn only the Scheme definition.\n\n```python\ndef aic(log_lik, k):\n    return -2 * log_lik + 2 * k\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_model_selection_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aic`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aic0 log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "aic"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aic`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aic0 log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_model_selection_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bic`.\nReturn only the Scheme definition.\n\n```python\ndef bic(log_lik, k, n):\n    return -2 * log_lik + k * log(n)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "bic"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bic`.\nReturn only the Scheme definition.\n\n```python\ndef bic(log_lik, k, n):\n    return -2 * log_lik + k * log(n)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_model_selection_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `bic`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (bic0 log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "bic"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `bic`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (bic0 log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aicc`.\nReturn only the Scheme definition.\n\n```python\ndef aicc(log_lik, k, n):\n    base = aic(log_lik, k)\n    if n - k - 1 <= 0:\n        return float('inf')\n    return base + (2 * k * (k + 1)) / (n - k - 1)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "aicc"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aicc`.\nReturn only the Scheme definition.\n\n```python\ndef aicc(log_lik, k, n):\n    base = aic(log_lik, k)\n    if n - k - 1 <= 0:\n        return float('inf')\n    return base + (2 * k * (k + 1)) / (n - k - 1)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aicc`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aicc0 log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "aicc"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aicc`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aicc0 log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aic-weights`.\nReturn only the Scheme definition.\n\n```python\ndef aic_weights(aic_values):\n    if not aic_values:\n        return []\n    a_min = min(aic_values)\n    deltas = [a - a_min for a in aic_values]\n    raw = [exp(-0.5 * d) for d in deltas]\n    total = sum(raw)\n    if total <= 0:\n        return [1.0 / len(aic_values) for _ in aic_values]\n    return [w / total for w in raw]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "aic-weights"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aic-weights`.\nReturn only the Scheme definition.\n\n```python\ndef aic_weights(aic_values):\n    if not aic_values:\n        return []\n    a_min = min(aic_values)\n    deltas = [a - a_min for a in aic_values]\n    raw = [exp(-0.5 * d) for d in deltas]\n    total = sum(raw)\n    if total <= 0:\n        return [1.0 / len(aic_values) for _ in aic_values]\n    return [w / total for w in raw]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_model_selection_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aic-weights`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aic-weights0 aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([a-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a a-min)) aic-values)]\n             [raw (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "aic-weights"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `aic-weights`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (aic-weights0 aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([a-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a a-min)) aic-values)]\n             [raw (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `evidence-ratio`.\nReturn only the Scheme definition.\n\n```python\ndef evidence_ratio(w_i, w_j):\n    if w_j <= 0:\n        return float('inf')\n    return w_i / w_j\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "evidence-ratio"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `evidence-ratio`.\nReturn only the Scheme definition.\n\n```python\ndef evidence_ratio(w_i, w_j):\n    if w_j <= 0:\n        return float('inf')\n    return w_i / w_j\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `evidence-ratio`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (evidence-ratio0 w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "evidence-ratio"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `evidence-ratio`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (evidence-ratio0 w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_model_selection_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `residual-entropy-bits`.\nReturn only the Scheme definition.\n\n```python\ndef residual_entropy_bits(residuals):\n    n = len(residuals)\n    ss = sum(r * r for r in residuals)\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return float('-inf')\n    sigma = sqrt(sigma2)\n    return gaussian_entropy(sigma)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "residual-entropy-bits"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `residual-entropy-bits`.\nReturn only the Scheme definition.\n\n```python\ndef residual_entropy_bits(residuals):\n    n = len(residuals)\n    ss = sum(r * r for r in residuals)\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return float('-inf')\n    sigma = sqrt(sigma2)\n    return gaussian_entropy(sigma)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_model_selection_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `residual-entropy-bits`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (residual-entropy0 residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "residual-entropy-bits"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `residual-entropy-bits`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (residual-entropy0 residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_model_selection_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian` in `lattice/info/model-selection.ss`.\nKnown issue: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* 0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\nExpected behavior after patch:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "bugfix", "log-likelihood-gaussian"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian` in `lattice/info/model-selection.ss`.\nKnown issue: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* 0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\nExpected behavior after patch:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian` in `lattice/info/model-selection.ss`.\nKnown issue: Residual variance must use squared residuals, not absolute values.\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map abs residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Residual variance must use squared residuals, not absolute values.\n\nExpected behavior after patch:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "bugfix", "log-likelihood-gaussian"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian` in `lattice/info/model-selection.ss`.\nKnown issue: Residual variance must use squared residuals, not absolute values.\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map abs residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Residual variance must use squared residuals, not absolute values.\n\nExpected behavior after patch:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_model_selection_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian-vec` in `lattice/info/model-selection.ss`.\nKnown issue: Vector residual accumulation must sum squared residuals.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s r)))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Vector residual accumulation must sum squared residuals.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "bugfix", "log-likelihood-gaussian-vec"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian-vec` in `lattice/info/model-selection.ss`.\nKnown issue: Vector residual accumulation must sum squared residuals.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s r)))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Vector residual accumulation must sum squared residuals.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian-vec` in `lattice/info/model-selection.ss`.\nKnown issue: Degenerate sigma^2<=0 branch should return 0 to match module semantics.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss 0]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Degenerate sigma^2<=0 branch should return 0 to match module semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "bugfix", "log-likelihood-gaussian-vec"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian-vec` in `lattice/info/model-selection.ss`.\nKnown issue: Degenerate sigma^2<=0 branch should return 0 to match module semantics.\n\n```scheme\n(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss 0]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Degenerate sigma^2<=0 branch should return 0 to match module semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic` in `lattice/info/model-selection.ss`.\nKnown issue: AIC uses -2*logL, not +2*logL.\n\n```scheme\n(define (aic log-lik k)\n  (+ (* 2 log-lik) (* 2 k)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: AIC uses -2*logL, not +2*logL.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aic 5 2) -6))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "bugfix", "aic"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic` in `lattice/info/model-selection.ss`.\nKnown issue: AIC uses -2*logL, not +2*logL.\n\n```scheme\n(define (aic log-lik k)\n  (+ (* 2 log-lik) (* 2 k)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: AIC uses -2*logL, not +2*logL.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aic 5 2) -6))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_model_selection_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic` in `lattice/info/model-selection.ss`.\nKnown issue: Parameter penalty should be 2*k, not k.\n\n```scheme\n(define (aic log-lik k)\n  (+ (* -2 log-lik) k))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (and (= (aic 5 2) -6) (= (aic -50 3) 106)))", "tags": ["tier1", "info", "model-selection", "bugfix", "aic"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic` in `lattice/info/model-selection.ss`.\nKnown issue: Parameter penalty should be 2*k, not k.\n\n```scheme\n(define (aic log-lik k)\n  (+ (* -2 log-lik) k))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aic 5 2) -6))\n(let () (= (aic -50 3) 106))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bic` in `lattice/info/model-selection.ss`.\nKnown issue: BIC uses log(n) penalty, not linear n.\n\n```scheme\n(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k n)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: BIC uses log(n) penalty, not linear n.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "bugfix", "bic"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bic` in `lattice/info/model-selection.ss`.\nKnown issue: BIC uses log(n) penalty, not linear n.\n\n```scheme\n(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k n)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: BIC uses log(n) penalty, not linear n.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_model_selection_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bic` in `lattice/info/model-selection.ss`.\nKnown issue: BIC needs -2*logL with negative sign.\n\n```scheme\n(define (bic log-lik k n)\n  (+ (* 2 log-lik) (* k (log-num n))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "bugfix", "bic"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bic` in `lattice/info/model-selection.ss`.\nKnown issue: BIC needs -2*logL with negative sign.\n\n```scheme\n(define (bic log-lik k n)\n  (+ (* 2 log-lik) (* k (log-num n))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_model_selection_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aicc` in `lattice/info/model-selection.ss`.\nKnown issue: AICc must add the finite-sample correction term.\n\n```scheme\n(define (aicc log-lik k n)\n  (aic log-lik k))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: AICc must add the finite-sample correction term.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "bugfix", "aicc"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aicc` in `lattice/info/model-selection.ss`.\nKnown issue: AICc must add the finite-sample correction term.\n\n```scheme\n(define (aicc log-lik k n)\n  (aic log-lik k))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: AICc must add the finite-sample correction term.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_model_selection_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aicc` in `lattice/info/model-selection.ss`.\nKnown issue: Undefined AICc region (n<=k+1) should return +inf.0.\n\n```scheme\n(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Undefined AICc region (n<=k+1) should return +inf.0.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "bugfix", "aicc"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aicc` in `lattice/info/model-selection.ss`.\nKnown issue: Undefined AICc region (n<=k+1) should return +inf.0.\n\n```scheme\n(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Undefined AICc region (n<=k+1) should return +inf.0.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_model_selection_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic-weights` in `lattice/info/model-selection.ss`.\nKnown issue: Weights must exponentiate -0.5*delta before normalization.\n\n```scheme\n(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights deltas]\n             [total (fold-left + 0 raw-weights)])\n        (map (lambda (w) (/ w total)) raw-weights))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "bugfix", "aic-weights"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic-weights` in `lattice/info/model-selection.ss`.\nKnown issue: Weights must exponentiate -0.5*delta before normalization.\n\n```scheme\n(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights deltas]\n             [total (fold-left + 0 raw-weights)])\n        (map (lambda (w) (/ w total)) raw-weights))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic-weights` in `lattice/info/model-selection.ss`.\nKnown issue: Returned weights must be normalized by the total.\n\n```scheme\n(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        raw-weights)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Returned weights must be normalized by the total.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))", "tags": ["tier1", "info", "model-selection", "bugfix", "aic-weights"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aic-weights` in `lattice/info/model-selection.ss`.\nKnown issue: Returned weights must be normalized by the total.\n\n```scheme\n(define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        raw-weights)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Returned weights must be normalized by the total.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([ws (aic-weights '(100 102 105 110))] [same (aic-weights '(100 100 100))] [total (fold-left + 0 ws)]) (and (approx=? 1.0 total 1e-10) (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)) (approx=? (/ 1.0 3) (car same) 1e-10) (approx=? (/ 1.0 3) (cadr same) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_model_selection_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `evidence-ratio` in `lattice/info/model-selection.ss`.\nKnown issue: Evidence ratio is w_i / w_j, not inverted.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  (/ w-j w-i))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Evidence ratio is w_i / w_j, not inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "bugfix", "evidence-ratio"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `evidence-ratio` in `lattice/info/model-selection.ss`.\nKnown issue: Evidence ratio is w_i / w_j, not inverted.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  (/ w-j w-i))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Evidence ratio is w_i / w_j, not inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_model_selection_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `evidence-ratio` in `lattice/info/model-selection.ss`.\nKnown issue: Non-positive denominator should yield +inf.0, not 0.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      0\n      (/ w-i w-j)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "bugfix", "evidence-ratio"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `evidence-ratio` in `lattice/info/model-selection.ss`.\nKnown issue: Non-positive denominator should yield +inf.0, not 0.\n\n```scheme\n(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      0\n      (/ w-i w-j)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_model_selection_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `residual-entropy-bits` in `lattice/info/model-selection.ss`.\nKnown issue: Gaussian entropy helper expects standard deviation sqrt(sigma^2).\n\n```scheme\n(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy sigma2))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "bugfix", "residual-entropy-bits"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `residual-entropy-bits` in `lattice/info/model-selection.ss`.\nKnown issue: Gaussian entropy helper expects standard deviation sqrt(sigma^2).\n\n```scheme\n(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy sigma2))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_model_selection_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `residual-entropy-bits` in `lattice/info/model-selection.ss`.\nKnown issue: Zero-variance branch should return -inf.0 for differential entropy limit.\n\n```scheme\n(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "bugfix", "residual-entropy-bits"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `residual-entropy-bits` in `lattice/info/model-selection.ss`.\nKnown issue: Zero-variance branch should return -inf.0 for differential entropy limit.\n\n```scheme\n(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_model_selection_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute Gaussian log-likelihood for residuals '(1 -1).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(log-likelihood-gaussian '(1 -1))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? (* -0.5 2 (+ 1 (log-num (* 2 (pi-value))))) (log-likelihood-gaussian '(1 -1)) 1e-6))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute Gaussian log-likelihood for residuals '(1 -1).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn Gaussian log-likelihood for perfect residuals '(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(log-likelihood-gaussian '(0 0 0 0))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (= (log-likelihood-gaussian '(0 0 0 0)) 0))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn Gaussian log-likelihood for perfect residuals '(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether tight residuals yield higher (less negative) log-likelihood than wide residuals.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([ll-tight (log-likelihood-gaussian '(0.1 -0.1 0.05 -0.05))] [ll-wide (log-likelihood-gaussian '(3 -2 4 -1))]) (> ll-tight ll-wide))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (equal? (let ([ll-tight (log-likelihood-gaussian '(0.1 -0.1 0.05 -0.05))] [ll-wide (log-likelihood-gaussian '(3 -2 4 -1))]) (> ll-tight ll-wide)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether tight residuals yield higher (less negative) log-likelihood than wide residuals.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether list and vector Gaussian log-likelihood implementations agree on the same residual data.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r '(0.5 -0.3 0.8 -0.2 0.1)]) (approx=? (log-likelihood-gaussian r) (log-likelihood-gaussian-vec (list->vector r)) 1e-10))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([r '(0.5 -0.3 0.8 -0.2 0.1)]) (approx=? (log-likelihood-gaussian r) (log-likelihood-gaussian-vec (list->vector r)) 1e-10)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian", "consistency"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether list and vector Gaussian log-likelihood implementations agree on the same residual data.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute vector Gaussian log-likelihood for #(1 -1).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(log-likelihood-gaussian-vec '#(1 -1))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? (* -0.5 2 (+ 1 (log-num (* 2 (pi-value))))) (log-likelihood-gaussian-vec '#(1 -1)) 1e-6))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian-vec", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute vector Gaussian log-likelihood for #(1 -1).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: small integration task across module primitives.\n\nReturn vector Gaussian log-likelihood for perfect residual vector '#(0 0 0).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(log-likelihood-gaussian-vec '#(0 0 0))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (= (log-likelihood-gaussian-vec '#(0 0 0)) 0))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian-vec", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn vector Gaussian log-likelihood for perfect residual vector '#(0 0 0).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether small vector residual variance leads to higher log-likelihood than large variance.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([ll-small (log-likelihood-gaussian-vec '#(0.2 -0.2 0.1 -0.1))] [ll-large (log-likelihood-gaussian-vec '#(5 -4 3 -2))]) (> ll-small ll-large))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (equal? (let ([ll-small (log-likelihood-gaussian-vec '#(0.2 -0.2 0.1 -0.1))] [ll-large (log-likelihood-gaussian-vec '#(5 -4 3 -2))]) (> ll-small ll-large)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian-vec", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether small vector residual variance leads to higher log-likelihood than large variance.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether vector and list log-likelihood versions are numerically equal on the same sample.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r '(0.5 -0.3 0.8 -0.2 0.1)]) (approx=? (log-likelihood-gaussian-vec (list->vector r)) (log-likelihood-gaussian r) 1e-10))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([r '(0.5 -0.3 0.8 -0.2 0.1)]) (approx=? (log-likelihood-gaussian-vec (list->vector r)) (log-likelihood-gaussian r) 1e-10)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian-vec", "consistency"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether vector and list log-likelihood versions are numerically equal on the same sample.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute AIC for log-likelihood -50 with k=3.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(aic -50 3)", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (= (aic -50 3) 106))", "tags": ["tier1", "info", "model-selection", "composition", "aic", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute AIC for log-likelihood -50 with k=3.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether improved log-likelihood (same k) lowers AIC.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(< (aic -40 3) (aic -50 3))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (equal? (< (aic -40 3) (aic -50 3)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether improved log-likelihood (same k) lowers AIC.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether increasing parameter count raises AIC when log-likelihood is fixed.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(< (aic -50 2) (aic -50 5))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (equal? (< (aic -50 2) (aic -50 5)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether increasing parameter count raises AIC when log-likelihood is fixed.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: small integration task across module primitives.\n\nCompute the AIC difference between k=5 and k=2 at the same log-likelihood -50.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(- (aic -50 5) (aic -50 2))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (= (- (aic -50 5) (aic -50 2)) 6))", "tags": ["tier1", "info", "model-selection", "composition", "aic", "difference"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute the AIC difference between k=5 and k=2 at the same log-likelihood -50.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute BIC for log-likelihood 5, k=2, n=100.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(bic 5 2 100)", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? (+ -10 (* 2 (log-num 100))) (bic 5 2 100) 1e-10))", "tags": ["tier1", "info", "model-selection", "composition", "bic", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute BIC for log-likelihood 5, k=2, n=100.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether BIC penalty increases with sample size when log-likelihood and k are fixed.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(< (bic -50 3 10) (bic -50 3 100))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (equal? (< (bic -50 3 10) (bic -50 3 100)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "bic", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether BIC penalty increases with sample size when log-likelihood and k are fixed.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether BIC is greater than AIC at n=100 and k=3 for log-likelihood -50.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(> (bic -50 3 100) (aic -50 3))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (equal? (> (bic -50 3 100) (aic -50 3)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "bic", "comparison"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether BIC is greater than AIC at n=100 and k=3 for log-likelihood -50.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: small integration task across module primitives.\n\nCompute BIC when k=0 (it should reduce to -2*log-likelihood).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(bic -33 0 500)", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (= (bic -33 0 500) 66))", "tags": ["tier1", "info", "model-selection", "composition", "bic", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute BIC when k=0 (it should reduce to -2*log-likelihood).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute AICc for log-likelihood -50, k=5, n=10.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(aicc -50 5 10)", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 125 (aicc -50 5 10) 1e-10))", "tags": ["tier1", "info", "model-selection", "composition", "aicc", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute AICc for log-likelihood -50, k=5, n=10.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn AICc for undefined finite-sample region n<=k+1 (log-likelihood -50, k=5, n=6).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(aicc -50 5 6)", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (= (aicc -50 5 6) +inf.0))", "tags": ["tier1", "info", "model-selection", "composition", "aicc", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn AICc for undefined finite-sample region n<=k+1 (log-likelihood -50, k=5, n=6).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether AICc converges to AIC for large n (n=10000, k=3, log-likelihood -50).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a (aic -50 3)] [ac (aicc -50 3 10000)]) (< (abs (- a ac)) 0.01))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (equal? (let ([a (aic -50 3)] [ac (aicc -50 3 10000)]) (< (abs (- a ac)) 0.01)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aicc", "limit"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether AICc converges to AIC for large n (n=10000, k=3, log-likelihood -50).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether smaller n implies larger AICc correction for fixed log-likelihood and k.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(> (- (aicc -50 3 20) (aic -50 3)) (- (aicc -50 3 100) (aic -50 3)))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (equal? (> (- (aicc -50 3 20) (aic -50 3)) (- (aicc -50 3 100) (aic -50 3))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aicc", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether smaller n implies larger AICc correction for fixed log-likelihood and k.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute Akaike weights for AIC values '(100 102 105 110).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(aic-weights '(100 102 105 110))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([ws (aic-weights '(100 102 105 110))] [total (fold-left + 0 ws)]) (approx=? 1.0 total 1e-10)))", "tags": ["tier1", "info", "model-selection", "composition", "aic-weights", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute Akaike weights for AIC values '(100 102 105 110).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether the minimum-AIC model receives the highest Akaike weight.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([ws (aic-weights '(100 102 105 110))]) (and (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws))))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (equal? (let ([ws (aic-weights '(100 102 105 110))]) (and (> (car ws) (cadr ws)) (> (cadr ws) (caddr ws)))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic-weights", "ordering"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether the minimum-AIC model receives the highest Akaike weight.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether identical AIC scores produce uniform weights.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([ws (aic-weights '(100 100 100))]) (and (approx=? (/ 1.0 3) (car ws) 1e-10) (approx=? (/ 1.0 3) (cadr ws) 1e-10) (approx=? (/ 1.0 3) (caddr ws) 1e-10)))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([ws (aic-weights '(100 100 100))]) (and (approx=? (/ 1.0 3) (car ws) 1e-10) (approx=? (/ 1.0 3) (cadr ws) 1e-10) (approx=? (/ 1.0 3) (caddr ws) 1e-10))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic-weights", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether identical AIC scores produce uniform weights.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether evidence ratio from first two Akaike weights exceeds 1 for AIC values '(100 102 105 110).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([ws (aic-weights '(100 102 105 110))] [w0 (car ws)] [w1 (cadr ws)]) (> (evidence-ratio w0 w1) 1.0))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (equal? (let* ([ws (aic-weights '(100 102 105 110))] [w0 (car ws)] [w1 (cadr ws)]) (> (evidence-ratio w0 w1) 1.0)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic-weights", "integration"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether evidence ratio from first two Akaike weights exceeds 1 for AIC values '(100 102 105 110).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: small integration task across module primitives.\n\nCompute evidence ratio for weights 0.6 and 0.3.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(evidence-ratio 0.6 0.3)", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))", "tags": ["tier1", "info", "model-selection", "composition", "evidence-ratio", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute evidence ratio for weights 0.6 and 0.3.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute evidence ratio when denominator is 0.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(evidence-ratio 0.5 0.0)", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (= (evidence-ratio 0.5 0.0) +inf.0))", "tags": ["tier1", "info", "model-selection", "composition", "evidence-ratio", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute evidence ratio when denominator is 0.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether evidence ratio is greater than 1 when numerator weight exceeds denominator weight.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(> (evidence-ratio 0.7 0.2) 1.0)", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (equal? (> (evidence-ratio 0.7 0.2) 1.0) #t))", "tags": ["tier1", "info", "model-selection", "composition", "evidence-ratio", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether evidence ratio is greater than 1 when numerator weight exceeds denominator weight.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether forward and reverse evidence ratios are multiplicative inverses for positive weights.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? 1.0 (* (evidence-ratio 0.8 0.2) (evidence-ratio 0.2 0.8)) 1e-10)", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? 1.0 (* (evidence-ratio 0.8 0.2) (evidence-ratio 0.2 0.8)) 1e-10) #t))", "tags": ["tier1", "info", "model-selection", "composition", "evidence-ratio", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether forward and reverse evidence ratios are multiplicative inverses for positive weights.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "info_model_selection_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute residual entropy bits for residuals '(1.0 -0.5 0.3 -0.8 0.2).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (> (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2)) 0))", "tags": ["tier1", "info", "model-selection", "composition", "residual-entropy-bits", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute residual entropy bits for residuals '(1.0 -0.5 0.3 -0.8 0.2).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_model_selection_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether tighter residuals have lower entropy than wide residuals.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(< (residual-entropy-bits '(0.01 -0.01 0.005 -0.008)) (residual-entropy-bits '(5.0 -3.0 4.0 -2.0)))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (equal? (< (residual-entropy-bits '(0.01 -0.01 0.005 -0.008)) (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "residual-entropy-bits", "comparison"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether tighter residuals have lower entropy than wide residuals.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute residual entropy bits for perfect residuals '(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(residual-entropy-bits '(0 0 0 0))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (= (residual-entropy-bits '(0 0 0 0)) -inf.0))", "tags": ["tier1", "info", "model-selection", "composition", "residual-entropy-bits", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute residual entropy bits for perfect residuals '(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_model_selection_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether scaling residuals by 10 increases residual entropy.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([base '(0.4 -0.2 0.1 -0.3)] [scaled '(4.0 -2.0 1.0 -3.0)]) (> (residual-entropy-bits scaled) (residual-entropy-bits base)))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (equal? (let ([base '(0.4 -0.2 0.1 -0.3)] [scaled '(4.0 -2.0 1.0 -3.0)]) (> (residual-entropy-bits scaled) (residual-entropy-bits base))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "residual-entropy-bits", "scaling"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether scaling residuals by 10 increases residual entropy.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
