{"id": "info_model_selection_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian-vec", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `log-likelihood-gaussian-vec`\nSpec: Vector variant of Gaussian log-likelihood; must match list behavior for equivalent residuals.\n\nWrite exactly one Scheme function definition for `log-likelihood-gaussian-vec`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian-vec residuals-vec)\n  (let* ([n (vector-length residuals-vec)]\n         [ss (let loop ([i 0] [s 0])\n               (if (= i n)\n                   s\n                   (let ([r (vector-ref residuals-vec i)])\n                     (loop (+ i 1) (+ s (* r r))))))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([r '(0.5 -0.3 0.8 -0.2 0.1)] [rv (list->vector r)] [ll-list (log-likelihood-gaussian r)] [ll-vec (log-likelihood-gaussian-vec rv)]) (approx=? ll-list ll-vec 1e-10)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "log-likelihood-gaussian-vec"], "split": "eval"}
{"id": "info_model_selection_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "bic", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `bic`\nSpec: Compute Bayesian Information Criterion: BIC = -2*logL + k*log(n).\n\nWrite exactly one Scheme function definition for `bic`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))", "verify_expr": "(let ()\n  (define (bic log-lik k n)\n  (+ (* -2 log-lik) (* k (log-num n))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([result (bic 5 2 100)]) (approx=? (+ -10 (* 2 (log-num 100))) result 1e-10)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "bic"], "split": "eval"}
{"id": "info_model_selection_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "evidence-ratio", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this model-selection utility in Fold-native Scheme.\n\nTarget module: lattice/info/model-selection.ss\nFunction: `evidence-ratio`\nSpec: Compute relative support w_i / w_j with +inf.0 when denominator weight is non-positive.\n\nWrite exactly one Scheme function definition for `evidence-ratio`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10))\n(let () (= (evidence-ratio 0.5 0.0) +inf.0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))", "verify_expr": "(let ()\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 2.0 (evidence-ratio 0.6 0.3) 1e-10) (= (evidence-ratio 0.5 0.0) +inf.0)))", "tags": ["tier1", "info", "model-selection", "spec-to-code", "evidence-ratio"], "split": "eval"}
{"id": "info_model_selection_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `log-likelihood-gaussian`.\nReturn only the Scheme definition.\n\n```python\ndef log_likelihood_gaussian(residuals):\n    n = len(residuals)\n    ss = sum(r * r for r in residuals)\n    sigma2 = ss / n\n    if sigma2 <= 0:\n        return 0\n    return -0.5 * n * (1 + log(2 * pi * sigma2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "log-likelihood-gaussian"], "split": "eval"}
{"id": "info_model_selection_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `aicc`.\nReturn only the Scheme definition.\n\n```python\ndef aicc(log_lik, k, n):\n    base = aic(log_lik, k)\n    if n - k - 1 <= 0:\n        return float('inf')\n    return base + (2 * k * (k + 1)) / (n - k - 1)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n(let () (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "python-to-scheme", "aicc"], "split": "eval"}
{"id": "info_model_selection_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `residual-entropy-bits`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (residual-entropy0 residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "chez-to-fold", "residual-entropy-bits"], "split": "eval"}
{"id": "info_model_selection_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-likelihood-gaussian` in `lattice/info/model-selection.ss`.\nKnown issue: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\n```scheme\n(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* 0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Log-likelihood should have a negative leading coefficient (-0.5*n).\n\nExpected behavior after patch:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (log-likelihood-gaussian '(0 0 0 0)) 0))\n(let () (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (log-likelihood-gaussian '(0 0 0 0)) 0) (let* ([r '(1 -1)] [ll (log-likelihood-gaussian r)] [expected (* -0.5 2 (+ 1 (log-num (* 2 (pi-value)))))] ) (approx=? expected ll 1e-6))))", "tags": ["tier1", "info", "model-selection", "bugfix", "log-likelihood-gaussian"], "split": "eval"}
{"id": "info_model_selection_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aicc` in `lattice/info/model-selection.ss`.\nKnown issue: AICc must add the finite-sample correction term.\n\n```scheme\n(define (aicc log-lik k n)\n  (aic log-lik k))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: AICc must add the finite-sample correction term.\n\nExpected behavior after patch:\n```scheme\n(let () (= (aicc -50 5 6) +inf.0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (= (aicc -50 5 6) +inf.0) (let* ([ll -50] [k 3] [n 10000] [a (aic ll k)] [ac (aicc ll k n)]) (< (abs (- a ac)) 0.01)) (let* ([ll -50] [k 5] [n 10] [a (aic ll k)] [ac (aicc ll k n)]) (and (> ac a) (approx=? 15 (- ac a) 1e-10)))))", "tags": ["tier1", "info", "model-selection", "bugfix", "aicc"], "split": "eval"}
{"id": "info_model_selection_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `residual-entropy-bits` in `lattice/info/model-selection.ss`.\nKnown issue: Zero-variance branch should return -inf.0 for differential entropy limit.\n\n```scheme\n(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (gaussian-entropy (sqrt sigma2)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (let ([h1 (residual-entropy-bits '(1.0 -0.5 0.3 -0.8 0.2))] [h-tight (residual-entropy-bits '(0.01 -0.01 0.005 -0.008))] [h-wide (residual-entropy-bits '(5.0 -3.0 4.0 -2.0))]) (and (> h1 0) (< h-tight h-wide))))", "tags": ["tier1", "info", "model-selection", "bugfix", "residual-entropy-bits"], "split": "eval"}
{"id": "info_model_selection_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "log-likelihood-gaussian", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute Gaussian log-likelihood for residuals '(1 -1).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(log-likelihood-gaussian '(1 -1))", "verify_expr": "(let ()\n  (define (log-likelihood-gaussian residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        0\n        (* -0.5 n (+ 1 (log-num (* 2 (pi-value) sigma2)))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? (* -0.5 2 (+ 1 (log-num (* 2 (pi-value))))) (log-likelihood-gaussian '(1 -1)) 1e-6))", "tags": ["tier1", "info", "model-selection", "composition", "log-likelihood-gaussian", "direct"], "split": "eval"}
{"id": "info_model_selection_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute AIC for log-likelihood -50 with k=3.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(aic -50 3)", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (= (aic -50 3) 106))", "tags": ["tier1", "info", "model-selection", "composition", "aic", "direct"], "split": "eval"}
{"id": "info_model_selection_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aicc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute AICc for log-likelihood -50, k=5, n=10.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(aicc -50 5 10)", "verify_expr": "(let ()\n  (define (aic log-lik k)\n  (+ (* -2 log-lik) (* 2 k)))\n  (define (aicc log-lik k n)\n  (let ([base (aic log-lik k)])\n    (if (<= (- n k 1) 0)\n        +inf.0\n        (+ base (/ (* 2 k (+ k 1)) (- n k 1))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 125 (aicc -50 5 10) 1e-10))", "tags": ["tier1", "info", "model-selection", "composition", "aicc", "direct"], "split": "eval"}
{"id": "info_model_selection_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "aic-weights", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether evidence ratio from first two Akaike weights exceeds 1 for AIC values '(100 102 105 110).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([ws (aic-weights '(100 102 105 110))] [w0 (car ws)] [w1 (cadr ws)]) (> (evidence-ratio w0 w1) 1.0))", "verify_expr": "(let ()\n  (define (aic-weights aic-values)\n  (if (null? aic-values)\n      '()\n      (let* ([aic-min (apply min aic-values)]\n             [deltas (map (lambda (a) (- a aic-min)) aic-values)]\n             [raw-weights (map (lambda (d) (exp-num (* -0.5 d))) deltas)]\n             [total (fold-left + 0 raw-weights)])\n        (if (<= total 0)\n            (map (lambda (_) (/ 1.0 (length aic-values))) aic-values)\n            (map (lambda (w) (/ w total)) raw-weights)))))\n  (define (evidence-ratio w-i w-j)\n  (if (<= w-j 0)\n      +inf.0\n      (/ w-i w-j)))\n  (equal? (let* ([ws (aic-weights '(100 102 105 110))] [w0 (car ws)] [w1 (cadr ws)]) (> (evidence-ratio w0 w1) 1.0)) #t))", "tags": ["tier1", "info", "model-selection", "composition", "aic-weights", "integration"], "split": "eval"}
{"id": "info_model_selection_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/model-selection.ss", "source_test": "lattice/info/test-model-selection.ss", "source_function": "residual-entropy-bits", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether scaling residuals by 10 increases residual entropy.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([base '(0.4 -0.2 0.1 -0.3)] [scaled '(4.0 -2.0 1.0 -3.0)]) (> (residual-entropy-bits scaled) (residual-entropy-bits base)))", "verify_expr": "(let ()\n  (define (residual-entropy-bits residuals)\n  (let* ([n (length residuals)]\n         [ss (fold-left + 0 (map (lambda (r) (* r r)) residuals))]\n         [sigma2 (/ ss n)])\n    (if (<= sigma2 0)\n        -inf.0\n        (gaussian-entropy (sqrt sigma2)))))\n  (equal? (let ([base '(0.4 -0.2 0.1 -0.3)] [scaled '(4.0 -2.0 1.0 -3.0)]) (> (residual-entropy-bits scaled) (residual-entropy-bits base))) #t))", "tags": ["tier1", "info", "model-selection", "composition", "residual-entropy-bits", "scaling"], "split": "eval"}
