{"id": "query_dsl_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `build-tag-predicate`\nSpec: Return a predicate that matches blocks by exact tag symbol.\n\nWrite exactly one Scheme function definition for `build-tag-predicate`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-tag-predicate tag)\n  ;; TODO: return block predicate for exact tag match\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-tag-predicate`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `build-tag-predicate` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return a predicate that matches blocks by exact tag symbol.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `build-tag-predicate`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `build-has-refs-predicate`\nSpec: Return a predicate that is true only for blocks with at least one reference.\n\nWrite exactly one Scheme function definition for `build-has-refs-predicate`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([pred (build-has-refs-predicate)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\")))) (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector)))))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-has-refs-predicate)\n  ;; TODO: return predicate true when block has at least one ref\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-has-refs-predicate`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `build-has-refs-predicate` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return a predicate that is true only for blocks with at least one reference.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `build-has-refs-predicate`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([pred (build-has-refs-predicate)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\")))) (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector)))))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `build-refs-count-predicate`\nSpec: Return a predicate that matches blocks with exactly n references.\n\nWrite exactly one Scheme function definition for `build-refs-count-predicate`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-refs-count-predicate n)\n  ;; TODO: return predicate true when refs count equals n\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-refs-count-predicate`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `build-refs-count-predicate` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return a predicate that matches blocks with exactly n references.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `build-refs-count-predicate`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `build-refs-to-predicate`\nSpec: Return a predicate that matches blocks containing the given target hash in refs.\n\nWrite exactly one Scheme function definition for `build-refs-to-predicate`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-refs-to-predicate target-hash)\n  ;; TODO: return predicate true when target-hash appears in block refs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-refs-to-predicate`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([target (string->utf8 \"target\")] [pred (build-refs-to-predicate target)]) (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\")))) (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\"))))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `build-refs-to-predicate` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return a predicate that matches blocks containing the given target hash in refs.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `build-refs-to-predicate`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `build-payload-size-predicate`\nSpec: Return a predicate comparing payload byte length against a threshold via comparator.\n\nWrite exactly one Scheme function definition for `build-payload-size-predicate`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-payload-size-predicate comparator size)\n  ;; TODO: return predicate that compares payload size via comparator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-payload-size-predicate`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `build-payload-size-predicate` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return a predicate comparing payload byte length against a threshold via comparator.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `build-payload-size-predicate`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `interpret-match`\nSpec: Interpret one match pattern and return the corresponding block predicate.\n\nWrite exactly one Scheme function definition for `interpret-match`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "interpret-match"], "split": "eval"}
{"id": "query_dsl_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (interpret-match pattern)\n  ;; TODO: dispatch on match key and return corresponding predicate\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `interpret-match`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "interpret-match"], "split": "eval"}
{"id": "query_dsl_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `interpret-match` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Interpret one match pattern and return the corresponding block predicate.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `interpret-match`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "interpret-match"], "split": "eval"}
{"id": "query_dsl_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `and-all`\nSpec: Return #t only when every predicate in the list matches the block.\n\nWrite exactly one Scheme function definition for `and-all`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "and-all"], "split": "train"}
{"id": "query_dsl_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (and-all predicates block)\n  ;; TODO: true only if every predicate matches block\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `and-all`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "and-all"], "split": "train"}
{"id": "query_dsl_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `and-all` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return #t only when every predicate in the list matches the block.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `and-all`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all '() 99) #t)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all '() 99) #t)))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "and-all"], "split": "train"}
{"id": "query_dsl_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `or-any`\nSpec: Return #t when at least one predicate in the list matches the block.\n\nWrite exactly one Scheme function definition for `or-any`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (or-any '() 'unused) #f)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f)))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "or-any"], "split": "train"}
{"id": "query_dsl_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (or-any predicates block)\n  ;; TODO: true if any predicate matches block\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `or-any`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any '() 'unused) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "or-any"], "split": "train"}
{"id": "query_dsl_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `or-any` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Return #t when at least one predicate in the list matches the block.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `or-any`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "or-any"], "split": "train"}
{"id": "query_dsl_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `build-tag-predicate`.\nReturn only the Scheme definition.\n\n```python\ndef build_tag_predicate(tag):\n    return lambda block: block['tag'] == tag\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-tag-predicate`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-tag-pred t)\n  (lambda (b)\n    (eq? (block-tag b) t)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-tag-predicate`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `build-tag-predicate`.\nReturn only the final Scheme definition.\n\n```python\ndef build_tag_predicate(tag):\n    return lambda block: block['tag'] == tag\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `build-has-refs-predicate`.\nReturn only the Scheme definition.\n\n```python\ndef build_has_refs_predicate():\n    return lambda block: len(block['refs']) > 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred (build-has-refs-predicate)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\")))) (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector)))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-has-refs-predicate`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-has-refs)\n  (lambda (b)\n    (> (vector-length (block-refs b)) 0)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred (build-has-refs-predicate)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\")))) (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector)))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-has-refs-predicate`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `build-has-refs-predicate`.\nReturn only the final Scheme definition.\n\n```python\ndef build_has_refs_predicate():\n    return lambda block: len(block['refs']) > 0\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred (build-has-refs-predicate)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\")))) (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector)))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `build-refs-count-predicate`.\nReturn only the Scheme definition.\n\n```python\ndef build_refs_count_predicate(n):\n    return lambda block: len(block['refs']) == n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-refs-count-predicate`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-refs-count n)\n  (lambda (b)\n    (= (vector-length (block-refs b)) n)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-refs-count-predicate`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `build-refs-count-predicate`.\nReturn only the final Scheme definition.\n\n```python\ndef build_refs_count_predicate(n):\n    return lambda block: len(block['refs']) == n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `build-refs-to-predicate`.\nReturn only the Scheme definition.\n\n```python\ndef build_refs_to_predicate(target_hash):\n    def pred(block):\n        return any(ref == target_hash for ref in block['refs'])\n    return pred\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([target (string->utf8 \"target\")] [pred (build-refs-to-predicate target)]) (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\")))) (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\"))))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-refs-to-predicate`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-refs-to target)\n  (lambda (b)\n    (let ([refs (block-refs b)])\n      (let loop ([i 0])\n        (cond\n          [(>= i (vector-length refs)) #f]\n          [(bytevector=? (vector-ref refs i) target) #t]\n          [else (loop (+ i 1))])))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-refs-to-predicate`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `build-refs-to-predicate`.\nReturn only the final Scheme definition.\n\n```python\ndef build_refs_to_predicate(target_hash):\n    def pred(block):\n        return any(ref == target_hash for ref in block['refs'])\n    return pred\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk)) #f)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk)) #f)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `build-payload-size-predicate`.\nReturn only the Scheme definition.\n\n```python\ndef build_payload_size_predicate(comparator, size):\n    return lambda block: comparator(len(block['payload']), size)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-payload-size-predicate`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-payload-size-pred cmp n)\n  (lambda (b)\n    (cmp (bytevector-length (block-payload b)) n)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-payload-size-predicate`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `build-payload-size-predicate`.\nReturn only the final Scheme definition.\n\n```python\ndef build_payload_size_predicate(comparator, size):\n    return lambda block: comparator(len(block['payload']), size)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `interpret-match`.\nReturn only the Scheme definition.\n\n```python\ndef interpret_match(pattern):\n    key, value = pattern\n    if key == 'tag':\n        return build_tag_predicate(value)\n    if key == 'payload-contains':\n        return build_payload_contains_predicate(value)\n    if key == 'payload-matches':\n        return build_payload_matches_predicate(value)\n    if key == 'has-refs':\n        return build_has_refs_predicate()\n    if key == 'refs-count':\n        return build_refs_count_predicate(value)\n    if key == 'payload-size-gt':\n        return build_payload_size_predicate(lambda a, b: a > b, value)\n    if key == 'payload-size-lt':\n        return build_payload_size_predicate(lambda a, b: a < b, value)\n    if key == 'payload-size-eq':\n        return build_payload_size_predicate(lambda a, b: a == b, value)\n    raise ValueError('unknown pattern')\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `interpret-match`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (interp-match pat)\n  (let ([k (car pat)] [v (cdr pat)])\n    (case k\n      [(tag) (build-tag-predicate v)]\n      [(payload-contains) (build-payload-contains-predicate v)]\n      [(payload-matches) (build-payload-matches-predicate v)]\n      [(has-refs) (build-has-refs-predicate)]\n      [(refs-count) (build-refs-count-predicate v)]\n      [(payload-size-gt) (build-payload-size-predicate > v)]\n      [(payload-size-lt) (build-payload-size-predicate < v)]\n      [(payload-size-eq) (build-payload-size-predicate = v)]\n      [else (error 'interp-match \"unknown\" k)])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `interpret-match`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `interpret-match`.\nReturn only the final Scheme definition.\n\n```python\ndef interpret_match(pattern):\n    key, value = pattern\n    if key == 'tag':\n        return build_tag_predicate(value)\n    if key == 'payload-contains':\n        return build_payload_contains_predicate(value)\n    if key == 'payload-matches':\n        return build_payload_matches_predicate(value)\n    if key == 'has-refs':\n        return build_has_refs_predicate()\n    if key == 'refs-count':\n        return build_refs_count_predicate(value)\n    if key == 'payload-size-gt':\n        return build_payload_size_predicate(lambda a, b: a > b, value)\n    if key == 'payload-size-lt':\n        return build_payload_size_predicate(lambda a, b: a < b, value)\n    if key == 'payload-size-eq':\n        return build_payload_size_predicate(lambda a, b: a == b, value)\n    raise ValueError('unknown pattern')\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_019", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `and-all`.\nReturn only the Scheme definition.\n\n```python\ndef and_all(predicates, block):\n    for pred in predicates:\n        if not pred(block):\n            return False\n    return True\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all '() 99) #t)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all '() 99) #t)))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "and-all"], "split": "train"}
{"id": "query_dsl_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `and-all`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (all? preds b)\n  (let loop ([ps preds])\n    (or (null? ps)\n        (and ((car ps) b)\n             (loop (cdr ps))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all '() 99) #t)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all '() 99) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "and-all"], "split": "train"}
{"id": "query_dsl_translation_021", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `and-all`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `and-all`.\nReturn only the final Scheme definition.\n\n```python\ndef and_all(predicates, block):\n    for pred in predicates:\n        if not pred(block):\n            return False\n    return True\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "and-all"], "split": "train"}
{"id": "query_dsl_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `or-any`.\nReturn only the Scheme definition.\n\n```python\ndef or_any(predicates, block):\n    for pred in predicates:\n        if pred(block):\n            return True\n    return False\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t)))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "or-any"], "split": "train"}
{"id": "query_dsl_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `or-any`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (any? preds b)\n  (let loop ([ps preds])\n    (and (pair? ps)\n         (or ((car ps) b)\n             (loop (cdr ps))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any '() 'unused) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "or-any"], "split": "train"}
{"id": "query_dsl_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `or-any`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `or-any`.\nReturn only the final Scheme definition.\n\n```python\ndef or_any(predicates, block):\n    for pred in predicates:\n        if pred(block):\n            return True\n    return False\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (or-any '() 'unused) #f)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "or-any"], "split": "train"}
{"id": "query_dsl_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-tag-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: The predicate must compare tag symbols, not payload bytes.\n\n```scheme\n(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-payload block) tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The predicate must compare tag symbols, not payload bytes.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-tag-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: The function should compare against parameter `tag`, not literal symbol `'tag`.\n\n```scheme\n(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) 'tag)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The function should compare against parameter `tag`, not literal symbol `'tag`.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([pred (build-tag-predicate 'entity)]) (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector))) (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector)))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)\n```", "ground_truth": "(define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-tag-predicate 'entity)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector)))\n       (not (pred (make-test-block 'relation (string->utf8 \"knows\") (vector))))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-tag-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-has-refs-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: Blocks with exactly one reference must also satisfy has-refs.\n\n```scheme\n(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 1)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-has-refs-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: Empty ref vectors must return #f, not #t.\n\n```scheme\n(define (build-has-refs-predicate)\n  (lambda (block)\n          (>= (vector-length (block-refs block)) 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)\n```", "ground_truth": "(define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred (build-has-refs-predicate)])\n  (and (pred (make-test-block 'entity (string->utf8 \"alice\") (vector (string->utf8 \"h1\"))))\n       (not (pred (make-test-block 'entity (string->utf8 \"bob\") (vector))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-has-refs-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-refs-count-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: refs-count must enforce exact equality, not lower bound.\n\n```scheme\n(define (build-refs-count-predicate n)\n  (lambda (block)\n          (>= (vector-length (block-refs block)) n)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-refs-count-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: The comparison is off by one.\n\n```scheme\n(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) (+ n 1))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The comparison is off by one.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([pred2 (build-refs-count-predicate 2)]) (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\"))))))))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t)\n```", "ground_truth": "(define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let ([pred2 (build-refs-count-predicate 2)])\n  (and (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))\n       (not (pred2 (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"a\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-refs-count-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-refs-to-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: When scan reaches the end without match, result must be #f.\n\n```scheme\n(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #t]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-refs-to-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: The scan skips every other reference and can miss valid matches.\n\n```scheme\n(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 2))])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The scan skips every other reference and can miss valid matches.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([target (string->utf8 \"target\")] [pred (build-refs-to-predicate target)]) (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\")))) (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\"))))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([target (string->utf8 \"target\")] [pred (build-refs-to-predicate target)]) (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\")))) (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\"))))))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk)) #f)\n```", "ground_truth": "(define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))", "verify_expr": "(and (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([target (string->utf8 \"target\")]\n       [pred (build-refs-to-predicate target)])\n  (and (pred (make-test-block 'relation (string->utf8 \"r\") (vector target (string->utf8 \"other\"))))\n       (not (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))))))) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t)) (let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk)) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-refs-to-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-payload-size-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: Comparator argument order is reversed.\n\n```scheme\n(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator size (bytevector-length (block-payload block)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Comparator argument order is reversed.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))\n```\n\nCheck 2:\n```scheme\n(equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-payload-size-predicate` in `lattice/query/query-dsl.ss`.\nKnown issue: Size predicate must use payload byte length, not reference count.\n\n```scheme\n(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (vector-length (block-refs block)) size)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([gt3 (build-payload-size-predicate > 3)] [eq5 (build-payload-size-predicate = 5)] [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))] [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))] [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))]) (and (gt3 blk4) (not (gt3 blk2)) (eq5 blk5))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))\n```\n\nCheck 2:\n```scheme\n(equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)\n```", "ground_truth": "(define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))", "verify_expr": "(and (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([gt3 (build-payload-size-predicate > 3)]\n       [eq5 (build-payload-size-predicate = 5)]\n       [blk4 (make-test-block 'doc (string->utf8 \"abcd\") (vector))]\n       [blk2 (make-test-block 'doc (string->utf8 \"ab\") (vector))]\n       [blk5 (make-test-block 'doc (string->utf8 \"hello\") (vector))])\n  (and (gt3 blk4)\n       (not (gt3 blk2))\n       (eq5 blk5)))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t))) (let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "build-payload-size-predicate"], "split": "train"}
{"id": "query_dsl_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `interpret-match` in `lattice/query/query-dsl.ss`.\nKnown issue: refs-count must dispatch to build-refs-count-predicate with the provided count.\n\n```scheme\n(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-has-refs-predicate)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "interpret-match"], "split": "eval"}
{"id": "query_dsl_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `interpret-match` in `lattice/query/query-dsl.ss`.\nKnown issue: payload-size-lt must use < comparator.\n\n```scheme\n(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "interpret-match"], "split": "eval"}
{"id": "query_dsl_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `and-all` in `lattice/query/query-dsl.ss`.\nKnown issue: and-all should return #t for empty predicate list (identity element).\n\n```scheme\n(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (and ((car preds) block)\n                 (loop (cdr preds))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: and-all should return #t for empty predicate list (identity element).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "and-all"], "split": "train"}
{"id": "query_dsl_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `and-all` in `lattice/query/query-dsl.ss`.\nKnown issue: Predicates must be combined conjunctively, not disjunctively.\n\n```scheme\n(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (or ((car preds) block)\n               (loop (cdr preds))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Predicates must be combined conjunctively, not disjunctively.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (lambda (n) (> n 0))] [p2 (lambda (n) (even? n))] [p3 (lambda (n) (< n 10))]) (and (and-all (list p1 p2 p3) 4) (not (and-all (list p1 p2 p3) 11)) (and-all '() 42))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)\n```", "ground_truth": "(define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (> n 0))]\n       [p2 (lambda (n) (even? n))]\n       [p3 (lambda (n) (< n 10))])\n  (and (and-all (list p1 p2 p3) 4)\n       (not (and-all (list p1 p2 p3) 11))\n       (and-all '() 42)))) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t)) (let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "and-all"], "split": "train"}
{"id": "query_dsl_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `or-any` in `lattice/query/query-dsl.ss`.\nKnown issue: or-any should return #f for empty predicate list.\n\n```scheme\n(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (or ((car preds) block)\n               (loop (cdr preds))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "or-any"], "split": "train"}
{"id": "query_dsl_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `or-any` in `lattice/query/query-dsl.ss`.\nKnown issue: or-any must short-circuit on first true predicate, not require all true.\n\n```scheme\n(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (and ((car preds) block)\n                 (loop (cdr preds))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: or-any must short-circuit on first true predicate, not require all true.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (lambda (n) (= (modulo n 2) 0))] [p2 (lambda (n) (> n 10))]) (and (or-any (list p1 p2) 8) (not (or-any (list p1 p2) 7)) (not (or-any '() 1)))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (or-any '() 'unused) #f)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)\n```", "ground_truth": "(define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))", "verify_expr": "(and (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (let* ([p1 (lambda (n) (= (modulo n 2) 0))]\n       [p2 (lambda (n) (> n 10))])\n  (and (or-any (list p1 p2) 8)\n       (not (or-any (list p1 p2) 7))\n       (not (or-any '() 1))))) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f)) (let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "or-any"], "split": "train"}
{"id": "query_dsl_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild an entity tag predicate and return results for entity/relation/entity blocks as a list.\n\nEnsure `build-tag-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-tag-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector)))))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-tag-predicate", "direct"], "split": "eval"}
{"id": "query_dsl_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether relation block fails the entity tag predicate.\n\nEnsure `build-tag-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-tag-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\")))))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (pred (make-test-block 'relation (string->utf8 \"r\") (vector (string->utf8 \"h\"))))) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "build-tag-predicate", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse and-all with entity tag + has-refs predicates on a block that should satisfy both.\n\nEnsure `build-tag-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-tag-predicate`\n- `build-has-refs-predicate`\n- `make-test-block`\n- `and-all`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([tag-pred (build-tag-predicate 'entity)] [refs-pred (build-has-refs-predicate)] [blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h1\")))]) (and-all (list tag-pred refs-pred) blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-tag-predicate", "integration"], "split": "train"}
{"id": "query_dsl_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse or-any over entity/relation predicates on a collection block.\n\nEnsure `build-tag-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-tag-predicate`\n- `make-test-block`\n- `or-any`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([entity? (build-tag-predicate 'entity)] [relation? (build-tag-predicate 'relation)] [blk (make-test-block 'collection (string->utf8 \"c\") (vector))]) (or-any (list entity? relation?) blk)) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "build-tag-predicate", "integration"], "split": "train"}
{"id": "query_dsl_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nApply has-refs predicate to blocks with zero and one reference and return the result list.\n\nEnsure `build-has-refs-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\"))))))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-has-refs-predicate)]) (list (pred (make-test-block 'note (string->utf8 \"n\") (vector))) (pred (make-test-block 'note (string->utf8 \"n\") (vector (string->utf8 \"h1\")))))) '(#f #t)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-has-refs-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate has-refs on a block with two references.\n\nEnsure `build-has-refs-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-has-refs-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-has-refs-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a block satisfies both has-refs and refs-count=2.\n\nEnsure `build-has-refs-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-has-refs-predicate`\n- `make-test-block`\n- `build-refs-count-predicate`\n- `and-all`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-has-refs-predicate", "property"], "split": "eval"}
{"id": "query_dsl_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that has-refs is false for an empty refs vector.\n\nEnsure `build-has-refs-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector)))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-has-refs-predicate) (make-test-block 'entity (string->utf8 \"x\") (vector))) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "build-has-refs-predicate", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nApply refs-count=2 predicate to blocks with 0/1/2 refs and return booleans.\n\nEnsure `build-refs-count-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\"))))))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred2 (build-refs-count-predicate 2)]) (list (pred2 (make-test-block 'x (string->utf8 \"\") (vector))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\")))) (pred2 (make-test-block 'x (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))))) '(#f #f #t)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-count-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether a two-ref block satisfies count=2 and not count=1.\n\nEnsure `build-refs-count-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-refs-count-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk))))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [count2 (build-refs-count-predicate 2)] [count1 (build-refs-count-predicate 1)]) (and (count2 blk) (not (count1 blk)))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-count-predicate", "property"], "split": "train"}
{"id": "query_dsl_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse or-any with predicates count=1 or count=3 on a three-ref block.\n\nEnsure `build-refs-count-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"a\") (string->utf8 \"b\") (string->utf8 \"c\")))] [preds (list (build-refs-count-predicate 1) (build-refs-count-predicate 3))]) (or-any preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-count-predicate", "integration"], "split": "train"}
{"id": "query_dsl_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate refs-count=0 on a block with no references.\n\nEnsure `build-refs-count-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector)))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-count-predicate", "edge-case"], "split": "eval"}
{"id": "query_dsl_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether a relation block references target hash `h`.\n\nEnsure `build-refs-to-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-refs-to-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-to-predicate", "direct"], "split": "eval"}
{"id": "query_dsl_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that refs-to predicate returns false when target hash is absent.\n\nEnsure `build-refs-to-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-refs-to-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") (string->utf8 \"y\")))]) (pred blk)) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-to-predicate", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nRun refs-to predicate against two blocks and return boolean results.\n\nEnsure `build-refs-to-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-refs-to-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\"))))))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)]) (list (pred (make-test-block 'r (string->utf8 \"\") (vector h))) (pred (make-test-block 'r (string->utf8 \"\") (vector (string->utf8 \"z\")))))) '(#t #f)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-to-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a block satisfies both refs-to(target) and refs-count=2.\n\nEnsure `build-refs-to-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-refs-to-predicate`\n- `make-test-block`\n- `build-refs-count-predicate`\n- `and-all`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [blk (make-test-block 'r (string->utf8 \"\") (vector h (string->utf8 \"x\")))] [preds (list (build-refs-to-predicate h) (build-refs-count-predicate 2))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-to-predicate", "integration"], "split": "train"}
{"id": "query_dsl_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply payload-size>3 predicate to payloads \"ab\" and \"abcd\".\n\nEnsure `build-payload-size-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector)))))", "verify_expr": "(let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-payload-size-predicate > 3)]) (list (pred (make-test-block 'doc (string->utf8 \"ab\") (vector))) (pred (make-test-block 'doc (string->utf8 \"abcd\") (vector))))) '(#f #t)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-payload-size-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate payload-size=5 predicate on payload \"hello\".\n\nEnsure `build-payload-size-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-payload-size-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector)))", "verify_expr": "(let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate = 5) (make-test-block 'doc (string->utf8 \"hello\") (vector))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-payload-size-predicate", "direct"], "split": "train"}
{"id": "query_dsl_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate payload-size<4 predicate on payload \"abcd\".\n\nEnsure `build-payload-size-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-payload-size-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector)))", "verify_expr": "(let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-payload-size-predicate < 4) (make-test-block 'doc (string->utf8 \"abcd\") (vector))) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "build-payload-size-predicate", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nUse and-all to require tag=doc and payload-size>2 on payload \"cat\".\n\nEnsure `build-payload-size-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-payload-size-predicate", "integration"], "split": "eval"}
{"id": "query_dsl_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: compose existing APIs into one expression.\n\nInterpret `(tag . entity)` and evaluate it on an entity block.\n\nEnsure `interpret-match` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `interpret-match`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector)))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "interpret-match", "direct"], "split": "train"}
{"id": "query_dsl_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: small integration task across module primitives.\n\nInterpret `(payload-contains . \"ana\")` and evaluate on payloads \"banana\" and \"cider\".\n\nEnsure `interpret-match` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `interpret-match`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector)))))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f)))", "tags": ["tier1", "query", "query-dsl", "composition", "interpret-match", "direct"], "split": "train"}
{"id": "query_dsl_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInterpret a payload-matches pattern that checks for substring \"bc\" in decoded payload text.\n\nEnsure `interpret-match` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector)))))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f)))", "tags": ["tier1", "query", "query-dsl", "composition", "interpret-match", "integration"], "split": "train"}
{"id": "query_dsl_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether interpreting an unknown pattern raises an exception.\n\nEnsure `interpret-match` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "interpret-match", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse and-all with predicates (>0), even?, and (<10) on 8.\n\nEnsure `and-all` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8)", "verify_expr": "(let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) 8) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "and-all", "direct"], "split": "train"}
{"id": "query_dsl_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse and-all with predicates (>0), even?, and (<10) on -2.\n\nEnsure `and-all` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2)", "verify_expr": "(let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "and-all", "direct"], "split": "eval"}
{"id": "query_dsl_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate and-all with an empty predicate list and any value.\n\nEnsure `and-all` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and-all '() 99)", "verify_expr": "(let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all '() 99) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "and-all", "edge-case"], "split": "train"}
{"id": "query_dsl_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a block passes tag=entity and refs-count=1 using and-all.\n\nEnsure `and-all` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'entity (string->utf8 \"x\") (vector (string->utf8 \"h\")))] [preds (list (build-tag-predicate 'entity) (build-refs-count-predicate 1))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "and-all", "integration"], "split": "train"}
{"id": "query_dsl_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: small integration task across module primitives.\n\nUse or-any with predicates (>10) and even? on 11.\n\nEnsure `or-any` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11)", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (> n 10)) (lambda (n) (even? n))) 11) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "direct"], "split": "train"}
{"id": "query_dsl_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: small integration task across module primitives.\n\nUse or-any with predicates (<0) and even? on 7.\n\nEnsure `or-any` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7)", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "direct"], "split": "eval"}
{"id": "query_dsl_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate or-any with an empty predicate list.\n\nEnsure `or-any` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(or-any '() 'unused)", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "edge-case"], "split": "eval"}
{"id": "query_dsl_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether a block satisfies tag=entity or refs-to(target) using or-any.\n\nEnsure `or-any` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `or-any`\n- `make-test-block`\n- `build-tag-predicate`\n- `build-refs-to-predicate`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk))", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "integration"], "split": "eval"}
