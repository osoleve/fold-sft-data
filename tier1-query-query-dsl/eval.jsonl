{"id": "query_dsl_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this query DSL function in Fold-native Scheme.\n\nTarget module: lattice/query/query-dsl.ss\nFunction: `interpret-match`\nSpec: Interpret one match pattern and return the corresponding block predicate.\n\nWrite exactly one Scheme function definition for `interpret-match`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "spec-to-code", "interpret-match"], "split": "eval"}
{"id": "query_dsl_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (interpret-match pattern)\n  ;; TODO: dispatch on match key and return corresponding predicate\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `interpret-match`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "skeleton-completion", "interpret-match"], "split": "eval"}
{"id": "query_dsl_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `interpret-match` from this query-DSL contract.\n\nModule: `lattice/query/query-dsl.ss`\nContract focus: Interpret one match pattern and return the corresponding block predicate.\n\nRequirements:\n1. Preserve query predicate semantics exactly.\n2. Keep the exact function name/signature for `interpret-match`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "contract-implementation", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `interpret-match`.\nReturn only the Scheme definition.\n\n```python\ndef interpret_match(pattern):\n    key, value = pattern\n    if key == 'tag':\n        return build_tag_predicate(value)\n    if key == 'payload-contains':\n        return build_payload_contains_predicate(value)\n    if key == 'payload-matches':\n        return build_payload_matches_predicate(value)\n    if key == 'has-refs':\n        return build_has_refs_predicate()\n    if key == 'refs-count':\n        return build_refs_count_predicate(value)\n    if key == 'payload-size-gt':\n        return build_payload_size_predicate(lambda a, b: a > b, value)\n    if key == 'payload-size-lt':\n        return build_payload_size_predicate(lambda a, b: a < b, value)\n    if key == 'payload-size-eq':\n        return build_payload_size_predicate(lambda a, b: a == b, value)\n    raise ValueError('unknown pattern')\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))))", "tags": ["tier1", "query", "query-dsl", "python-to-scheme", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `interpret-match`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (interp-match pat)\n  (let ([k (car pat)] [v (cdr pat)])\n    (case k\n      [(tag) (build-tag-predicate v)]\n      [(payload-contains) (build-payload-contains-predicate v)]\n      [(payload-matches) (build-payload-matches-predicate v)]\n      [(has-refs) (build-has-refs-predicate)]\n      [(refs-count) (build-refs-count-predicate v)]\n      [(payload-size-gt) (build-payload-size-predicate > v)]\n      [(payload-size-lt) (build-payload-size-predicate < v)]\n      [(payload-size-eq) (build-payload-size-predicate = v)]\n      [else (error 'interp-match \"unknown\" k)])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((interpret-match '(tag . entity)) (make-test-block 'entity (string->utf8 \"x\") (vector))) #t)))", "tags": ["tier1", "query", "query-dsl", "chez-to-fold", "interpret-match"], "split": "eval"}
{"id": "query_dsl_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `interpret-match`.\n\nPreserve observable query behavior exactly.\nKeep the target function name/signature as `interpret-match`.\nReturn only the final Scheme definition.\n\n```python\ndef interpret_match(pattern):\n    key, value = pattern\n    if key == 'tag':\n        return build_tag_predicate(value)\n    if key == 'payload-contains':\n        return build_payload_contains_predicate(value)\n    if key == 'payload-matches':\n        return build_payload_matches_predicate(value)\n    if key == 'has-refs':\n        return build_has_refs_predicate()\n    if key == 'refs-count':\n        return build_refs_count_predicate(value)\n    if key == 'payload-size-gt':\n        return build_payload_size_predicate(lambda a, b: a > b, value)\n    if key == 'payload-size-lt':\n        return build_payload_size_predicate(lambda a, b: a < b, value)\n    if key == 'payload-size-eq':\n        return build_payload_size_predicate(lambda a, b: a == b, value)\n    raise ValueError('unknown pattern')\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "reference-translation", "interpret-match"], "split": "eval"}
{"id": "query_dsl_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `interpret-match` in `lattice/query/query-dsl.ss`.\nKnown issue: refs-count must dispatch to build-refs-count-predicate with the provided count.\n\n```scheme\n(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-has-refs-predicate)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (interpret-match '(payload-contains . \"ana\"))]) (list (pred (make-test-block 'doc (string->utf8 \"banana\") (vector))) (pred (make-test-block 'doc (string->utf8 \"cider\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "interpret-match"], "split": "eval"}
{"id": "query_dsl_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "interpret-match", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `interpret-match` in `lattice/query/query-dsl.ss`.\nKnown issue: payload-size-lt must use < comparator.\n\n```scheme\n(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)\n```", "ground_truth": "(define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))", "verify_expr": "(and (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (let* ([b-entity (make-test-block 'entity (string->utf8 \"abc\") (vector))]\n       [b-two-refs (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\") (string->utf8 \"r2\")))]\n       [b-one-ref (make-test-block 'relation (string->utf8 \"xy\") (vector (string->utf8 \"r1\")))]\n       [p-tag (interpret-match '(tag . entity))]\n       [p-has (interpret-match '(has-refs . #t))]\n       [p-count (interpret-match '(refs-count . 2))]\n       [p-size (interpret-match '(payload-size-gt . 2))])\n  (and (p-tag b-entity)\n       (p-has b-two-refs)\n       (not (p-has b-entity))\n       (p-count b-two-refs)\n       (not (p-count b-one-ref))\n       (p-size (make-test-block 'doc (string->utf8 \"abc\") (vector)))\n       (guard (ex [else #t])\n              (begin (interpret-match '(unknown . 1)) #f))))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([m (lambda (s) (query-string-contains? s \"bc\"))] [pred (interpret-match (cons 'payload-matches m))]) (list (pred (make-test-block 'doc (string->utf8 \"abcde\") (vector))) (pred (make-test-block 'doc (string->utf8 \"ax\") (vector))))) '(#t #f))) (let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (safe-utf8->string bv)\n  (guard (ex [else \"\"])\n         (utf8->string bv)))\n  (define (query-string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n       (cond\n        [(= n-len 0) #t]\n        [(> n-len h-len) #f]\n        [else\n         (let ([first-char (string-ref needle 0)])\n              (let outer ([i 0])\n                   (cond\n                    [(> (+ i n-len) h-len) #f]\n                    [(char=? (string-ref haystack i) first-char)\n                     (if (let inner ([j 1])\n                              (cond\n                               [(= j n-len) #t]\n                               [(char=? (string-ref haystack (+ i j))\n                                        (string-ref needle j))\n                                (inner (+ j 1))]\n                               [else #f]))\n                         #t\n                         (outer (+ i 1)))]\n                    [else (outer (+ i 1))])))])))\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-contains-predicate substring)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (query-string-contains? payload-str substring))))\n  (define (build-payload-matches-predicate matcher)\n  (lambda (block)\n          (let ([payload-str (safe-utf8->string (block-payload block))])\n               (matcher payload-str))))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (interpret-match pattern)\n  (let ([key (car pattern)]\n        [value (cdr pattern)])\n       (case key\n             [(tag)\n              (build-tag-predicate value)]\n             [(payload-contains)\n              (build-payload-contains-predicate value)]\n             [(payload-matches)\n              (build-payload-matches-predicate value)]\n             [(has-refs)\n              (build-has-refs-predicate)]\n             [(refs-count)\n              (build-refs-count-predicate value)]\n             [(payload-size-gt)\n              (build-payload-size-predicate > value)]\n             [(payload-size-lt)\n              (build-payload-size-predicate < value)]\n             [(payload-size-eq)\n              (build-payload-size-predicate = value)]\n             [else\n              (error 'interpret-match \"Unknown match pattern\" key)])))\n  (equal? (guard (ex [else #t]) (begin (interpret-match '(bad-key . 1)) #f)) #t)))", "tags": ["tier1", "query", "query-dsl", "bugfix", "interpret-match"], "split": "eval"}
{"id": "query_dsl_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-tag-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild an entity tag predicate and return results for entity/relation/entity blocks as a list.\n\nEnsure `build-tag-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-tag-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector)))))", "verify_expr": "(let ()\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let ([pred (build-tag-predicate 'entity)]) (list (pred (make-test-block 'entity (string->utf8 \"a\") (vector))) (pred (make-test-block 'relation (string->utf8 \"r\") (vector))) (pred (make-test-block 'entity (string->utf8 \"b\") (vector))))) '(#t #f #t)))", "tags": ["tier1", "query", "query-dsl", "composition", "build-tag-predicate", "direct"], "split": "eval"}
{"id": "query_dsl_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-has-refs-predicate", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a block satisfies both has-refs and refs-count=2.\n\nEnsure `build-has-refs-predicate` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `build-has-refs-predicate`\n- `make-test-block`\n- `build-refs-count-predicate`\n- `and-all`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-has-refs-predicate)\n  (lambda (block)\n          (> (vector-length (block-refs block)) 0)))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'relation (string->utf8 \"rel\") (vector (string->utf8 \"a\") (string->utf8 \"b\")))] [preds (list (build-has-refs-predicate) (build-refs-count-predicate 2))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-has-refs-predicate", "property"], "split": "eval"}
{"id": "query_dsl_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-count-predicate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate refs-count=0 on a block with no references.\n\nEnsure `build-refs-count-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector)))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-count-predicate n)\n  (lambda (block)\n          (= (vector-length (block-refs block)) n)))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? ((build-refs-count-predicate 0) (make-test-block 'x (string->utf8 \"\") (vector))) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-count-predicate", "edge-case"], "split": "eval"}
{"id": "query_dsl_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-refs-to-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether a relation block references target hash `h`.\n\nEnsure `build-refs-to-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `build-refs-to-predicate`\n- `make-test-block`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk))", "verify_expr": "(let ()\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([h (string->utf8 \"h\")] [pred (build-refs-to-predicate h)] [blk (make-test-block 'relation (string->utf8 \"\") (vector (string->utf8 \"x\") h))]) (pred blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-refs-to-predicate", "direct"], "split": "eval"}
{"id": "query_dsl_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "build-payload-size-predicate", "prompt": "Task mode: small integration task across module primitives.\n\nUse and-all to require tag=doc and payload-size>2 on payload \"cat\".\n\nEnsure `build-payload-size-predicate` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk))", "verify_expr": "(let ()\n  (define (block-payload block)\n  (vector-ref block 1))\n  (define (build-payload-size-predicate comparator size)\n  (lambda (block)\n          (comparator (bytevector-length (block-payload block)) size)))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([blk (make-test-block 'doc (string->utf8 \"cat\") (vector))] [preds (list (build-tag-predicate 'doc) (build-payload-size-predicate > 2))]) (and-all preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "build-payload-size-predicate", "integration"], "split": "eval"}
{"id": "query_dsl_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "and-all", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse and-all with predicates (>0), even?, and (<10) on -2.\n\nEnsure `and-all` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2)", "verify_expr": "(let ()\n  (define (and-all predicates block)\n  (let loop ([preds predicates])\n       (or (null? preds)\n           (and ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (and-all (list (lambda (n) (> n 0)) (lambda (n) (even? n)) (lambda (n) (< n 10))) -2) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "and-all", "direct"], "split": "eval"}
{"id": "query_dsl_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: small integration task across module primitives.\n\nUse or-any with predicates (<0) and even? on 7.\n\nEnsure `or-any` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7)", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any (list (lambda (n) (< n 0)) (lambda (n) (even? n))) 7) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "direct"], "split": "eval"}
{"id": "query_dsl_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate or-any with an empty predicate list.\n\nEnsure `or-any` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(or-any '() 'unused)", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (equal? (or-any '() 'unused) #f))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "edge-case"], "split": "eval"}
{"id": "query_dsl_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/query-dsl.ss", "source_test": "lattice/query/test-query-dsl.ss", "source_function": "or-any", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether a block satisfies tag=entity or refs-to(target) using or-any.\n\nEnsure `or-any` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `or-any`\n- `make-test-block`\n- `build-tag-predicate`\n- `build-refs-to-predicate`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk))", "verify_expr": "(let ()\n  (define (or-any predicates block)\n  (let loop ([preds predicates])\n       (and (pair? preds)\n            (or ((car preds) block)\n                (loop (cdr preds))))))\n  (define (block-tag block)\n  (vector-ref block 0))\n  (define (build-tag-predicate tag)\n  (lambda (block)\n          (eq? (block-tag block) tag)))\n  (define (block-refs block)\n  (vector-ref block 2))\n  (define (build-refs-to-predicate target-hash)\n  (lambda (block)\n          (let ([refs (block-refs block)])\n               (let check-refs ([i 0])\n                    (cond\n                     [(>= i (vector-length refs)) #f]\n                     [(bytevector=? (vector-ref refs i) target-hash) #t]\n                     [else (check-refs (+ i 1))])))))\n  (define (make-test-block tag payload refs)\n  (vector tag payload refs))\n  (equal? (let* ([target (string->utf8 \"target\")] [blk (make-test-block 'relation (string->utf8 \"\") (vector target))] [preds (list (build-tag-predicate 'entity) (build-refs-to-predicate target))]) (or-any preds blk)) #t))", "tags": ["tier1", "query", "query-dsl", "composition", "or-any", "integration"], "split": "eval"}
