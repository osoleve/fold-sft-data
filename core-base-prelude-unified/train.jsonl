{"id": "core_prelude_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `andmap` in `core/base/prelude.ss`.\nKnown issue: All elements must satisfy predicate, not just one.\n\n```scheme\n(define (andmap pred lst)\n  (or (null? lst)\n      (or (pred (car lst)) (andmap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `andmap` in `core/base/prelude.ss`.\nKnown issue: All elements must satisfy predicate, not just one.\n\n```scheme\n(define (andmap pred lst)\n  (or (null? lst)\n      (or (pred (car lst)) (andmap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: All elements must satisfy predicate, not just one.\n\nExpected behavior after patch:\n```scheme\n(let () (andmap number? '()))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (andmap number? '()))\n(let () (andmap number? '(1 2 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "bugfix", "andmap"], "split": "train"}
{"id": "core_prelude_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ormap` in `core/base/prelude.ss`.\nKnown issue: Should return first truthy predicate result; empty list should return #f.\n\n```scheme\n(define (ormap pred lst)\n  (or (null? lst)\n      (and (pred (car lst)) (ormap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ormap` in `core/base/prelude.ss`.\nKnown issue: Should return first truthy predicate result; empty list should return #f.\n\n```scheme\n(define (ormap pred lst)\n  (or (null? lst)\n      (and (pred (car lst)) (ormap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Should return first truthy predicate result; empty list should return #f.\n\nExpected behavior after patch:\n```scheme\n(let () (not (ormap number? '())))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (not (ormap number? '())))\n(let () (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "bugfix", "ormap"], "split": "train"}
{"id": "core_prelude_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter-map` in `core/base/prelude.ss`.\nKnown issue: Must remove #f results.\n\n```scheme\n(define (filter-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter-map` in `core/base/prelude.ss`.\nKnown issue: Must remove #f results.\n\n```scheme\n(define (filter-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "bugfix", "filter-map"], "split": "train"}
{"id": "core_prelude_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-left` in `core/base/prelude.ss`.\nKnown issue: This is right-associative, not left-associative.\n\n```scheme\n(define (fold-left f acc lst)\n  (if (null? lst) acc (f (car lst) (fold-left f acc (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-left` in `core/base/prelude.ss`.\nKnown issue: This is right-associative, not left-associative.\n\n```scheme\n(define (fold-left f acc lst)\n  (if (null? lst) acc (f (car lst) (fold-left f acc (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: This is right-associative, not left-associative.\n\nExpected behavior after patch:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "bugfix", "fold-left"], "split": "train"}
{"id": "core_prelude_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-right` in `core/base/prelude.ss`.\nKnown issue: This behaves like fold-left.\n\n```scheme\n(define (fold-right f acc lst)\n  (if (null? lst) acc (fold-right f (f (car lst) acc) (cdr lst))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-right` in `core/base/prelude.ss`.\nKnown issue: This behaves like fold-left.\n\n```scheme\n(define (fold-right f acc lst)\n  (if (null? lst) acc (fold-right f (f (car lst) acc) (cdr lst))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: This behaves like fold-left.\n\nExpected behavior after patch:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "bugfix", "fold-right"], "split": "train"}
{"id": "core_prelude_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `zip` in `core/base/prelude.ss`.\nKnown issue: Expected pairs `(a . b)`, not two-element lists.\n\n```scheme\n(define (zip xs ys)\n  (map list xs ys))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `zip` in `core/base/prelude.ss`.\nKnown issue: Expected pairs `(a . b)`, not two-element lists.\n\n```scheme\n(define (zip xs ys)\n  (map list xs ys))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "bugfix", "zip"], "split": "train"}
{"id": "core_prelude_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `range` in `core/base/prelude.ss`.\nKnown issue: End should be exclusive.\n\n```scheme\n(define (range start end)\n  (if (> start end) '() (cons start (range (+ start 1) end))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `range` in `core/base/prelude.ss`.\nKnown issue: End should be exclusive.\n\n```scheme\n(define (range start end)\n  (if (> start end) '() (cons start (range (+ start 1) end))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "bugfix", "range"], "split": "train"}
{"id": "core_prelude_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `take` in `core/base/prelude.ss`.\nKnown issue: When n is 0, result must be empty.\n\n```scheme\n(define (take n lst)\n  (if (or (< n 0) (null? lst)) '() (cons (car lst) (take (- n 1) (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `take` in `core/base/prelude.ss`.\nKnown issue: When n is 0, result must be empty.\n\n```scheme\n(define (take n lst)\n  (if (or (< n 0) (null? lst)) '() (cons (car lst) (take (- n 1) (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: When n is 0, result must be empty.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "bugfix", "take"], "split": "train"}
{"id": "core_prelude_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find` in `core/base/prelude.ss`.\nKnown issue: Find returns matching element, not boolean.\n\n```scheme\n(define (find pred lst)\n  (ormap pred lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find` in `core/base/prelude.ss`.\nKnown issue: Find returns matching element, not boolean.\n\n```scheme\n(define (find pred lst)\n  (ormap pred lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (find even? '(1 3 4 6)) 4))\n(let () (not (find even? '(1 3 5))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "bugfix", "find"], "split": "train"}
{"id": "core_prelude_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `init` in `core/base/prelude.ss`.\nKnown issue: Must remove final element.\n\n```scheme\n(define (init lst)\n  lst)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `init` in `core/base/prelude.ss`.\nKnown issue: Must remove final element.\n\n```scheme\n(define (init lst)\n  lst)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must remove final element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "bugfix", "init"], "split": "train"}
{"id": "core_prelude_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `replicate` in `core/base/prelude.ss`.\nKnown issue: For n=0 result should be empty, not one element.\n\n```scheme\n(define (replicate n x)\n  (if (< n 0) '() (cons x (replicate (- n 1) x))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `replicate` in `core/base/prelude.ss`.\nKnown issue: For n=0 result should be empty, not one element.\n\n```scheme\n(define (replicate n x)\n  (if (< n 0) '() (cons x (replicate (- n 1) x))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: For n=0 result should be empty, not one element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n(let () (equal? (replicate 0 'q) '()))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "bugfix", "replicate"], "split": "train"}
{"id": "core_prelude_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span` in `core/base/prelude.ss`.\nKnown issue: Must split at first failure of predicate.\n\n```scheme\n(define (span pred lst)\n  (values lst '()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span` in `core/base/prelude.ss`.\nKnown issue: Must split at first failure of predicate.\n\n```scheme\n(define (span pred lst)\n  (values lst '()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must split at first failure of predicate.\n\nExpected behavior after patch:\n```scheme\n(let () (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "bugfix", "span"], "split": "train"}
{"id": "core_prelude_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `break` in `core/base/prelude.ss`.\nKnown issue: Break should negate predicate before delegating to span.\n\n```scheme\n(define (break pred lst)\n  (span pred lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `break` in `core/base/prelude.ss`.\nKnown issue: Break should negate predicate before delegating to span.\n\n```scheme\n(define (break pred lst)\n  (span pred lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Break should negate predicate before delegating to span.\n\nExpected behavior after patch:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "bugfix", "break"], "split": "train"}
{"id": "core_prelude_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sum` in `core/base/prelude.ss`.\nKnown issue: Sum should add, not multiply.\n\n```scheme\n(define (sum lst)\n  (fold-left * 1 lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sum` in `core/base/prelude.ss`.\nKnown issue: Sum should add, not multiply.\n\n```scheme\n(define (sum lst)\n  (fold-left * 1 lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Sum should add, not multiply.\n\nExpected behavior after patch:\n```scheme\n(let () (= (sum '()) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "bugfix", "sum"], "split": "train"}
{"id": "core_prelude_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `product` in `core/base/prelude.ss`.\nKnown issue: Product should multiply, not add.\n\n```scheme\n(define (product lst)\n  (fold-left + 0 lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `product` in `core/base/prelude.ss`.\nKnown issue: Product should multiply, not add.\n\n```scheme\n(define (product lst)\n  (fold-left + 0 lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "bugfix", "product"], "split": "train"}
{"id": "core_prelude_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mean` in `core/base/prelude.ss`.\nKnown issue: Must error on empty list.\n\n```scheme\n(define (mean lst)\n  (/ (sum lst) (length lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mean` in `core/base/prelude.ss`.\nKnown issue: Must error on empty list.\n\n```scheme\n(define (mean lst)\n  (/ (sum lst) (length lst)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must error on empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "bugfix", "mean"], "split": "train"}
{"id": "core_prelude_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `identity` in `core/base/prelude.ss`.\nKnown issue: Identity must return input unchanged.\n\n```scheme\n(define (identity x)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `identity` in `core/base/prelude.ss`.\nKnown issue: Identity must return input unchanged.\n\n```scheme\n(define (identity x)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Identity must return input unchanged.\n\nExpected behavior after patch:\n```scheme\n(let () (= (identity 42) 42))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (identity 42) 42))\n(let () (equal? (identity '(a b)) '(a b)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "bugfix", "identity"], "split": "train"}
{"id": "core_prelude_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `core/base/prelude.ss`.\nKnown issue: Output order is `(yes no)`.\n\n```scheme\n(define (partition pred lst)\n  (list (filter (lambda (x) (not (pred x))) lst) (filter pred lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `core/base/prelude.ss`.\nKnown issue: Output order is `(yes no)`.\n\n```scheme\n(define (partition pred lst)\n  (list (filter (lambda (x) (not (pred x))) lst) (filter pred lst)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Output order is `(yes no)`.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "bugfix", "partition"], "split": "train"}
{"id": "core_prelude_bugfix_026", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distinct-by` in `core/base/prelude.ss`.\nKnown issue: Must deduplicate by computed key while preserving first occurrences.\n\n```scheme\n(define (distinct-by key-fn lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distinct-by` in `core/base/prelude.ss`.\nKnown issue: Must deduplicate by computed key while preserving first occurrences.\n\n```scheme\n(define (distinct-by key-fn lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must deduplicate by computed key while preserving first occurrences.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "bugfix", "distinct-by"], "split": "train"}
{"id": "core_prelude_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Return whether any element in `(\"a\" 2 \"c\")` is a number.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether any element in `(\"a\" 2 \"c\")` is a number.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(ormap number? '(\"a\" 2 \"c\"))", "verify_expr": "(equal? (ormap number? '(\"a\" 2 \"c\")) #t)", "tags": ["core", "base", "prelude", "composition", "ormap", "direct"], "split": "train"}
{"id": "core_prelude_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Keep evens from `(1 2 3 4 5 6)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nKeep evens from `(1 2 3 4 5 6)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(filter even? '(1 2 3 4 5 6))", "verify_expr": "(equal? (filter even? '(1 2 3 4 5 6)) '(2 4 6))", "tags": ["core", "base", "prelude", "composition", "filter", "direct"], "split": "train"}
{"id": "core_prelude_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Double positive numbers and drop others from `(-1 0 2 3)`.", "prompt": "Task mode: small integration task across module primitives.\n\nDouble positive numbers and drop others from `(-1 0 2 3)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-1 0 2 3))", "verify_expr": "(equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-1 0 2 3)) '(4 6))", "tags": ["core", "base", "prelude", "composition", "filter-map", "direct"], "split": "train"}
{"id": "core_prelude_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Compute sum of `(1 2 3 4)` using fold-left.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute sum of `(1 2 3 4)` using fold-left.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(fold-left + 0 '(1 2 3 4))", "verify_expr": "(equal? (fold-left + 0 '(1 2 3 4)) 10)", "tags": ["core", "base", "prelude", "composition", "fold-left", "direct"], "split": "train"}
{"id": "core_prelude_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Zip `(1 2 3)` and `(a b)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nZip `(1 2 3)` and `(a b)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(zip '(1 2 3) '(a b))", "verify_expr": "(equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b)))", "tags": ["core", "base", "prelude", "composition", "zip", "direct"], "split": "train"}
{"id": "core_prelude_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Generate `iota` for 5.", "prompt": "Task mode: compose existing APIs into one expression.\n\nGenerate `iota` for 5.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(iota 5)", "verify_expr": "(equal? (iota 5) '(0 1 2 3 4))", "tags": ["core", "base", "prelude", "composition", "iota", "direct"], "split": "train"}
{"id": "core_prelude_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Generate range from 3 to 7.", "prompt": "Task mode: compose existing APIs into one expression.\n\nGenerate range from 3 to 7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(range 3 7)", "verify_expr": "(equal? (range 3 7) '(3 4 5 6))", "tags": ["core", "base", "prelude", "composition", "range", "direct"], "split": "train"}
{"id": "core_prelude_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Drop 3 elements from `(a b c d e)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDrop 3 elements from `(a b c d e)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(drop 3 '(a b c d e))", "verify_expr": "(equal? (drop 3 '(a b c d e)) '(d e))", "tags": ["core", "base", "prelude", "composition", "drop", "direct"], "split": "train"}
{"id": "core_prelude_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Find first even value in `(1 3 4 6)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFind first even value in `(1 3 4 6)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(find even? '(1 3 4 6))", "verify_expr": "(equal? (find even? '(1 3 4 6)) 4)", "tags": ["core", "base", "prelude", "composition", "find", "direct"], "split": "train"}
{"id": "core_prelude_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Return last element of `(x y z)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn last element of `(x y z)`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(last '(x y z))", "verify_expr": "(equal? (last '(x y z)) 'z)", "tags": ["core", "base", "prelude", "composition", "last", "direct"], "split": "train"}
{"id": "core_prelude_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Return init of `(x y z)`.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn init of `(x y z)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(init '(x y z))", "verify_expr": "(equal? (init '(x y z)) '(x y))", "tags": ["core", "base", "prelude", "composition", "init", "direct"], "split": "train"}
{"id": "core_prelude_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Split `(1 3 5 2 4)` at first even using break.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSplit `(1 3 5 2 4)` at first even using break.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (list pre suf))", "verify_expr": "(equal? (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (list pre suf)) '((1 3 5) (2 4)))", "tags": ["core", "base", "prelude", "composition", "break", "direct"], "split": "train"}
{"id": "core_prelude_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Apply identity to list `(a b)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply identity to list `(a b)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(identity '(a b))", "verify_expr": "(equal? (identity '(a b)) '(a b))", "tags": ["core", "base", "prelude", "composition", "identity", "direct"], "split": "train"}
{"id": "core_prelude_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Flatten list-of-lists `((1 2) () (3 4))`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlatten list-of-lists `((1 2) () (3 4))`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(flatten '((1 2) () (3 4)))", "verify_expr": "(equal? (flatten '((1 2) () (3 4))) '(1 2 3 4))", "tags": ["core", "base", "prelude", "composition", "flatten", "direct"], "split": "train"}
{"id": "core_prelude_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Duplicate each element with append-map over `(1 2 3)`.", "prompt": "Task mode: small integration task across module primitives.\n\nDuplicate each element with append-map over `(1 2 3)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(append-map (lambda (x) (list x x)) '(1 2 3))", "verify_expr": "(equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3))", "tags": ["core", "base", "prelude", "composition", "append-map", "direct"], "split": "train"}
{"id": "core_prelude_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Partition `(1 2 3 4 5)` by even?.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition `(1 2 3 4 5)` by even?.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition even? '(1 2 3 4 5))", "verify_expr": "(equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5)))", "tags": ["core", "base", "prelude", "composition", "partition", "direct"], "split": "train"}
{"id": "core_prelude_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Group strings by length in `(\"a\" \"b\" \"cc\" \"dd\")`.", "prompt": "Task mode: small integration task across module primitives.\n\nGroup strings by length in `(\"a\" \"b\" \"cc\" \"dd\")`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(group-by string-length '(\"a\" \"b\" \"cc\" \"dd\"))", "verify_expr": "(equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\")))", "tags": ["core", "base", "prelude", "composition", "group-by", "direct"], "split": "train"}
{"id": "core_prelude_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Keep first string per initial letter.", "prompt": "Task mode: compose existing APIs into one expression.\n\nKeep first string per initial letter.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\"))", "verify_expr": "(equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\"))", "tags": ["core", "base", "prelude", "composition", "distinct-by", "direct"], "split": "train"}
{"id": "core_prelude_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Return #t iff `sum (iota 6)` equals 15.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff `sum (iota 6)` equals 15.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (sum (iota 6)) 15)", "verify_expr": "(equal? (= (sum (iota 6)) 15) #t)", "tags": ["core", "base", "prelude", "composition", "sum", "integration"], "split": "train"}
{"id": "core_prelude_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Build reversed list via fold-left and cons.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild reversed list via fold-left and cons.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(fold-left (lambda (acc x) (cons x acc)) '() '(1 2 3 4))", "verify_expr": "(equal? (fold-left (lambda (acc x) (cons x acc)) '() '(1 2 3 4)) '(4 3 2 1))", "tags": ["core", "base", "prelude", "composition", "fold-left", "integration"], "split": "train"}
{"id": "core_prelude_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Return #t iff `break` is the opposite split of `span` for predicate even? on `(1 3 5 2 4)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff `break` is the opposite split of `span` for predicate even? on `(1 3 5 2 4)`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let-values ([(a b) (break even? '(1 3 5 2 4))]) (and (equal? a '(1 3 5)) (equal? b '(2 4))))", "verify_expr": "(equal? (let-values ([(a b) (break even? '(1 3 5 2 4))]) (and (equal? a '(1 3 5)) (equal? b '(2 4)))) #t)", "tags": ["core", "base", "prelude", "composition", "break", "property"], "split": "train"}
{"id": "core_prelude_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Count partition sizes for `(1 2 3 4 5 6)` by even?.", "prompt": "Task mode: small integration task across module primitives.\n\nCount partition sizes for `(1 2 3 4 5 6)` by even?.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (partition even? '(1 2 3 4 5 6))] [yes (car p)] [no (cadr p)]) (list (length yes) (length no)))", "verify_expr": "(equal? (let* ([p (partition even? '(1 2 3 4 5 6))] [yes (car p)] [no (cadr p)]) (list (length yes) (length no))) '(3 3))", "tags": ["core", "base", "prelude", "composition", "partition", "integration"], "split": "train"}
{"id": "core_prelude_ext_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must remove duplicates while preserving first occurrence.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-simple '(a b a c b a)) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unique-simple"], "split": "train"}
{"id": "core_prelude_ext_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-fast` in `core/base/prelude.ss`.\nKnown issue: Order and complexity behavior are wrong.\n\n```scheme\n(define (unique-fast lst)\n  (unique-simple (reverse lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-fast` in `core/base/prelude.ss`.\nKnown issue: Order and complexity behavior are wrong.\n\n```scheme\n(define (unique-fast lst)\n  (unique-simple (reverse lst)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Order and complexity behavior are wrong.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cons*` in `core/base/prelude.ss`.\nKnown issue: cons* builds improper lists, not always proper lists.\n\n```scheme\n(define (cons* . args)\n  (apply list args))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cons*` in `core/base/prelude.ss`.\nKnown issue: cons* builds improper lists, not always proper lists.\n\n```scheme\n(define (cons* . args)\n  (apply list args))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "cons*"], "split": "train"}
{"id": "core_prelude_ext_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assoc-ref` in `core/base/prelude.ss`.\nKnown issue: assoc-ref must use assoc/equal?, not assq/eq?.\n\n```scheme\n(define (assoc-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assoc-ref` in `core/base/prelude.ss`.\nKnown issue: assoc-ref must use assoc/equal?, not assq/eq?.\n\n```scheme\n(define (assoc-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2))\n(let () (not (assoc-ref '((a . 1)) 'z)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `core/base/prelude.ss`.\nKnown issue: Must replace existing key entries and put new mapping at front.\n\n```scheme\n(define (alist-update alist key value)\n  (append alist (list (cons key value))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `core/base/prelude.ss`.\nKnown issue: Must replace existing key entries and put new mapping at front.\n\n```scheme\n(define (alist-update alist key value)\n  (append alist (list (cons key value))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must replace existing key entries and put new mapping at front.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "alist-update"], "split": "train"}
{"id": "core_prelude_ext_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag check is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (ok? '(ok 42)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "ok?"], "split": "train"}
{"id": "core_prelude_ext_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (error? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (error? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag check is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (error? '(error bad detail)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "error?"], "split": "train"}
{"id": "core_prelude_ext_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-ok` in `core/base/prelude.ss`.\nKnown issue: Should return payload, not tag.\n\n```scheme\n(define (unwrap-ok result)\n  (car result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-ok` in `core/base/prelude.ss`.\nKnown issue: Should return payload, not tag.\n\n```scheme\n(define (unwrap-ok result)\n  (car result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-error` in `core/base/prelude.ss`.\nKnown issue: Should return full error payload tail.\n\n```scheme\n(define (unwrap-error result)\n  (cadr result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-error` in `core/base/prelude.ss`.\nKnown issue: Should return full error payload tail.\n\n```scheme\n(define (unwrap-error result)\n  (cadr result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Should return full error payload tail.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unwrap-error '(error bad detail)) '(bad detail)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-map` in `core/base/prelude.ss`.\nKnown issue: Errors must pass through unchanged.\n\n```scheme\n(define (result-map f result)\n  `(ok ,(f (unwrap-ok result))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-map` in `core/base/prelude.ss`.\nKnown issue: Errors must pass through unchanged.\n\n```scheme\n(define (result-map f result)\n  `(ok ,(f (unwrap-ok result))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Errors must pass through unchanged.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-map"], "split": "train"}
{"id": "core_prelude_ext_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-bind` in `core/base/prelude.ss`.\nKnown issue: Bind should return f's result directly for ok case.\n\n```scheme\n(define (result-bind result f)\n  (result-map f result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-bind` in `core/base/prelude.ss`.\nKnown issue: Bind should return f's result directly for ok case.\n\n```scheme\n(define (result-bind result f)\n  (result-map f result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Bind should return f's result directly for ok case.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must preserve ok values and short-circuit on first error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-sequence"], "split": "train"}
{"id": "core_prelude_ext_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Remove duplicates from `(a b a c b a)` with unique-simple.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove duplicates from `(a b a c b a)` with unique-simple.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unique-simple '(a b a c b a))", "verify_expr": "(equal? (unique-simple '(a b a c b a)) '(a b c))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-simple", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Return length of unique-simple over `(x x y y z)`.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn length of unique-simple over `(x x y y z)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (unique-simple '(x x y y z)))", "verify_expr": "(equal? (length (unique-simple '(x x y y z))) 3)", "tags": ["core", "base", "prelude", "extended", "composition", "unique-simple", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Return #t iff unique-fast preserves first occurrence order.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff unique-fast preserves first occurrence order.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (unique-fast '(3 1 3 2 1)) '(3 1 2))", "verify_expr": "(equal? (unique-fast '(3 1 3 2 1)) '(3 1 2))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-fast", "property"], "split": "train"}
{"id": "core_prelude_ext_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Build `(a b . c)` using cons*.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild `(a b . c)` using cons*.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cons* 'a 'b 'c)", "verify_expr": "(equal? (cons* 'a 'b 'c) '(a b . c))", "tags": ["core", "base", "prelude", "extended", "composition", "cons*", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Call cons* with one argument `q`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCall cons* with one argument `q`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cons* 'q)", "verify_expr": "(equal? (cons* 'q) 'q)", "tags": ["core", "base", "prelude", "extended", "composition", "cons*", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Lookup key `b` in `((a . 1) (b . 2))`.", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key `b` in `((a . 1) (b . 2))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(assoc-ref '((a . 1) (b . 2)) 'b)", "verify_expr": "(equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "assoc-ref", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Lookup symbol `a` via assq-ref.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLookup symbol `a` via assq-ref.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assq-ref '((a . 1) (b . 2)) 'a)", "verify_expr": "(equal? (assq-ref '((a . 1) (b . 2)) 'a) 1)", "tags": ["core", "base", "prelude", "extended", "composition", "assq-ref", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Return #f when assq-ref key is missing.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #f when assq-ref key is missing.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assq-ref '((a . 1)) 'z)", "verify_expr": "(equal? (assq-ref '((a . 1)) 'z) #f)", "tags": ["core", "base", "prelude", "extended", "composition", "assq-ref", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Update existing key `a` to 9.", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpdate existing key `a` to 9.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(assoc-ref (alist-update '((a . 1) (b . 2)) 'a 9) 'a)", "verify_expr": "(equal? (assoc-ref (alist-update '((a . 1) (b . 2)) 'a 9) 'a) 9)", "tags": ["core", "base", "prelude", "extended", "composition", "alist-update", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Insert new key `c` with value 7.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert new key `c` with value 7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assoc-ref (alist-update '((a . 1)) 'c 7) 'c)", "verify_expr": "(equal? (assoc-ref (alist-update '((a . 1)) 'c 7) 'c) 7)", "tags": ["core", "base", "prelude", "extended", "composition", "alist-update", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Count ok? results in a mixed list.", "prompt": "Task mode: small integration task across module primitives.\n\nCount ok? results in a mixed list.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (filter ok? '((ok 1) (error bad) (ok 2))))", "verify_expr": "(equal? (length (filter ok? '((ok 1) (error bad) (ok 2)))) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "ok?", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Check error? on `(error bad detail)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck error? on `(error bad detail)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(error? '(error bad detail))", "verify_expr": "(equal? (error? '(error bad detail)) #t)", "tags": ["core", "base", "prelude", "extended", "composition", "error?", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Count error? results in a mixed list.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount error? results in a mixed list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (filter error? '((ok 1) (error bad) (error x))))", "verify_expr": "(equal? (length (filter error? '((ok 1) (error bad) (error x)))) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "error?", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Map unwrap-ok across only ok values.", "prompt": "Task mode: small integration task across module primitives.\n\nMap unwrap-ok across only ok values.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map unwrap-ok '((ok 1) (ok 2) (ok 3)))", "verify_expr": "(equal? (map unwrap-ok '((ok 1) (ok 2) (ok 3))) '(1 2 3))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-ok", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Unwrap `(error bad detail)` payload.", "prompt": "Task mode: small integration task across module primitives.\n\nUnwrap `(error bad detail)` payload.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unwrap-error '(error bad detail))", "verify_expr": "(equal? (unwrap-error '(error bad detail)) '(bad detail))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-error", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Unwrap error with one tag.", "prompt": "Task mode: small integration task across module primitives.\n\nUnwrap error with one tag.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(unwrap-error '(error oops))", "verify_expr": "(equal? (unwrap-error '(error oops)) '(oops))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-error", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Return unchanged error through result-map.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn unchanged error through result-map.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(result-map (lambda (x) (* x 2)) '(error bad))", "verify_expr": "(equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-map", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Bind ok result through increment function.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBind ok result through increment function.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1))))", "verify_expr": "(equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6))", "tags": ["core", "base", "prelude", "extended", "composition", "result-bind", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Return unchanged error through result-bind.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn unchanged error through result-bind.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-bind '(error bad) (lambda (x) `(ok ,(+ x 1))))", "verify_expr": "(equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-bind", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Sequence three ok results.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSequence three ok results.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-sequence '((ok 1) (ok 2) (ok 3)))", "verify_expr": "(equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3)))", "tags": ["core", "base", "prelude", "extended", "composition", "result-sequence", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Short-circuit result-sequence on first error.", "prompt": "Task mode: compose existing APIs into one expression.\n\nShort-circuit result-sequence on first error.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(result-sequence '((ok 1) (error bad) (ok 3)))", "verify_expr": "(equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-sequence", "direct"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-simple lst)\n  ;; TODO: O(n^2) duplicate removal using memq\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-simple`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-simple lst)\n  ;; TODO: O(n^2) duplicate removal using memq\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-simple`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unique-simple"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-fast`\nSpec: Remove duplicates using a hashtable (equal?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-fast`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-fast`\nSpec: Remove duplicates using a hashtable (equal?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-fast`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-fast lst)\n  ;; TODO: O(n) duplicate removal using hashtable\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-fast`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-fast lst)\n  ;; TODO: O(n) duplicate removal using hashtable\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-fast`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "cons*"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assoc-ref`\nSpec: Lookup key using assoc/equal? and return value or #f.\n\nWrite exactly one Scheme function definition for `assoc-ref`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assoc-ref`\nSpec: Lookup key using assoc/equal? and return value or #f.\n\nWrite exactly one Scheme function definition for `assoc-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (assoc-ref alist key)\n  ;; TODO: assoc lookup by equal?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assoc-ref`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (assoc-ref alist key)\n  ;; TODO: assoc lookup by equal?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assoc-ref`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (assq-ref alist key)\n  ;; TODO: assq lookup by eq?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assq-ref`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (assq-ref alist key)\n  ;; TODO: assq lookup by eq?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assq-ref`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-update alist key value)\n  ;; TODO: insert new key/value and remove stale entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-update`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-update alist key value)\n  ;; TODO: insert new key/value and remove stale entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-update`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "alist-update"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ok?`\nSpec: Return #t iff value is tagged `(ok ...)`.\n\nWrite exactly one Scheme function definition for `ok?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ok?`\nSpec: Return #t iff value is tagged `(ok ...)`.\n\nWrite exactly one Scheme function definition for `ok?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (ok? '(ok 42)))\n(let () (not (ok? '(error bad))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "ok?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ok? result)\n  ;; TODO: tag check for ok\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ok?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ok? result)\n  ;; TODO: tag check for ok\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ok?`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "ok?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (error? result)\n  ;; TODO: tag check for error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error? result)\n  ;; TODO: tag check for error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (error? '(error bad detail)))\n(let () (not (error? '(ok 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "error?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-ok`\nSpec: Extract ok payload from `(ok value)`.\n\nWrite exactly one Scheme function definition for `unwrap-ok`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-ok`\nSpec: Extract ok payload from `(ok value)`.\n\nWrite exactly one Scheme function definition for `unwrap-ok`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (unwrap-ok '(ok (1 2))) '(1 2)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-ok result)\n  ;; TODO: extract ok payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-ok`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-ok result)\n  ;; TODO: extract ok payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-ok`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-error`\nSpec: Extract error payload tail from `(error tag ...)`.\n\nWrite exactly one Scheme function definition for `unwrap-error`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-error`\nSpec: Extract error payload tail from `(error tag ...)`.\n\nWrite exactly one Scheme function definition for `unwrap-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-map`\nSpec: Apply function to ok payload and pass through errors unchanged.\n\nWrite exactly one Scheme function definition for `result-map`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-map`\nSpec: Apply function to ok payload and pass through errors unchanged.\n\nWrite exactly one Scheme function definition for `result-map`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)))\n(let () (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-map"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-map f result)\n  ;; TODO: map only successful results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-map`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-map f result)\n  ;; TODO: map only successful results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-map`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-map"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-bind result f)\n  ;; TODO: bind successful result through f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-bind`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-bind result f)\n  ;; TODO: bind successful result through f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-bind`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)))\n(let () (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-sequence results)\n  ;; TODO: sequence list of results with short-circuiting\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-sequence`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-sequence results)\n  ;; TODO: sequence list of results with short-circuiting\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-sequence`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-sequence"], "split": "train"}
{"id": "core_prelude_ext_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cons*`.\nReturn only the Scheme definition.\n\n```python\ndef cons_star(*args):\n    if len(args)==0:\n        raise ValueError('requires at least one argument')\n    if len(args)==1:\n        return args[0]\n    return (args[0], cons_star(*args[1:]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cons*`.\nReturn only the Scheme definition.\n\n```python\ndef cons_star(*args):\n    if len(args)==0:\n        raise ValueError('requires at least one argument')\n    if len(args)==1:\n        return args[0]\n    return (args[0], cons_star(*args[1:]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "cons*"], "split": "train"}
{"id": "core_prelude_ext_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assoc-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assoc_ref(alist, key):\n    for k,v in alist:\n        if k == key:\n            return v\n    return None\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assoc-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assoc_ref(alist, key):\n    for k,v in alist:\n        if k == key:\n            return v\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2))\n(let () (not (assoc-ref '((a . 1)) 'z)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assq-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assq_ref(alist, key):\n    for k,v in alist:\n        if k is key:\n            return v\n    return None\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assq-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assq_ref(alist, key):\n    for k,v in alist:\n        if k is key:\n            return v\n    return None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n(let () (not (assq-ref '((a . 1)) 'z)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ok?`.\nReturn only the Scheme definition.\n\n```python\ndef is_ok(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'ok'\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ok?`.\nReturn only the Scheme definition.\n\n```python\ndef is_ok(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'ok'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (ok? '(ok 42)))\n(let () (not (ok? '(error bad))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "ok?"], "split": "train"}
{"id": "core_prelude_ext_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `error?`.\nReturn only the Scheme definition.\n\n```python\ndef is_error(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'error'\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `error?`.\nReturn only the Scheme definition.\n\n```python\ndef is_error(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'error'\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "error?"], "split": "train"}
{"id": "core_prelude_ext_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-error`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_error(result):\n    return result[1:]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-error`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_error(result):\n    return result[1:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (unwrap-error '(error bad detail)) '(bad detail)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-map"], "split": "train"}
{"id": "core_prelude_ext_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-sequence`.\nReturn only the Scheme definition.\n\n```python\ndef result_sequence(results):\n    out=[]\n    for r in results:\n        if r[0] == 'error':\n            return r\n        out.append(r[1])\n    return ('ok', out)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-sequence`.\nReturn only the Scheme definition.\n\n```python\ndef result_sequence(results):\n    out=[]\n    for r in results:\n        if r[0] == 'error':\n            return r\n        out.append(r[1])\n    return ('ok', out)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-sequence"], "split": "train"}
{"id": "core_prelude_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `andmap`\nSpec: Apply predicate to all elements; return #t for empty list.\n\nWrite exactly one Scheme function definition for `andmap`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `andmap`\nSpec: Apply predicate to all elements; return #t for empty list.\n\nWrite exactly one Scheme function definition for `andmap`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "spec-to-code", "andmap"], "split": "train"}
{"id": "core_prelude_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (andmap pred lst)\n  ;; TODO: #t iff every element satisfies pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `andmap`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (andmap pred lst)\n  ;; TODO: #t iff every element satisfies pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `andmap`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (andmap number? '()))\n(let () (andmap number? '(1 2 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "andmap"], "split": "train"}
{"id": "core_prelude_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ormap`\nSpec: Apply predicate to list; return first truthy result, or #f if none match.\n\nWrite exactly one Scheme function definition for `ormap`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ormap`\nSpec: Apply predicate to list; return first truthy result, or #f if none match.\n\nWrite exactly one Scheme function definition for `ormap`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (not (ormap number? '())))\n(let () (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "spec-to-code", "ormap"], "split": "train"}
{"id": "core_prelude_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter`\nSpec: Return only elements satisfying predicate.\n\nWrite exactly one Scheme function definition for `filter`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter`\nSpec: Return only elements satisfying predicate.\n\nWrite exactly one Scheme function definition for `filter`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "filter"], "split": "train"}
{"id": "core_prelude_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (filter pred lst)\n  ;; TODO: keep only matching elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (filter pred lst)\n  ;; TODO: keep only matching elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "filter"], "split": "train"}
{"id": "core_prelude_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter-map`\nSpec: Map function and keep only non-#f results.\n\nWrite exactly one Scheme function definition for `filter-map`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter-map`\nSpec: Map function and keep only non-#f results.\n\nWrite exactly one Scheme function definition for `filter-map`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "filter-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (filter-map f lst)\n  ;; TODO: map f and keep non-#f results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter-map`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (filter-map f lst)\n  ;; TODO: map f and keep non-#f results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter-map`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "filter-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-left f acc lst)\n  ;; TODO: left-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-left`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-left f acc lst)\n  ;; TODO: left-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-left`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "skeleton-completion", "fold-left"], "split": "train"}
{"id": "core_prelude_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-right`\nSpec: Right-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-right`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-right`\nSpec: Right-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-right`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "spec-to-code", "fold-right"], "split": "train"}
{"id": "core_prelude_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-right f acc lst)\n  ;; TODO: right-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-right`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-right f acc lst)\n  ;; TODO: right-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-right`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "fold-right"], "split": "train"}
{"id": "core_prelude_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (zip xs ys)\n  ;; TODO: zip into pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `zip`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (zip xs ys)\n  ;; TODO: zip into pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `zip`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "skeleton-completion", "zip"], "split": "train"}
{"id": "core_prelude_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `iota`\nSpec: Return list `(0 ... n-1)`.\n\nWrite exactly one Scheme function definition for `iota`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `iota`\nSpec: Return list `(0 ... n-1)`.\n\nWrite exactly one Scheme function definition for `iota`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "spec-to-code", "iota"], "split": "train"}
{"id": "core_prelude_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (iota n)\n  ;; TODO: generate 0..n-1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iota`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (iota n)\n  ;; TODO: generate 0..n-1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iota`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "skeleton-completion", "iota"], "split": "train"}
{"id": "core_prelude_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `range`\nSpec: Return list from start (inclusive) to end (exclusive).\n\nWrite exactly one Scheme function definition for `range`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `range`\nSpec: Return list from start (inclusive) to end (exclusive).\n\nWrite exactly one Scheme function definition for `range`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "spec-to-code", "range"], "split": "train"}
{"id": "core_prelude_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `take`\nSpec: Return first n elements from list.\n\nWrite exactly one Scheme function definition for `take`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `take`\nSpec: Return first n elements from list.\n\nWrite exactly one Scheme function definition for `take`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "spec-to-code", "take"], "split": "train"}
{"id": "core_prelude_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (take n lst)\n  ;; TODO: take first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `take`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (take n lst)\n  ;; TODO: take first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `take`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "skeleton-completion", "take"], "split": "train"}
{"id": "core_prelude_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `drop`\nSpec: Drop first n elements from list.\n\nWrite exactly one Scheme function definition for `drop`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `drop`\nSpec: Drop first n elements from list.\n\nWrite exactly one Scheme function definition for `drop`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (drop 3 '(a b c d e)) '(d e)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "spec-to-code", "drop"], "split": "train"}
{"id": "core_prelude_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (drop n lst)\n  ;; TODO: drop first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `drop`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (drop n lst)\n  ;; TODO: drop first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `drop`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (drop 3 '(a b c d e)) '(d e)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "skeleton-completion", "drop"], "split": "train"}
{"id": "core_prelude_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (find pred lst)\n  ;; TODO: return first match or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `find`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (find pred lst)\n  ;; TODO: return first match or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `find`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (find even? '(1 3 4 6)) 4))\n(let () (not (find even? '(1 3 5))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "find"], "split": "train"}
{"id": "core_prelude_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `last`\nSpec: Return final element of non-empty list.\n\nWrite exactly one Scheme function definition for `last`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `last`\nSpec: Return final element of non-empty list.\n\nWrite exactly one Scheme function definition for `last`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "spec-to-code", "last"], "split": "train"}
{"id": "core_prelude_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (last lst)\n  ;; TODO: return last element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `last`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (last lst)\n  ;; TODO: return last element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `last`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "skeleton-completion", "last"], "split": "train"}
{"id": "core_prelude_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `init`\nSpec: Return all elements except last.\n\nWrite exactly one Scheme function definition for `init`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `init`\nSpec: Return all elements except last.\n\nWrite exactly one Scheme function definition for `init`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "spec-to-code", "init"], "split": "train"}
{"id": "core_prelude_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `replicate`\nSpec: Return list containing n copies of value.\n\nWrite exactly one Scheme function definition for `replicate`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `replicate`\nSpec: Return list containing n copies of value.\n\nWrite exactly one Scheme function definition for `replicate`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n(let () (equal? (replicate 0 'q) '()))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "spec-to-code", "replicate"], "split": "train"}
{"id": "core_prelude_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (replicate n x)\n  ;; TODO: list of n copies of x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `replicate`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (replicate n x)\n  ;; TODO: list of n copies of x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `replicate`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "skeleton-completion", "replicate"], "split": "train"}
{"id": "core_prelude_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `span`\nSpec: Split list at first element that fails predicate.\n\nWrite exactly one Scheme function definition for `span`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `span`\nSpec: Split list at first element that fails predicate.\n\nWrite exactly one Scheme function definition for `span`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "spec-to-code", "span"], "split": "train"}
{"id": "core_prelude_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span pred lst)\n  ;; TODO: return (values prefix suffix)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span pred lst)\n  ;; TODO: return (values prefix suffix)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "span"], "split": "train"}
{"id": "core_prelude_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (break pred lst)\n  ;; TODO: split at first satisfying element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `break`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (break pred lst)\n  ;; TODO: split at first satisfying element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `break`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "break"], "split": "train"}
{"id": "core_prelude_spec_to_code_035", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `sum`\nSpec: Sum numeric list; return 0 for empty list.\n\nWrite exactly one Scheme function definition for `sum`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `sum`\nSpec: Sum numeric list; return 0 for empty list.\n\nWrite exactly one Scheme function definition for `sum`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "spec-to-code", "sum"], "split": "train"}
{"id": "core_prelude_spec_to_code_036", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sum lst)\n  ;; TODO: sum numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sum`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sum lst)\n  ;; TODO: sum numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sum`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "skeleton-completion", "sum"], "split": "train"}
{"id": "core_prelude_spec_to_code_037", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `product`\nSpec: Multiply numeric list; return 1 for empty list.\n\nWrite exactly one Scheme function definition for `product`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `product`\nSpec: Multiply numeric list; return 1 for empty list.\n\nWrite exactly one Scheme function definition for `product`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "spec-to-code", "product"], "split": "train"}
{"id": "core_prelude_spec_to_code_039", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `mean`\nSpec: Arithmetic mean; raise error on empty list.\n\nWrite exactly one Scheme function definition for `mean`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `mean`\nSpec: Arithmetic mean; raise error on empty list.\n\nWrite exactly one Scheme function definition for `mean`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "spec-to-code", "mean"], "split": "train"}
{"id": "core_prelude_spec_to_code_040", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (mean lst)\n  ;; TODO: arithmetic mean (error on empty)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mean`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (mean lst)\n  ;; TODO: arithmetic mean (error on empty)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mean`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "skeleton-completion", "mean"], "split": "train"}
{"id": "core_prelude_spec_to_code_041", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `identity`\nSpec: Return argument unchanged.\n\nWrite exactly one Scheme function definition for `identity`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `identity`\nSpec: Return argument unchanged.\n\nWrite exactly one Scheme function definition for `identity`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "spec-to-code", "identity"], "split": "train"}
{"id": "core_prelude_spec_to_code_043", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `flatten`\nSpec: Concatenate list of lists.\n\nWrite exactly one Scheme function definition for `flatten`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `flatten`\nSpec: Concatenate list of lists.\n\nWrite exactly one Scheme function definition for `flatten`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "flatten"], "split": "train"}
{"id": "core_prelude_spec_to_code_044", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (flatten lst-of-lists)\n  ;; TODO: flatten list-of-lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `flatten`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (flatten lst-of-lists)\n  ;; TODO: flatten list-of-lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `flatten`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "flatten"], "split": "train"}
{"id": "core_prelude_spec_to_code_045", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `append-map`\nSpec: Map to lists and concatenate results.\n\nWrite exactly one Scheme function definition for `append-map`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `append-map`\nSpec: Map to lists and concatenate results.\n\nWrite exactly one Scheme function definition for `append-map`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "spec-to-code", "append-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (append-map f lst)\n  ;; TODO: map to lists then append\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `append-map`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (append-map f lst)\n  ;; TODO: map to lists then append\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `append-map`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "skeleton-completion", "append-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_048", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (partition pred lst)\n  ;; TODO: return (list yes no)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition pred lst)\n  ;; TODO: return (list yes no)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "skeleton-completion", "partition"], "split": "train"}
{"id": "core_prelude_spec_to_code_049", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `group-by`\nSpec: Group consecutive elements by key function result.\n\nWrite exactly one Scheme function definition for `group-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `group-by`\nSpec: Group consecutive elements by key function result.\n\nWrite exactly one Scheme function definition for `group-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "spec-to-code", "group-by"], "split": "train"}
{"id": "core_prelude_spec_to_code_050", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (group-by key-fn lst)\n  ;; TODO: group consecutive elements by key\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `group-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (group-by key-fn lst)\n  ;; TODO: group consecutive elements by key\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `group-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "skeleton-completion", "group-by"], "split": "train"}
{"id": "core_prelude_spec_to_code_051", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `distinct-by`\nSpec: Remove duplicates by key function, preserving first occurrence.\n\nWrite exactly one Scheme function definition for `distinct-by`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `distinct-by`\nSpec: Remove duplicates by key function, preserving first occurrence.\n\nWrite exactly one Scheme function definition for `distinct-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "spec-to-code", "distinct-by"], "split": "train"}
{"id": "core_prelude_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `andmap`.\nReturn only the Scheme definition.\n\n```python\ndef andmap(pred, xs):\n    return all(pred(x) for x in xs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `andmap`.\nReturn only the Scheme definition.\n\n```python\ndef andmap(pred, xs):\n    return all(pred(x) for x in xs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "andmap"], "split": "train"}
{"id": "core_prelude_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ormap`.\nReturn only the Scheme definition.\n\n```python\ndef ormap(pred, xs):\n    for x in xs:\n        v = pred(x)\n        if v:\n            return v\n    return False\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ormap`.\nReturn only the Scheme definition.\n\n```python\ndef ormap(pred, xs):\n    for x in xs:\n        v = pred(x)\n        if v:\n            return v\n    return False\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "python-to-scheme", "ormap"], "split": "train"}
{"id": "core_prelude_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter`.\nReturn only the Scheme definition.\n\n```python\ndef filter_(pred, xs):\n    return [x for x in xs if pred(x)]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter`.\nReturn only the Scheme definition.\n\n```python\ndef filter_(pred, xs):\n    return [x for x in xs if pred(x)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "filter"], "split": "train"}
{"id": "core_prelude_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-left`.\nReturn only the Scheme definition.\n\n```python\ndef fold_left(f, acc, xs):\n    for x in xs:\n        acc=f(acc,x)\n    return acc\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-left`.\nReturn only the Scheme definition.\n\n```python\ndef fold_left(f, acc, xs):\n    for x in xs:\n        acc=f(acc,x)\n    return acc\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "python-to-scheme", "fold-left"], "split": "train"}
{"id": "core_prelude_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-right`.\nReturn only the Scheme definition.\n\n```python\ndef fold_right(f, acc, xs):\n    for x in reversed(xs):\n        acc=f(x,acc)\n    return acc\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-right`.\nReturn only the Scheme definition.\n\n```python\ndef fold_right(f, acc, xs):\n    for x in reversed(xs):\n        acc=f(x,acc)\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "fold-right"], "split": "train"}
{"id": "core_prelude_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `zip`.\nReturn only the Scheme definition.\n\n```python\ndef zip_(xs, ys):\n    return list(zip(xs, ys))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `zip`.\nReturn only the Scheme definition.\n\n```python\ndef zip_(xs, ys):\n    return list(zip(xs, ys))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "python-to-scheme", "zip"], "split": "train"}
{"id": "core_prelude_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `iota`.\nReturn only the Scheme definition.\n\n```python\ndef iota(n):\n    return list(range(0, n))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `iota`.\nReturn only the Scheme definition.\n\n```python\ndef iota(n):\n    return list(range(0, n))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "python-to-scheme", "iota"], "split": "train"}
{"id": "core_prelude_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `range`.\nReturn only the Scheme definition.\n\n```python\ndef range_(start, end):\n    return list(range(start, end))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `range`.\nReturn only the Scheme definition.\n\n```python\ndef range_(start, end):\n    return list(range(start, end))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "python-to-scheme", "range"], "split": "train"}
{"id": "core_prelude_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `drop`.\nReturn only the Scheme definition.\n\n```python\ndef drop(n, xs):\n    return xs[n:]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `drop`.\nReturn only the Scheme definition.\n\n```python\ndef drop(n, xs):\n    return xs[n:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "python-to-scheme", "drop"], "split": "train"}
{"id": "core_prelude_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `find`.\nReturn only the Scheme definition.\n\n```python\ndef find(pred, xs):\n    for x in xs:\n        if pred(x):\n            return x\n    return None\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `find`.\nReturn only the Scheme definition.\n\n```python\ndef find(pred, xs):\n    for x in xs:\n        if pred(x):\n            return x\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "find"], "split": "train"}
{"id": "core_prelude_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `last`.\nReturn only the Scheme definition.\n\n```python\ndef last(xs):\n    return xs[-1]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `last`.\nReturn only the Scheme definition.\n\n```python\ndef last(xs):\n    return xs[-1]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "python-to-scheme", "last"], "split": "train"}
{"id": "core_prelude_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `init`.\nReturn only the Scheme definition.\n\n```python\ndef init(xs):\n    return xs[:-1]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `init`.\nReturn only the Scheme definition.\n\n```python\ndef init(xs):\n    return xs[:-1]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "python-to-scheme", "init"], "split": "train"}
{"id": "core_prelude_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span`.\nReturn only the Scheme definition.\n\n```python\ndef span(pred, xs):\n    i=0\n    while i < len(xs) and pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span`.\nReturn only the Scheme definition.\n\n```python\ndef span(pred, xs):\n    i=0\n    while i < len(xs) and pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "span"], "split": "train"}
{"id": "core_prelude_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `break`.\nReturn only the Scheme definition.\n\n```python\ndef break_(pred, xs):\n    i=0\n    while i < len(xs) and not pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `break`.\nReturn only the Scheme definition.\n\n```python\ndef break_(pred, xs):\n    i=0\n    while i < len(xs) and not pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "break"], "split": "train"}
{"id": "core_prelude_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `sum`.\nReturn only the Scheme definition.\n\n```python\ndef sum_(xs):\n    return sum(xs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `sum`.\nReturn only the Scheme definition.\n\n```python\ndef sum_(xs):\n    return sum(xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "python-to-scheme", "sum"], "split": "train"}
{"id": "core_prelude_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `product`.\nReturn only the Scheme definition.\n\n```python\ndef product(xs):\n    out=1\n    for x in xs:\n        out*=x\n    return out\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `product`.\nReturn only the Scheme definition.\n\n```python\ndef product(xs):\n    out=1\n    for x in xs:\n        out*=x\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "python-to-scheme", "product"], "split": "train"}
{"id": "core_prelude_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mean`.\nReturn only the Scheme definition.\n\n```python\ndef mean(xs):\n    if len(xs)==0:\n        raise ValueError('empty list')\n    return sum(xs)/len(xs)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mean`.\nReturn only the Scheme definition.\n\n```python\ndef mean(xs):\n    if len(xs)==0:\n        raise ValueError('empty list')\n    return sum(xs)/len(xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "python-to-scheme", "mean"], "split": "train"}
{"id": "core_prelude_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `flatten`.\nReturn only the Scheme definition.\n\n```python\ndef flatten(xss):\n    return [x for xs in xss for x in xs]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `flatten`.\nReturn only the Scheme definition.\n\n```python\ndef flatten(xss):\n    return [x for xs in xss for x in xs]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "flatten"], "split": "train"}
{"id": "core_prelude_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `append-map`.\nReturn only the Scheme definition.\n\n```python\ndef append_map(f, xs):\n    out=[]\n    for x in xs:\n        out.extend(f(x))\n    return out\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `append-map`.\nReturn only the Scheme definition.\n\n```python\ndef append_map(f, xs):\n    out=[]\n    for x in xs:\n        out.extend(f(x))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "python-to-scheme", "append-map"], "split": "train"}
{"id": "core_prelude_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(pred, xs):\n    yes=[]; no=[]\n    for x in xs:\n        (yes if pred(x) else no).append(x)\n    return [yes,no]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(pred, xs):\n    yes=[]; no=[]\n    for x in xs:\n        (yes if pred(x) else no).append(x)\n    return [yes,no]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "python-to-scheme", "partition"], "split": "train"}
{"id": "core_prelude_translation_025", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `group-by`.\nReturn only the Scheme definition.\n\n```python\ndef group_by(key_fn, xs):\n    if not xs:\n        return []\n    out=[]\n    cur_k=key_fn(xs[0]); cur=[]\n    for x in xs:\n        k=key_fn(x)\n        if k==cur_k:\n            cur.append(x)\n        else:\n            out.append((cur_k,cur)); cur_k=k; cur=[x]\n    out.append((cur_k,cur))\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `group-by`.\nReturn only the Scheme definition.\n\n```python\ndef group_by(key_fn, xs):\n    if not xs:\n        return []\n    out=[]\n    cur_k=key_fn(xs[0]); cur=[]\n    for x in xs:\n        k=key_fn(x)\n        if k==cur_k:\n            cur.append(x)\n        else:\n            out.append((cur_k,cur)); cur_k=k; cur=[x]\n    out.append((cur_k,cur))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "python-to-scheme", "group-by"], "split": "train"}
