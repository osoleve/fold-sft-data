{"id": "core_prelude_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter` in `core/base/prelude.ss`.\nKnown issue: Predicate logic is inverted.\n\n```scheme\n(define (filter pred lst)\n  (cond [(null? lst) '()]\n        [(pred (car lst)) (filter pred (cdr lst))]\n        [else (cons (car lst) (filter pred (cdr lst)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter` in `core/base/prelude.ss`.\nKnown issue: Predicate logic is inverted.\n\n```scheme\n(define (filter pred lst)\n  (cond [(null? lst) '()]\n        [(pred (car lst)) (filter pred (cdr lst))]\n        [else (cons (car lst) (filter pred (cdr lst)))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Predicate logic is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "bugfix", "filter"], "split": "eval"}
{"id": "core_prelude_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/prelude.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()]) (if (> i n) (reverse acc) (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/prelude.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()]) (if (> i n) (reverse acc) (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "bugfix", "iota"], "split": "eval"}
{"id": "core_prelude_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `drop` in `core/base/prelude.ss`.\nKnown issue: Drop and take are not the same.\n\n```scheme\n(define (drop n lst)\n  (take n lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `drop` in `core/base/prelude.ss`.\nKnown issue: Drop and take are not the same.\n\n```scheme\n(define (drop n lst)\n  (take n lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (drop 3 '(a b c d e)) '(d e)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "bugfix", "drop"], "split": "eval"}
{"id": "core_prelude_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `last` in `core/base/prelude.ss`.\nKnown issue: Must return final element.\n\n```scheme\n(define (last lst)\n  (car lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `last` in `core/base/prelude.ss`.\nKnown issue: Must return final element.\n\n```scheme\n(define (last lst)\n  (car lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must return final element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "bugfix", "last"], "split": "eval"}
{"id": "core_prelude_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `flatten` in `core/base/prelude.ss`.\nKnown issue: Must concatenate all inner lists.\n\n```scheme\n(define (flatten lst-of-lists)\n  (if (null? lst-of-lists) '() (car lst-of-lists)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `flatten` in `core/base/prelude.ss`.\nKnown issue: Must concatenate all inner lists.\n\n```scheme\n(define (flatten lst-of-lists)\n  (if (null? lst-of-lists) '() (car lst-of-lists)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must concatenate all inner lists.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "bugfix", "flatten"], "split": "eval"}
{"id": "core_prelude_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `append-map` in `core/base/prelude.ss`.\nKnown issue: Must append mapped lists into one list.\n\n```scheme\n(define (append-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `append-map` in `core/base/prelude.ss`.\nKnown issue: Must append mapped lists into one list.\n\n```scheme\n(define (append-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must append mapped lists into one list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "bugfix", "append-map"], "split": "eval"}
{"id": "core_prelude_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `core/base/prelude.ss`.\nKnown issue: Must produce grouped key/list pairs.\n\n```scheme\n(define (group-by key-fn lst)\n  '())\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `core/base/prelude.ss`.\nKnown issue: Must produce grouped key/list pairs.\n\n```scheme\n(define (group-by key-fn lst)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "bugfix", "group-by"], "split": "eval"}
{"id": "core_prelude_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Return whether all elements in `(1 2 3)` are numbers.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether all elements in `(1 2 3)` are numbers.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(andmap number? '(1 2 3))", "verify_expr": "(equal? (andmap number? '(1 2 3)) #t)", "tags": ["core", "base", "prelude", "composition", "andmap", "direct"], "split": "eval"}
{"id": "core_prelude_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Build nested pair form with fold-right over `(1 2)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild nested pair form with fold-right over `(1 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-right (lambda (x acc) (list x acc)) 0 '(1 2))", "verify_expr": "(equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))", "tags": ["core", "base", "prelude", "composition", "fold-right", "direct"], "split": "eval"}
{"id": "core_prelude_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Take 3 elements from `(a b c d e)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTake 3 elements from `(a b c d e)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(take 3 '(a b c d e))", "verify_expr": "(equal? (take 3 '(a b c d e)) '(a b c))", "tags": ["core", "base", "prelude", "composition", "take", "direct"], "split": "eval"}
{"id": "core_prelude_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Replicate symbol `q` three times.", "prompt": "Task mode: small integration task across module primitives.\n\nReplicate symbol `q` three times.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(replicate 3 'q)", "verify_expr": "(equal? (replicate 3 'q) '(q q q))", "tags": ["core", "base", "prelude", "composition", "replicate", "direct"], "split": "eval"}
{"id": "core_prelude_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Split `(1 2 3 4)` with predicate `<3` using span.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSplit `(1 2 3 4)` with predicate `<3` using span.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (list pre suf))", "verify_expr": "(equal? (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (list pre suf)) '((1 2) (3 4)))", "tags": ["core", "base", "prelude", "composition", "span", "direct"], "split": "eval"}
{"id": "core_prelude_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Sum values `(10 20 30)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSum values `(10 20 30)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sum '(10 20 30))", "verify_expr": "(equal? (sum '(10 20 30)) 60)", "tags": ["core", "base", "prelude", "composition", "sum", "direct"], "split": "eval"}
{"id": "core_prelude_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Product of `(2 3 4)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nProduct of `(2 3 4)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(product '(2 3 4))", "verify_expr": "(equal? (product '(2 3 4)) 24)", "tags": ["core", "base", "prelude", "composition", "product", "direct"], "split": "eval"}
{"id": "core_prelude_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Mean of `(2 4 6 8)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMean of `(2 4 6 8)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mean '(2 4 6 8))", "verify_expr": "(equal? (mean '(2 4 6 8)) 5)", "tags": ["core", "base", "prelude", "composition", "mean", "direct"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assq-ref` in `core/base/prelude.ss`.\nKnown issue: assq-ref must use assq/eq? semantics.\n\n```scheme\n(define (assq-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assq-ref` in `core/base/prelude.ss`.\nKnown issue: assq-ref must use assq/eq? semantics.\n\n```scheme\n(define (assq-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: assq-ref must use assq/eq? semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n(let () (not (assq-ref '((a . 1)) 'z)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "assq-ref"], "split": "eval"}
{"id": "core_prelude_ext_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Remove duplicates from string list with unique-fast.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove duplicates from string list with unique-fast.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\"))", "verify_expr": "(equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\"))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-fast", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Return #f when assoc-ref key is missing.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #f when assoc-ref key is missing.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assoc-ref '((a . 1)) 'z)", "verify_expr": "(equal? (assoc-ref '((a . 1)) 'z) #f)", "tags": ["core", "base", "prelude", "extended", "composition", "assoc-ref", "edge-case"], "split": "eval"}
{"id": "core_prelude_ext_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Check ok? on `(ok 42)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck ok? on `(ok 42)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(ok? '(ok 42))", "verify_expr": "(equal? (ok? '(ok 42)) #t)", "tags": ["core", "base", "prelude", "extended", "composition", "ok?", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Unwrap `(ok (1 2 3))`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUnwrap `(ok (1 2 3))`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(unwrap-ok '(ok (1 2 3)))", "verify_expr": "(equal? (unwrap-ok '(ok (1 2 3))) '(1 2 3))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-ok", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Double an ok result using result-map.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDouble an ok result using result-map.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-map (lambda (x) (* x 2)) '(ok 5))", "verify_expr": "(equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10))", "tags": ["core", "base", "prelude", "extended", "composition", "result-map", "direct"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-simple`\nSpec: Remove duplicates using memq (eq?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-simple`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-simple`\nSpec: Remove duplicates using memq (eq?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-simple`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unique-simple"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (cons* . args)\n  ;; TODO: improper-list constructor with variadic args\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cons*`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (cons* . args)\n  ;; TODO: improper-list constructor with variadic args\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cons*`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "cons*"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "alist-update"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (error? '(error bad detail)))\n(let () (not (error? '(ok 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "error?"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-error result)\n  ;; TODO: extract error payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-error`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-error result)\n  ;; TODO: extract error payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-error`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unwrap-error"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-sequence`\nSpec: Convert list of results to result of list, stopping at first error.\n\nWrite exactly one Scheme function definition for `result-sequence`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-sequence`\nSpec: Convert list of results to result of list, stopping at first error.\n\nWrite exactly one Scheme function definition for `result-sequence`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-sequence"], "split": "eval"}
{"id": "core_prelude_ext_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-simple`.\nReturn only the Scheme definition.\n\n```python\ndef unique_simple(xs):\n    seen=[]\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.append(x)\n            out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-simple`.\nReturn only the Scheme definition.\n\n```python\ndef unique_simple(xs):\n    seen=[]\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.append(x)\n            out.append(x)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (unique-simple '(a b a c b a)) '(a b c)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unique-simple"], "split": "eval"}
{"id": "core_prelude_ext_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alist-update`.\nReturn only the Scheme definition.\n\n```python\ndef alist_update(alist, key, value):\n    return [(key, value)] + [(k,v) for (k,v) in alist if k != key]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alist-update`.\nReturn only the Scheme definition.\n\n```python\ndef alist_update(alist, key, value):\n    return [(key, value)] + [(k,v) for (k,v) in alist if k != key]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "alist-update"], "split": "eval"}
{"id": "core_prelude_ext_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-bind`.\nReturn only the Scheme definition.\n\n```python\ndef result_bind(result, f):\n    if result[0] == 'ok':\n        return f(result[1])\n    return result\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-bind`.\nReturn only the Scheme definition.\n\n```python\ndef result_bind(result, f):\n    if result[0] == 'ok':\n        return f(result[1])\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-bind"], "split": "eval"}
{"id": "core_prelude_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ormap pred lst)\n  ;; TODO: first truthy predicate result, or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ormap`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ormap pred lst)\n  ;; TODO: first truthy predicate result, or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ormap`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "skeleton-completion", "ormap"], "split": "eval"}
{"id": "core_prelude_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-left`\nSpec: Left-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-left`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-left`\nSpec: Left-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-left`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "spec-to-code", "fold-left"], "split": "eval"}
{"id": "core_prelude_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `zip`\nSpec: Pair elements from two lists, stopping at shorter list.\n\nWrite exactly one Scheme function definition for `zip`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `zip`\nSpec: Pair elements from two lists, stopping at shorter list.\n\nWrite exactly one Scheme function definition for `zip`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "spec-to-code", "zip"], "split": "eval"}
{"id": "core_prelude_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (range start end)\n  ;; TODO: generate [start, end)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `range`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (range start end)\n  ;; TODO: generate [start, end)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `range`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "skeleton-completion", "range"], "split": "eval"}
{"id": "core_prelude_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `find`\nSpec: Return first matching element, else #f.\n\nWrite exactly one Scheme function definition for `find`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `find`\nSpec: Return first matching element, else #f.\n\nWrite exactly one Scheme function definition for `find`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (find even? '(1 3 4 6)) 4))\n(let () (not (find even? '(1 3 5))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "spec-to-code", "find"], "split": "eval"}
{"id": "core_prelude_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (init lst)\n  ;; TODO: all except final element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `init`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (init lst)\n  ;; TODO: all except final element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `init`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "skeleton-completion", "init"], "split": "eval"}
{"id": "core_prelude_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `break`\nSpec: Split list at first element that satisfies predicate.\n\nWrite exactly one Scheme function definition for `break`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `break`\nSpec: Split list at first element that satisfies predicate.\n\nWrite exactly one Scheme function definition for `break`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "spec-to-code", "break"], "split": "eval"}
{"id": "core_prelude_spec_to_code_038", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (product lst)\n  ;; TODO: multiply numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `product`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (product lst)\n  ;; TODO: multiply numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `product`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "skeleton-completion", "product"], "split": "eval"}
{"id": "core_prelude_spec_to_code_042", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (identity x)\n  ;; TODO: return x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `identity`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (identity x)\n  ;; TODO: return x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `identity`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (identity 42) 42))\n(let () (equal? (identity '(a b)) '(a b)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "skeleton-completion", "identity"], "split": "eval"}
{"id": "core_prelude_spec_to_code_047", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `partition`\nSpec: Return `(list yes no)` by predicate.\n\nWrite exactly one Scheme function definition for `partition`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `partition`\nSpec: Return `(list yes no)` by predicate.\n\nWrite exactly one Scheme function definition for `partition`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "spec-to-code", "partition"], "split": "eval"}
{"id": "core_prelude_spec_to_code_052", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distinct-by key-fn lst)\n  ;; TODO: remove duplicate keys, keep first\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distinct-by`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distinct-by key-fn lst)\n  ;; TODO: remove duplicate keys, keep first\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distinct-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "skeleton-completion", "distinct-by"], "split": "eval"}
{"id": "core_prelude_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter-map`.\nReturn only the Scheme definition.\n\n```python\ndef filter_map(f, xs):\n    out=[]\n    for x in xs:\n        v=f(x)\n        if v is not None:\n            out.append(v)\n    return out\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter-map`.\nReturn only the Scheme definition.\n\n```python\ndef filter_map(f, xs):\n    out=[]\n    for x in xs:\n        v=f(x)\n        if v is not None:\n            out.append(v)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "filter-map"], "split": "eval"}
{"id": "core_prelude_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `take`.\nReturn only the Scheme definition.\n\n```python\ndef take(n, xs):\n    return xs[:n]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `take`.\nReturn only the Scheme definition.\n\n```python\ndef take(n, xs):\n    return xs[:n]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "python-to-scheme", "take"], "split": "eval"}
{"id": "core_prelude_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `replicate`.\nReturn only the Scheme definition.\n\n```python\ndef replicate(n, x):\n    return [x]*max(n,0)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `replicate`.\nReturn only the Scheme definition.\n\n```python\ndef replicate(n, x):\n    return [x]*max(n,0)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n(let () (equal? (replicate 0 'q) '()))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "python-to-scheme", "replicate"], "split": "eval"}
{"id": "core_prelude_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `identity`.\nReturn only the Scheme definition.\n\n```python\ndef identity(x):\n    return x\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `identity`.\nReturn only the Scheme definition.\n\n```python\ndef identity(x):\n    return x\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (identity 42) 42))\n(let () (equal? (identity '(a b)) '(a b)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "python-to-scheme", "identity"], "split": "eval"}
{"id": "core_prelude_translation_026", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `distinct-by`.\nReturn only the Scheme definition.\n\n```python\ndef distinct_by(key_fn, xs):\n    seen=[]; out=[]\n    for x in xs:\n        k=key_fn(x)\n        if k not in seen:\n            seen.append(k); out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `distinct-by`.\nReturn only the Scheme definition.\n\n```python\ndef distinct_by(key_fn, xs):\n    seen=[]; out=[]\n    for x in xs:\n        k=key_fn(x)\n        if k not in seen:\n            seen.append(k); out.append(x)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "python-to-scheme", "distinct-by"], "split": "eval"}
