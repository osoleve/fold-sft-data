{"id": "set_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-empty?`\nSpec: Return #t iff the set has no elements.\n\nWrite exactly one Scheme function definition for `set-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (set-empty? '()))\n(let () (not (set-empty? '(x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-empty?"], "split": "train"}
{"id": "set_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-empty? set)\n  ;; TODO: return whether set is empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-empty?"], "split": "train"}
{"id": "set_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-member?`\nSpec: Return #t iff elem is present in set.\n\nWrite exactly one Scheme function definition for `set-member?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (set-member? 'b '(a b c)))\n(let () (not (set-member? 'z '(a b c))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-member?"], "split": "train"}
{"id": "set_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-member? elem set)\n  ;; TODO: recursive membership test\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-member?`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (set-member? 'b '(a b c)))\n(let () (not (set-member? 'z '(a b c))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-member?"], "split": "train"}
{"id": "set_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-add elem set)\n  ;; TODO: add only if elem is not already in set\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-add`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-add"], "split": "train"}
{"id": "set_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-remove`\nSpec: Remove elem from set if present; otherwise return the original set.\n\nWrite exactly one Scheme function definition for `set-remove`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-remove"], "split": "train"}
{"id": "set_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-remove elem set)\n  ;; TODO: remove first matching elem and preserve order\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-remove`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n(let () (equal? (set-remove 'z '(a b c)) '(a b c)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-remove"], "split": "train"}
{"id": "set_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-union`\nSpec: Return a set containing elements from both set1 and set2 without duplicates.\n\nWrite exactly one Scheme function definition for `set-union`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-union"], "split": "train"}
{"id": "set_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-union set1 set2)\n  ;; TODO: union without duplicates\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-union`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-union"], "split": "train"}
{"id": "set_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-intersection set1 set2)\n  ;; TODO: keep only elements present in both sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-intersection`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-intersection"], "split": "train"}
{"id": "set_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-difference set1 set2)\n  ;; TODO: keep elements in set1 not in set2\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-difference`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-difference"], "split": "train"}
{"id": "set_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-subset?`\nSpec: Return #t iff every element of set1 appears in set2.\n\nWrite exactly one Scheme function definition for `set-subset?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-subset?"], "split": "train"}
{"id": "set_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-subset? set1 set2)\n  ;; TODO: check that every element of set1 is in set2\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-subset?`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-subset?"], "split": "train"}
{"id": "set_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-size`\nSpec: Return number of elements in set.\n\nWrite exactly one Scheme function definition for `set-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "spec-to-code", "set-size"], "split": "train"}
{"id": "set_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set-size set)\n  ;; TODO: return element count\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set-size`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "skeleton-completion", "set-size"], "split": "train"}
{"id": "set_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (set->list set)\n  ;; TODO: convert set to list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `set->list`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (set->list '(c b a)) '(c b a)))\n(let () (equal? (set->list '()) '()))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "skeleton-completion", "set->list"], "split": "train"}
{"id": "set_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `list->set`\nSpec: Convert list to set by removing duplicates.\n\nWrite exactly one Scheme function definition for `list->set`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "spec-to-code", "list->set"], "split": "train"}
{"id": "set_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (list->set lst)\n  ;; TODO: build set from list values\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->set`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "skeleton-completion", "list->set"], "split": "train"}
{"id": "set_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? s)\n  (null? s))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-empty?"], "split": "train"}
{"id": "set_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-member?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (member0 x s)\n  (cond [(null? s) #f] [(equal? x (car s)) #t] [else (member0 x (cdr s))]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-member?"], "split": "train"}
{"id": "set_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-add`.\nReturn only the Scheme definition.\n\n```python\ndef set_add(elem, s):\n    return s if elem in s else [elem] + s\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-add"], "split": "train"}
{"id": "set_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-add`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (add x s)\n  (if (set-member? x s) s (cons x s)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-add"], "split": "train"}
{"id": "set_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-remove`.\nReturn only the Scheme definition.\n\n```python\ndef set_remove(elem, s):\n    out = []\n    removed = False\n    for x in s:\n        if not removed and x == elem:\n            removed = True\n        else:\n            out.append(x)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n(let () (equal? (set-remove 'z '(a b c)) '(a b c)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-remove"], "split": "train"}
{"id": "set_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-union`.\nReturn only the Scheme definition.\n\n```python\ndef set_union(s1, s2):\n    out = list(s2)\n    for x in s1:\n        if x not in out:\n            out.insert(0, x)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-union"], "split": "train"}
{"id": "set_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-union`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (union0 s1 s2)\n  (fold-left (lambda (acc x) (set-add x acc)) s2 s1))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-union"], "split": "train"}
{"id": "set_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-intersection`.\nReturn only the Scheme definition.\n\n```python\ndef set_intersection(s1, s2):\n    return [x for x in s1 if x in s2]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-intersection"], "split": "train"}
{"id": "set_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-intersection`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (intersect0 s1 s2)\n  (filter (lambda (x) (set-member? x s2)) s1))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-intersection"], "split": "train"}
{"id": "set_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-difference`.\nReturn only the Scheme definition.\n\n```python\ndef set_difference(s1, s2):\n    return [x for x in s1 if x not in s2]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-difference"], "split": "train"}
{"id": "set_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-difference`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (diff0 s1 s2)\n  (filter (lambda (x) (not (set-member? x s2))) s1))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-difference"], "split": "train"}
{"id": "set_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-subset?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (subset0 s1 s2)\n  (fold-left (lambda (ok x) (and ok (set-member? x s2))) #t s1))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-subset?"], "split": "train"}
{"id": "set_translation_017", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-size`.\nReturn only the Scheme definition.\n\n```python\ndef set_size(s):\n    return len(s)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-size"], "split": "train"}
{"id": "set_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size0 s)\n  (length s))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-size"], "split": "train"}
{"id": "set_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set->list`.\nReturn only the Scheme definition.\n\n```python\ndef set_to_list(s):\n    return s\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (set->list '(c b a)) '(c b a)))\n(let () (equal? (set->list '()) '()))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "python-to-scheme", "set->list"], "split": "train"}
{"id": "set_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list s)\n  s)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "chez-to-fold", "set->list"], "split": "train"}
{"id": "set_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `list->set`.\nReturn only the Scheme definition.\n\n```python\ndef list_to_set(xs):\n    out = []\n    for x in xs:\n        if x not in out:\n            out.insert(0, x)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "python-to-scheme", "list->set"], "split": "train"}
{"id": "set_translation_022", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `list->set`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-list xs)\n  (fold-left (lambda (acc x) (set-add x acc)) '() xs))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "chez-to-fold", "list->set"], "split": "train"}
{"id": "set_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-empty?` in `lattice/data/set.ss`.\nKnown issue: Empty set must return #t.\n\n```scheme\n(define (set-empty? set)\n  #f)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (set-empty? '()))\n(let () (not (set-empty? '(x))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "bugfix", "set-empty?"], "split": "train"}
{"id": "set_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-member?` in `lattice/data/set.ss`.\nKnown issue: Membership must search entire set, not just the head.\n\n```scheme\n(define (set-member? elem set)\n  (and (not (null? set)) (equal? elem (car set))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "bugfix", "set-member?"], "split": "train"}
{"id": "set_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-member?` in `lattice/data/set.ss`.\nKnown issue: Absent elements must return #f.\n\n```scheme\n(define (set-member? elem set)\n  #t)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Absent elements must return #f.\n\nExpected behavior after patch:\n```scheme\n(let () (set-member? 'b '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (set-member? 'b '(a b c)))\n(let () (not (set-member? 'z '(a b c))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "bugfix", "set-member?"], "split": "train"}
{"id": "set_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-add` in `lattice/data/set.ss`.\nKnown issue: Adding an existing element must not create duplicates.\n\n```scheme\n(define (set-add elem set)\n  (cons elem set))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Adding an existing element must not create duplicates.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "bugfix", "set-add"], "split": "train"}
{"id": "set_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-add` in `lattice/data/set.ss`.\nKnown issue: Missing element should actually be added.\n\n```scheme\n(define (set-add elem set)\n  set)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Missing element should actually be added.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "bugfix", "set-add"], "split": "train"}
{"id": "set_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-remove` in `lattice/data/set.ss`.\nKnown issue: Existing element should be removed.\n\n```scheme\n(define (set-remove elem set)\n  set)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Existing element should be removed.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n(let () (equal? (set-remove 'z '(a b c)) '(a b c)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "bugfix", "set-remove"], "split": "train"}
{"id": "set_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-union` in `lattice/data/set.ss`.\nKnown issue: Union must avoid duplicates.\n\n```scheme\n(define (set-union set1 set2)\n  (append set1 set2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "bugfix", "set-union"], "split": "train"}
{"id": "set_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-union` in `lattice/data/set.ss`.\nKnown issue: Union should include elements unique to set2.\n\n```scheme\n(define (set-union set1 set2)\n  set1)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Union should include elements unique to set2.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (set-union set1 set2)\n  (let loop ([remaining set1]\n             [result set2])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (set-add (car remaining) result)))))\n  (let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u))))", "tags": ["tier0", "data", "set", "bugfix", "set-union"], "split": "train"}
{"id": "set_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-intersection` in `lattice/data/set.ss`.\nKnown issue: Intersection must keep only common elements.\n\n```scheme\n(define (set-intersection set1 set2)\n  set1)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-intersection"], "split": "train"}
{"id": "set_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-intersection` in `lattice/data/set.ss`.\nKnown issue: Union is not intersection.\n\n```scheme\n(define (set-intersection set1 set2)\n  (set-union set1 set2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Union is not intersection.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-intersection"], "split": "train"}
{"id": "set_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-difference` in `lattice/data/set.ss`.\nKnown issue: Difference should come from set1.\n\n```scheme\n(define (set-difference set1 set2)\n  set2)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-difference"], "split": "train"}
{"id": "set_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-difference` in `lattice/data/set.ss`.\nKnown issue: This computes intersection, not difference.\n\n```scheme\n(define (set-difference set1 set2)\n  (filter (lambda (x) (set-member? x set2)) set1))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-difference"], "split": "train"}
{"id": "set_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-subset?` in `lattice/data/set.ss`.\nKnown issue: Non-subsets must return #f.\n\n```scheme\n(define (set-subset? set1 set2)\n  #t)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (set-subset? '(1 2) '(3 2 1)))\n(let () (not (set-subset? '(1 4) '(1 2 3))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "bugfix", "set-subset?"], "split": "train"}
{"id": "set_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-size` in `lattice/data/set.ss`.\nKnown issue: Empty set size must be 0.\n\n```scheme\n(define (set-size set)\n  (if (null? set) 1 (length set)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-size"], "split": "train"}
{"id": "set_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-size` in `lattice/data/set.ss`.\nKnown issue: Size should match length exactly.\n\n```scheme\n(define (set-size set)\n  (- (length set) 1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (set-size '()) 0))\n(let () (= (set-size '(a b c)) 3))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-size set)\n  (length set))", "verify_expr": "(let ()\n  (define (set-size set)\n  (length set))\n  (and (= (set-size '()) 0) (= (set-size '(a b c)) 3)))", "tags": ["tier0", "data", "set", "bugfix", "set-size"], "split": "train"}
{"id": "set_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set->list` in `lattice/data/set.ss`.\nKnown issue: Set->list is identity in this representation.\n\n```scheme\n(define (set->list set)\n  (reverse set))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set->list '(c b a)) '(c b a)))\n(let () (equal? (set->list '()) '()))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "bugfix", "set->list"], "split": "train"}
{"id": "set_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set->list` in `lattice/data/set.ss`.\nKnown issue: Conversion must preserve elements.\n\n```scheme\n(define (set->list set)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set->list '(c b a)) '(c b a)))\n(let () (equal? (set->list '()) '()))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "bugfix", "set->list"], "split": "train"}
{"id": "set_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->set` in `lattice/data/set.ss`.\nKnown issue: Duplicates should be removed.\n\n```scheme\n(define (list->set lst)\n  lst)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Duplicates should be removed.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "bugfix", "list->set"], "split": "train"}
{"id": "set_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether set `'(a)` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-empty? '(a))", "verify_expr": "(equal? (set-empty? '(a)) #f)", "tags": ["tier0", "data", "set", "composition", "set-empty?", "direct"], "split": "train"}
{"id": "set_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck membership of `'b` in set `'(a b c)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-member? 'b '(a b c))", "verify_expr": "(equal? (set-member? 'b '(a b c)) #t)", "tags": ["tier0", "data", "set", "composition", "set-member?", "direct"], "split": "train"}
{"id": "set_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck membership of `'z` in set `'(a b c)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-member? 'z '(a b c))", "verify_expr": "(equal? (set-member? 'z '(a b c)) #f)", "tags": ["tier0", "data", "set", "composition", "set-member?", "direct"], "split": "train"}
{"id": "set_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: small integration task across module primitives.\n\nAdd `'x` to set `'(a b)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-add 'x '(a b))", "verify_expr": "(equal? (set-add 'x '(a b)) '(x a b))", "tags": ["tier0", "data", "set", "composition", "set-add", "direct"], "split": "train"}
{"id": "set_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: small integration task across module primitives.\n\nRemove `'b` from set `'(a b c)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-remove 'b '(a b c))", "verify_expr": "(equal? (set-remove 'b '(a b c)) '(a c))", "tags": ["tier0", "data", "set", "composition", "set-remove", "direct"], "split": "train"}
{"id": "set_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn intersection of `'(1 2 3)` and `'(2 3 4)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-intersection '(1 2 3) '(2 3 4))", "verify_expr": "(equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3))", "tags": ["tier0", "data", "set", "composition", "set-intersection", "direct"], "split": "train"}
{"id": "set_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: small integration task across module primitives.\n\nReturn difference `set1 - set2` for `'(1 2 3 4)` and `'(2 4)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(set-difference '(1 2 3 4) '(2 4))", "verify_expr": "(equal? (set-difference '(1 2 3 4) '(2 4)) '(1 3))", "tags": ["tier0", "data", "set", "composition", "set-difference", "direct"], "split": "train"}
{"id": "set_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether `'(1 2)` is subset of `'(3 2 1)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-subset? '(1 2) '(3 2 1))", "verify_expr": "(equal? (set-subset? '(1 2) '(3 2 1)) #t)", "tags": ["tier0", "data", "set", "composition", "set-subset?", "direct"], "split": "train"}
{"id": "set_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff adding an existing element does not change set size.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (set-size (set-add 'b '(a b c))) (set-size '(a b c)))", "verify_expr": "(equal? (= (set-size (set-add 'b '(a b c))) (set-size '(a b c))) #t)", "tags": ["tier0", "data", "set", "composition", "set-add", "property"], "split": "train"}
{"id": "set_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff removing an absent element leaves the set unchanged.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (set-remove 'z '(a b c)) '(a b c))", "verify_expr": "(equal? (equal? (set-remove 'z '(a b c)) '(a b c)) #t)", "tags": ["tier0", "data", "set", "composition", "set-remove", "property"], "split": "train"}
{"id": "set_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that empty set is subset of `'(a b c)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-subset? '() '(a b c))", "verify_expr": "(equal? (set-subset? '() '(a b c)) #t)", "tags": ["tier0", "data", "set", "composition", "set-subset?", "property"], "split": "train"}
{"id": "set_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff union is equivalent regardless of argument order for `'(1 2)` and `'(2 3)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([u1 (set-union '(1 2) '(2 3))] [u2 (set-union '(2 3) '(1 2))]) (and (set-subset? u1 u2) (set-subset? u2 u1)))", "verify_expr": "(equal? (let ([u1 (set-union '(1 2) '(2 3))] [u2 (set-union '(2 3) '(1 2))]) (and (set-subset? u1 u2) (set-subset? u2 u1))) #t)", "tags": ["tier0", "data", "set", "composition", "set-union", "property"], "split": "train"}
{"id": "set_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff intersection is subset of the left set.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([i (set-intersection '(1 2 3) '(2 3 4))]) (set-subset? i '(1 2 3)))", "verify_expr": "(equal? (let ([i (set-intersection '(1 2 3) '(2 3 4))]) (set-subset? i '(1 2 3))) #t)", "tags": ["tier0", "data", "set", "composition", "set-intersection", "property"], "split": "train"}
{"id": "set_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff removed elements are absent after difference.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (set-difference '(1 2 3 4) '(2 4))]) (and (not (set-member? 2 d)) (not (set-member? 4 d))))", "verify_expr": "(equal? (let ([d (set-difference '(1 2 3 4) '(2 4))]) (and (not (set-member? 2 d)) (not (set-member? 4 d)))) #t)", "tags": ["tier0", "data", "set", "composition", "set-difference", "property"], "split": "train"}
{"id": "set_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a set from `'(1 2 3 2 1 4)` using `fold-left` and `set-add`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(fold-left (lambda (s x) (set-add x s)) set-empty '(1 2 3 2 1 4))", "verify_expr": "(let ([s (fold-left (lambda (s x) (set-add x s)) set-empty '(1 2 3 2 1 4))]) (and (= (set-size s) 4) (set-member? 1 s) (set-member? 2 s) (set-member? 3 s) (set-member? 4 s)))", "tags": ["tier0", "data", "set", "composition", "set-add", "fold"], "split": "train"}
{"id": "set_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt": "Task mode: small integration task across module primitives.\n\nMap membership of `'a` across sets `'((a b) (b c) (a c) ())`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (s) (set-member? 'a s)) '((a b) (b c) (a c) ()))", "verify_expr": "(equal? (map (lambda (s) (set-member? 'a s)) '((a b) (b c) (a c) ())) '(#t #f #t #f))", "tags": ["tier0", "data", "set", "composition", "set-member?", "list"], "split": "train"}
{"id": "set_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt": "Task mode: compose existing APIs into one expression.\n\nFold union over set list `'((1 2) (2 3) (3 4))`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(fold-left (lambda (acc s) (set-union acc s)) set-empty '((1 2) (2 3) (3 4)))", "verify_expr": "(let ([u (fold-left (lambda (acc s) (set-union acc s)) set-empty '((1 2) (2 3) (3 4)))]) (and (= (set-size u) 4) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u) (set-member? 4 u)))", "tags": ["tier0", "data", "set", "composition", "set-union", "fold"], "split": "train"}
{"id": "set_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse a loop to intersect `'(1 2 3 4)` with each set in `'((2 3 5) (3 4) (3 6))`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([cur '(1 2 3 4)] [sets '((2 3 5) (3 4) (3 6))]) (if (null? sets) cur (loop (set-intersection cur (car sets)) (cdr sets))))", "verify_expr": "(equal? (let loop ([cur '(1 2 3 4)] [sets '((2 3 5) (3 4) (3 6))]) (if (null? sets) cur (loop (set-intersection cur (car sets)) (cdr sets)))) '(3))", "tags": ["tier0", "data", "set", "composition", "set-intersection", "loop"], "split": "train"}
{"id": "set_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt": "Task mode: small integration task across module primitives.\n\nCount how many elements in `'(a b c d)` are missing from set `'(a c)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([xs '(a b c d)] [n 0]) (if (null? xs) n (loop (cdr xs) (if (set-member? (car xs) '(a c)) n (+ n 1)))))", "verify_expr": "(equal? (let loop ([xs '(a b c d)] [n 0]) (if (null? xs) n (loop (cdr xs) (if (set-member? (car xs) '(a c)) n (+ n 1))))) 2)", "tags": ["tier0", "data", "set", "composition", "set-size", "loop"], "split": "train"}
{"id": "set_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute symmetric difference of `'(1 2 3)` and `'(3 4)` as union of two differences.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-union (set-difference '(1 2 3) '(3 4)) (set-difference '(3 4) '(1 2 3)))", "verify_expr": "(let ([s (set-union (set-difference '(1 2 3) '(3 4)) (set-difference '(3 4) '(1 2 3)))]) (and (= (set-size s) 3) (set-member? 1 s) (set-member? 2 s) (set-member? 4 s)))", "tags": ["tier0", "data", "set", "composition", "set-difference", "integration"], "split": "train"}
{"id": "set_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt": "Task mode: small integration task across module primitives.\n\nReturn overlap size between `'(a b c d)` and `'(c d e)`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-size (set-intersection '(a b c d) '(c d e)))", "verify_expr": "(equal? (set-size (set-intersection '(a b c d) '(c d e))) 2)", "tags": ["tier0", "data", "set", "composition", "set-intersection", "integration"], "split": "train"}
{"id": "set_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt": "Task mode: compose existing APIs into one expression.\n\nFrom `users='(u1 u2 u3 u4)` remove banned `'(u2 u4)` and return remaining users.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-difference '(u1 u2 u3 u4) '(u2 u4))", "verify_expr": "(equal? (set-difference '(u1 u2 u3 u4) '(u2 u4)) '(u1 u3))", "tags": ["tier0", "data", "set", "composition", "set-difference", "integration"], "split": "train"}
{"id": "set_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff deduplicating `'(a a b c c c)` yields set size 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (set-size (list->set '(a a b c c c))) 3)", "verify_expr": "(equal? (= (set-size (list->set '(a a b c c c))) 3) #t)", "tags": ["tier0", "data", "set", "composition", "list->set", "integration"], "split": "train"}
{"id": "set_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck if intersection is subset of each original set for `A='(1 2 3)` and `B='(2 3 4)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([i (set-intersection '(1 2 3) '(2 3 4))]) (and (set-subset? i '(1 2 3)) (set-subset? i '(2 3 4))))", "verify_expr": "(equal? (let ([i (set-intersection '(1 2 3) '(2 3 4))]) (and (set-subset? i '(1 2 3)) (set-subset? i '(2 3 4)))) #t)", "tags": ["tier0", "data", "set", "composition", "set-subset?", "integration"], "split": "train"}
