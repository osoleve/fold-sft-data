{"id": "set_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-add", "prompt_body": "You are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-add`\nSpec: Add elem to set if absent; keep set unchanged if elem already exists.\n\nWrite exactly one Scheme function definition for `set-add`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-add`\nSpec: Add elem to set if absent; keep set unchanged if elem already exists.\n\nWrite exactly one Scheme function definition for `set-add`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-size set)\n  (length set))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (let ([s1 (set-add 'a '(b c))] [s2 (set-add 'b '(b c))]) (and (set-member? 'a s1) (= (set-size s1) 3) (equal? s2 '(b c)))))", "tags": ["tier0", "data", "set", "spec-to-code", "set-add"], "split": "eval"}
{"id": "set_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-intersection", "prompt_body": "You are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-intersection`\nSpec: Return elements common to both sets.\n\nWrite exactly one Scheme function definition for `set-intersection`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-intersection`\nSpec: Return elements common to both sets.\n\nWrite exactly one Scheme function definition for `set-intersection`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-intersection set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (set-intersection '(1 2 3) '(2 3 4)) '(2 3)))", "tags": ["tier0", "data", "set", "spec-to-code", "set-intersection"], "split": "eval"}
{"id": "set_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-difference", "prompt_body": "You are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-difference`\nSpec: Return elements in set1 that are not in set2.\n\nWrite exactly one Scheme function definition for `set-difference`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set-difference`\nSpec: Return elements in set1 that are not in set2.\n\nWrite exactly one Scheme function definition for `set-difference`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-difference set1 set2)\n  (let loop ([remaining set1]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining) acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (equal? (set-difference '(1 2 3 4) '(2 4 6)) '(1 3)))", "tags": ["tier0", "data", "set", "spec-to-code", "set-difference"], "split": "eval"}
{"id": "set_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set->list", "prompt_body": "You are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set->list`\nSpec: Convert set representation to list (arbitrary order).\n\nWrite exactly one Scheme function definition for `set->list`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/set.ss\nFunction: `set->list`\nSpec: Convert set representation to list (arbitrary order).\n\nWrite exactly one Scheme function definition for `set->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (set->list set)\n  set)", "verify_expr": "(let ()\n  (define (set->list set)\n  set)\n  (and (equal? (set->list '(c b a)) '(c b a)) (equal? (set->list '()) '())))", "tags": ["tier0", "data", "set", "spec-to-code", "set->list"], "split": "eval"}
{"id": "set_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef set_empty(s):\n    return len(s) == 0\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef set_empty(s):\n    return len(s) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-empty?"], "split": "eval"}
{"id": "set_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-member?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-member?`.\nReturn only the Scheme definition.\n\n```python\ndef set_member(elem, s):\n    return elem in s\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-member?`.\nReturn only the Scheme definition.\n\n```python\ndef set_member(elem, s):\n    return elem in s\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (and (set-member? 'b '(a b c)) (not (set-member? 'z '(a b c)))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-member?"], "split": "eval"}
{"id": "set_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-remove`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (remove1 x s)\n  (cond [(null? s) '()] [(equal? x (car s)) (cdr s)] [else (cons (car s) (remove1 x (cdr s)))]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `set-remove`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (remove1 x s)\n  (cond [(null? s) '()] [(equal? x (car s)) (cdr s)] [else (cons (car s) (remove1 x (cdr s)))]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n(let () (equal? (set-remove 'z '(a b c)) '(a b c)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "chez-to-fold", "set-remove"], "split": "eval"}
{"id": "set_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-subset?`.\nReturn only the Scheme definition.\n\n```python\ndef set_subset(s1, s2):\n    return all(x in s2 for x in s1)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `set-subset?`.\nReturn only the Scheme definition.\n\n```python\ndef set_subset(s1, s2):\n    return all(x in s2 for x in s1)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (set-subset? '(1 2) '(3 2 1)))\n(let () (not (set-subset? '(1 4) '(1 2 3))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "python-to-scheme", "set-subset?"], "split": "eval"}
{"id": "set_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-empty?` in `lattice/data/set.ss`.\nKnown issue: A one-element set should not be empty.\n\n```scheme\n(define (set-empty? set)\n  (null? (cdr set)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-empty?` in `lattice/data/set.ss`.\nKnown issue: A one-element set should not be empty.\n\n```scheme\n(define (set-empty? set)\n  (null? (cdr set)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (set-empty? '()))\n(let () (not (set-empty? '(x))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-empty? set)\n  (null? set))", "verify_expr": "(let ()\n  (define (set-empty? set)\n  (null? set))\n  (and (set-empty? '()) (not (set-empty? '(x)))))", "tags": ["tier0", "data", "set", "bugfix", "set-empty?"], "split": "eval"}
{"id": "set_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-remove", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-remove` in `lattice/data/set.ss`.\nKnown issue: Removal should match by value, not always drop head.\n\n```scheme\n(define (set-remove elem set)\n  (if (null? set) '() (cdr set)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-remove` in `lattice/data/set.ss`.\nKnown issue: Removal should match by value, not always drop head.\n\n```scheme\n(define (set-remove elem set)\n  (if (null? set) '() (cdr set)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Removal should match by value, not always drop head.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (set-remove 'b '(a b c)) '(a c)))\n(let () (equal? (set-remove 'z '(a b c)) '(a b c)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (set-remove elem set)\n  (let loop ([remaining set]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? elem (car remaining))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and (equal? (set-remove 'b '(a b c)) '(a c)) (equal? (set-remove 'z '(a b c)) '(a b c))))", "tags": ["tier0", "data", "set", "bugfix", "set-remove"], "split": "eval"}
{"id": "set_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-subset?` in `lattice/data/set.ss`.\nKnown issue: Subset direction is reversed.\n\n```scheme\n(define (set-subset? set1 set2)\n  (let loop ([remaining set2])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set1)\n       (loop (cdr remaining))]\n      [else #f])))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `set-subset?` in `lattice/data/set.ss`.\nKnown issue: Subset direction is reversed.\n\n```scheme\n(define (set-subset? set1 set2)\n  (let loop ([remaining set2])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set1)\n       (loop (cdr remaining))]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Subset direction is reversed.\n\nExpected behavior after patch:\n```scheme\n(let () (set-subset? '(1 2) '(3 2 1)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (set-subset? '(1 2) '(3 2 1)))\n(let () (not (set-subset? '(1 4) '(1 2 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-subset? set1 set2)\n  (let loop ([remaining set1])\n    (cond\n      [(null? remaining) #t]\n      [(set-member? (car remaining) set2)\n       (loop (cdr remaining))]\n      [else #f])))\n  (and (set-subset? '(1 2) '(3 2 1)) (not (set-subset? '(1 4) '(1 2 3)))))", "tags": ["tier0", "data", "set", "bugfix", "set-subset?"], "split": "eval"}
{"id": "set_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->set` in `lattice/data/set.ss`.\nKnown issue: Reversing alone does not enforce set semantics.\n\n```scheme\n(define (list->set lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->set` in `lattice/data/set.ss`.\nKnown issue: Reversing alone does not enforce set semantics.\n\n```scheme\n(define (list->set lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Reversing alone does not enforce set semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))", "verify_expr": "(let ()\n  (define (set-member? elem set)\n  (cond\n    [(null? set) #f]\n    [(equal? elem (car set)) #t]\n    [else (set-member? elem (cdr set))]))\n  (define (set-add elem set)\n  (if (set-member? elem set)\n      set\n      (cons elem set)))\n  (define (set-size set)\n  (length set))\n  (define (list->set lst)\n  (let loop ([remaining lst]\n             [acc '()])\n    (if (null? remaining)\n        acc\n        (loop (cdr remaining) (set-add (car remaining) acc)))))\n  (let ([s (list->set '(a b a c b))]) (and (= (set-size s) 3) (set-member? 'a s) (set-member? 'b s) (set-member? 'c s))))", "tags": ["tier0", "data", "set", "bugfix", "list->set"], "split": "eval"}
{"id": "set_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-empty?", "prompt_body": "Return whether `set-empty` is empty.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `set-empty` is empty.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-empty? set-empty)", "verify_expr": "(equal? (set-empty? set-empty) #t)", "tags": ["tier0", "data", "set", "composition", "set-empty?", "direct"], "split": "eval"}
{"id": "set_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt_body": "Return union of sets `'(1 2)` and `'(2 3)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn union of sets `'(1 2)` and `'(2 3)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(set-union '(1 2) '(2 3))", "verify_expr": "(let ([u (set-union '(1 2) '(2 3))]) (and (= (set-size u) 3) (set-member? 1 u) (set-member? 2 u) (set-member? 3 u)))", "tags": ["tier0", "data", "set", "composition", "set-union", "direct"], "split": "eval"}
{"id": "set_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-subset?", "prompt_body": "Check subset reflexivity for `'(x y z)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck subset reflexivity for `'(x y z)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(set-subset? '(x y z) '(x y z))", "verify_expr": "(equal? (set-subset? '(x y z) '(x y z)) #t)", "tags": ["tier0", "data", "set", "composition", "set-subset?", "property"], "split": "eval"}
{"id": "set_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->set", "prompt_body": "Return #t iff list->set followed by set->list then list->set preserves set size.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff list->set followed by set->list then list->set preserves set size.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([s (list->set '(a b a c b))]) (= (set-size s) (set-size (list->set (set->list s)))))", "verify_expr": "(equal? (let ([s (list->set '(a b a c b))]) (= (set-size s) (set-size (list->set (set->list s))))) #t)", "tags": ["tier0", "data", "set", "composition", "list->set", "property"], "split": "eval"}
{"id": "set_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-size", "prompt_body": "Map set sizes over `'((a) (a b) (a b c) ())`.", "prompt": "Task mode: small integration task across module primitives.\n\nMap set sizes over `'((a) (a b) (a b c) ())`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map set-size '((a) (a b) (a b c) ()))", "verify_expr": "(equal? (map set-size '((a) (a b) (a b c) ())) '(1 2 3 0))", "tags": ["tier0", "data", "set", "composition", "set-size", "list"], "split": "eval"}
{"id": "set_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/set.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "set-union", "prompt_body": "Build union of three sets and test that element `5` appears.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild union of three sets and test that element `5` appears.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([u (set-union (set-union '(1 2) '(2 3)) '(3 4 5))]) (set-member? 5 u))", "verify_expr": "(equal? (let ([u (set-union (set-union '(1 2) '(2 3)) '(3 4 5))]) (set-member? 5 u)) #t)", "tags": ["tier0", "data", "set", "composition", "set-union", "integration"], "split": "eval"}
