{"id": "numeric_instances_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-signum`\nSpec: Map each element to -1, 0, or 1 depending on sign.\n\nWrite exactly one Scheme function definition for `vec-signum`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-signum"], "split": "eval"}
{"id": "numeric_instances_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-pow`\nSpec: Elementwise exponentiation; require equal vector lengths or return dimension mismatch error.\n\nWrite exactly one Scheme function definition for `vec-pow`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4))\n(equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-pow"], "split": "eval"}
{"id": "numeric_instances_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `matrix-recip`\nSpec: Elementwise reciprocal of matrix entries.\n\nWrite exactly one Scheme function definition for `matrix-recip`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10)))\n(equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "matrix-recip"], "split": "eval"}
{"id": "numeric_instances_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `vec-abs`\n\n```python\ndef vec_abs(v):\n    return [abs(x) for x in v]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (vec-abs (vec -1 2 -3)) '#(1 2 3))\n(equal? (vec-abs (vec)) '#())\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "translation", "python", "vec-abs"], "split": "eval"}
{"id": "numeric_instances_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `matrix-hadamard`\n\n```python\ndef matrix_hadamard(m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if r1 != r2 or c1 != c2:\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c1)\n    for i in range(r1 * c1):\n        out[i] = d1[i] * d2[i]\n    return ['matrix', r1, c1, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20)))\n(equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "translation", "python", "matrix-hadamard"], "split": "eval"}
{"id": "numeric_instances_translation_016", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `scalar-matrix+`\n\n```scheme\n(define (s+m k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "scalar-matrix+"], "split": "eval"}
{"id": "numeric_instances_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-abs` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Absolute value is not simple negation for positive entries.\n\n```scheme\n(define (vec-abs v)\n  (vec-map (lambda (x) (- x)) v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-abs"], "split": "eval"}
{"id": "numeric_instances_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-hadamard` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Hadamard product is elementwise multiplication, not addition.\n\n```scheme\n(define (matrix-hadamard m1 m2)\n  (matrix-add m1 m2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix-hadamard"], "split": "eval"}
{"id": "numeric_instances_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `scalar-matrix+` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Mapped expression must use scalar k, not duplicate x.\n\n```scheme\n(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ x x)) m))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14)))\n(equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "scalar-matrix+"], "split": "eval"}
{"id": "numeric_instances_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply vec-abs to #( -1 2 -3 ).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-abs (vec -1 2 -3)) '#(1 2 3))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-abs (vec -1 2 -3))", "verify_expr": "(equal? (vec-abs (vec -1 2 -3)) '#(1 2 3))", "tags": ["linalg", "numeric-instances", "composition", "vec-abs", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: small integration task across module primitives.\n\nApply vec-recip to #(2 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-recip (vec 2 4 5))", "verify_expr": "(equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5))", "tags": ["linalg", "numeric-instances", "composition", "vec-recip", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nHadamard multiply two 2x2 matrices.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5)))))", "verify_expr": "(equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-hadamard", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff dividing matrix by itself yields all ones.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix/ (matrix-from-lists '((2 4) (5 10))) (matrix-from-lists '((2 4) (5 10))))) '((1 1) (1 1)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (matrix->lists (matrix/ (matrix-from-lists '((2 4) (5 10))) (matrix-from-lists '((2 4) (5 10))))) '((1 1) (1 1)))", "verify_expr": "(equal? (matrix->lists (matrix/ (matrix-from-lists '((2 4) (5 10))) (matrix-from-lists '((2 4) (5 10))))) '((1 1) (1 1)))", "tags": ["linalg", "numeric-instances", "composition", "matrix/", "property"], "split": "eval"}
{"id": "numeric_instances_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff adding 0 leaves matrix unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (scalar-matrix+ 0 (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (matrix->lists (scalar-matrix+ 0 (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))", "verify_expr": "(equal? (matrix->lists (scalar-matrix+ 0 (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))", "tags": ["linalg", "numeric-instances", "composition", "scalar-matrix+", "property"], "split": "eval"}
