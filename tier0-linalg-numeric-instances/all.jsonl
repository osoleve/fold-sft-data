{"id": "numeric_instances_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-abs`\nSpec: Apply absolute value elementwise to a numeric vector.\n\nWrite exactly one Scheme function definition for `vec-abs`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-abs"], "split": "train"}
{"id": "numeric_instances_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `vec-abs`\nBehavior contract: Apply absolute value elementwise to a numeric vector.\n\n```scheme\n(define (vec-abs v)\n  ;; TODO: elementwise absolute value\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "vec-abs"], "split": "train"}
{"id": "numeric_instances_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `vec-signum`\nBehavior contract: Map each element to -1, 0, or 1 depending on sign.\n\n```scheme\n(define (vec-signum v)\n  ;; TODO: map negatives to -1, positives to 1, zeros to 0\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "vec-signum"], "split": "train"}
{"id": "numeric_instances_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-recip`\nSpec: Map each element x to reciprocal 1/x.\n\nWrite exactly one Scheme function definition for `vec-recip`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-recip"], "split": "train"}
{"id": "numeric_instances_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `vec-recip`\nBehavior contract: Map each element x to reciprocal 1/x.\n\n```scheme\n(define (vec-recip v)\n  ;; TODO: elementwise reciprocal\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n(let () (equal? (vec-recip (vec -2)) '#(-1/2)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "vec-recip"], "split": "train"}
{"id": "numeric_instances_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `vec-pow`\nBehavior contract: Elementwise exponentiation; require equal vector lengths or return dimension mismatch error.\n\n```scheme\n(define (vec-pow v1 v2)\n  ;; TODO: elementwise exponentiation with vec-zip-with\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n(let () (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "vec-pow"], "split": "train"}
{"id": "numeric_instances_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `matrix-hadamard`\nSpec: Elementwise matrix multiplication; shapes must match.\n\nWrite exactly one Scheme function definition for `matrix-hadamard`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n(let () (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "matrix-hadamard"], "split": "train"}
{"id": "numeric_instances_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `matrix-hadamard`\nBehavior contract: Elementwise matrix multiplication; shapes must match.\n\n```scheme\n(define (matrix-hadamard m1 m2)\n  ;; TODO: dimension check + elementwise matrix multiply\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n(let () (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "matrix-hadamard"], "split": "train"}
{"id": "numeric_instances_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `matrix/`\nSpec: Elementwise matrix division; shapes must match.\n\nWrite exactly one Scheme function definition for `matrix/`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))))\n(let () (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "matrix/"], "split": "train"}
{"id": "numeric_instances_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `matrix/`\nBehavior contract: Elementwise matrix division; shapes must match.\n\n```scheme\n(define (matrix/ m1 m2)\n  ;; TODO: dimension check + elementwise matrix division\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "matrix/"], "split": "train"}
{"id": "numeric_instances_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `matrix-recip`\nBehavior contract: Elementwise reciprocal of matrix entries.\n\n```scheme\n(define (matrix-recip m)\n  ;; TODO: map each element x to 1/x\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "matrix-recip"], "split": "train"}
{"id": "numeric_instances_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `scalar-matrix+`\nSpec: Add scalar to every matrix element.\n\nWrite exactly one Scheme function definition for `scalar-matrix+`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))))\n(let () (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "scalar-matrix+"], "split": "train"}
{"id": "numeric_instances_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/numeric-instances.ss\nFunction target: `scalar-matrix+`\nBehavior contract: Add scalar to every matrix element.\n\n```scheme\n(define (scalar-matrix+ k m)\n  ;; TODO: add scalar k to each matrix element\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))))\n(let () (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "skeleton", "scalar-matrix+"], "split": "train"}
{"id": "numeric_instances_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-abs`\n\n```scheme\n(define (vabs v)\n  (vec-map abs v))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)))\n(let () (equal? (vec-abs (vec)) '#()))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "translation", "chez", "vec-abs"], "split": "train"}
{"id": "numeric_instances_translation_003", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `vec-signum`\n\n```python\ndef vec_signum(v):\n    out = [0] * len(v)\n    for i, x in enumerate(v):\n        if x < 0:\n            out[i] = -1\n        elif x > 0:\n            out[i] = 1\n        else:\n            out[i] = 0\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)))\n(let () (equal? (vec-signum (vec 0 0)) '#(0 0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "translation", "python", "vec-signum"], "split": "train"}
{"id": "numeric_instances_translation_004", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-signum`\n\n```scheme\n(define (vsign v)\n  (vec-map (lambda (x)\n             (cond ((< x 0) -1)\n                   ((> x 0) 1)\n                   (else 0)))\n           v))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)))\n(let () (equal? (vec-signum (vec 0 0)) '#(0 0)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "vec-signum"], "split": "train"}
{"id": "numeric_instances_translation_005", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `vec-recip`\n\n```python\ndef vec_recip(v):\n    return [1 / x for x in v]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n(let () (equal? (vec-recip (vec -2)) '#(-1/2)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "translation", "python", "vec-recip"], "split": "train"}
{"id": "numeric_instances_translation_006", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-recip`\n\n```scheme\n(define (vrecip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n(let () (equal? (vec-recip (vec -2)) '#(-1/2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "vec-recip"], "split": "train"}
{"id": "numeric_instances_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `vec-pow`\n\n```python\ndef vec_pow(v1, v2):\n    if len(v1) != len(v2):\n        return ['error', 'dimension-mismatch', len(v1), len(v2)]\n    out = [0] * len(v1)\n    for i in range(len(v1)):\n        out[i] = v1[i] ** v2[i]\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "translation", "python", "vec-pow"], "split": "train"}
{"id": "numeric_instances_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-pow`\n\n```scheme\n(define (vpow a b)\n  (vec-zip-with expt a b))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n(let () (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "vec-pow"], "split": "train"}
{"id": "numeric_instances_translation_010", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-hadamard`\n\n```scheme\n(define (mhadamard a b)\n  (let ((r1 (matrix-rows a)) (c1 (matrix-cols a))\n        (r2 (matrix-rows b)) (c2 (matrix-cols b)))\n    (if (or (not (= r1 r2)) (not (= c1 c2)))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let ((d1 (matrix-data a)) (d2 (matrix-data b))\n              (out (make-vector (* r1 c1) 0)))\n          (do ((i 0 (+ i 1)))\n              ((= i (* r1 c1)))\n            (vector-set! out i (* (vector-ref d1 i) (vector-ref d2 i))))\n          (list 'matrix r1 c1 out)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n(let () (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "matrix-hadamard"], "split": "train"}
{"id": "numeric_instances_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `matrix/`\n\n```python\ndef matrix_div(m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if r1 != r2 or c1 != c2:\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c1)\n    for i in range(r1 * c1):\n        out[i] = d1[i] / d2[i]\n    return ['matrix', r1, c1, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))))\n(let () (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "translation", "python", "matrix/"], "split": "train"}
{"id": "numeric_instances_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix/`\n\n```scheme\n(define (mdiv a b)\n  (let ((r1 (matrix-rows a)) (c1 (matrix-cols a))\n        (r2 (matrix-rows b)) (c2 (matrix-cols b)))\n    (if (or (not (= r1 r2)) (not (= c1 c2)))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let ((d1 (matrix-data a)) (d2 (matrix-data b))\n              (out (make-vector (* r1 c1) 0)))\n          (do ((i 0 (+ i 1)))\n              ((= i (* r1 c1)))\n            (vector-set! out i (/ (vector-ref d1 i) (vector-ref d2 i))))\n          (list 'matrix r1 c1 out)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))))\n(let () (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "matrix/"], "split": "train"}
{"id": "numeric_instances_translation_013", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `matrix-recip`\n\n```python\ndef matrix_recip(m):\n    return matrix_map(lambda x: 1 / x, m)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))))\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "translation", "python", "matrix-recip"], "split": "train"}
{"id": "numeric_instances_translation_014", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-recip`\n\n```scheme\n(define (mrecip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))))\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "matrix-recip"], "split": "train"}
{"id": "numeric_instances_translation_015", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `scalar-matrix+`\n\n```python\ndef scalar_matrix_add(k, m):\n    return matrix_map(lambda x: k + x, m)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))))\n(let () (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "translation", "python", "scalar-matrix+"], "split": "train"}
{"id": "numeric_instances_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-abs` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Positive values should be unchanged by absolute value; they must not be incremented.\n\n```scheme\n(define (vec-abs v)\n  (vec-map (lambda (x)\n                   (if (< x 0)\n                       (- x)\n                       (+ x 1)))\n           v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Positive values should be unchanged by absolute value; they must not be incremented.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)))\n(let () (equal? (vec-abs (vec)) '#()))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-abs"], "split": "train"}
{"id": "numeric_instances_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-signum` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Zero must map to 0, not 1.\n\n```scheme\n(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [else 1]))\n           v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Zero must map to 0, not 1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-signum"], "split": "train"}
{"id": "numeric_instances_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-signum` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Signs for positive/negative cases are swapped.\n\n```scheme\n(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) 1]\n                         [(> x 0) -1]\n                         [else 0]))\n           v))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Signs for positive/negative cases are swapped.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)))\n(let () (equal? (vec-signum (vec 0 0)) '#(0 0)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-signum"], "split": "train"}
{"id": "numeric_instances_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-recip` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Reciprocal must preserve sign; using abs loses negative signs.\n\n```scheme\n(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 (abs x))) v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Reciprocal must preserve sign; using abs loses negative signs.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n(let () (equal? (vec-recip (vec -2)) '#(-1/2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-recip"], "split": "train"}
{"id": "numeric_instances_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-recip` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Division direction is reversed.\n\n```scheme\n(define (vec-recip v)\n  (vec-map (lambda (x) (/ x 1)) v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)))\n(let () (equal? (vec-recip (vec -2)) '#(-1/2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))", "verify_expr": "(let ()\n  (define (vec-recip v)\n  (vec-map (lambda (x) (/ 1 x)) v))\n  (and (equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5)) (equal? (vec-recip (vec -2)) '#(-1/2))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-recip"], "split": "train"}
{"id": "numeric_instances_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-pow` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Operation should exponentiate elementwise, not add.\n\n```scheme\n(define (vec-pow v1 v2)\n  (vec-zip-with + v1 v2))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Operation should exponentiate elementwise, not add.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n(let () (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-pow"], "split": "train"}
{"id": "numeric_instances_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-pow` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Dimension mismatch condition is inverted.\n\n```scheme\n(define (vec-pow v1 v2)\n  (if (= (vector-length v1) (vector-length v2))\n      '(error dimension-mismatch)\n      (vec-zip-with expt v1 v2)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dimension mismatch condition is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n(let () (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-pow"], "split": "train"}
{"id": "numeric_instances_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-hadamard` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Dimension check should reject mismatched shapes, not matched ones.\n\n```scheme\n(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (and (= r1 r2) (= c1 c2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (list 'matrix r1 c1 (make-vector (* r1 c1) 0)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dimension check should reject mismatched shapes, not matched ones.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix-hadamard"], "split": "train"}
{"id": "numeric_instances_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix/` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Elementwise division is required, not multiplication.\n\n```scheme\n(define (matrix/ m1 m2)\n  (matrix-hadamard m1 m2))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))))\n(let () (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix/"], "split": "train"}
{"id": "numeric_instances_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix/` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Numerator and denominator order is reversed.\n\n```scheme\n(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (or (not (= r1 r2)) (not (= c1 c2)))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [result (make-vector (* r1 c1) 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i (* r1 c1)))\n            (vector-set! result i (/ (vector-ref data2 i) (vector-ref data1 i))))\n          (list 'matrix r1 c1 result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix/ m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (/ (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5))) (equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix/"], "split": "train"}
{"id": "numeric_instances_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-recip` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Reciprocals should be 1/x, not negated reciprocals.\n\n```scheme\n(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ -1 x)) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))))\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix-recip"], "split": "train"}
{"id": "numeric_instances_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-recip` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Division direction is wrong; this leaves the matrix unchanged.\n\n```scheme\n(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ x 1)) m))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix-recip"], "split": "train"}
{"id": "numeric_instances_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `scalar-matrix+` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Function should add scalar, not scale by multiplication.\n\n```scheme\n(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (* k x)) m))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "scalar-matrix+"], "split": "train"}
{"id": "numeric_instances_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply vec-abs to empty vector.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-abs (vec))", "verify_expr": "(equal? (vec-abs (vec)) '#())", "tags": ["linalg", "numeric-instances", "composition", "vec-abs", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: small integration task across module primitives.\n\nCompose vec-abs then vec-recip on #( -2 -4 ).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-recip (vec-abs (vec -2 -4)))", "verify_expr": "(equal? (vec-recip (vec-abs (vec -2 -4))) '#(1/2 1/4))", "tags": ["linalg", "numeric-instances", "composition", "vec-abs", "integration"], "split": "train"}
{"id": "numeric_instances_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff sum of abs values for #( -1 2 -3 ) is 6.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (vec-sum (vec-abs (vec -1 2 -3))) 6)", "verify_expr": "(equal? (= (vec-sum (vec-abs (vec -1 2 -3))) 6) #t)", "tags": ["linalg", "numeric-instances", "composition", "vec-abs", "property"], "split": "train"}
{"id": "numeric_instances_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: small integration task across module primitives.\n\nApply vec-signum to #( -5 0 7 ).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-signum (vec -5 0 7))", "verify_expr": "(equal? (vec-signum (vec -5 0 7)) '#(-1 0 1))", "tags": ["linalg", "numeric-instances", "composition", "vec-signum", "direct"], "split": "train"}
{"id": "numeric_instances_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: small integration task across module primitives.\n\nApply vec-signum to all-zero vector.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-signum (vec 0 0 0))", "verify_expr": "(equal? (vec-signum (vec 0 0 0)) '#(0 0 0))", "tags": ["linalg", "numeric-instances", "composition", "vec-signum", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply vec-signum after vec-abs on #( -2 0 3 ).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-signum (vec-abs (vec -2 0 3)))", "verify_expr": "(equal? (vec-signum (vec-abs (vec -2 0 3))) '#(1 0 1))", "tags": ["linalg", "numeric-instances", "composition", "vec-signum", "integration"], "split": "train"}
{"id": "numeric_instances_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff vec-signum outputs only values in {-1, 0, 1} on sample.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([v (vec-signum (vec -9 -1 0 4 5))]) (null? (filter (lambda (x) (not (or (= x -1) (= x 0) (= x 1)))) (vector->list v))))", "verify_expr": "(equal? (let ([v (vec-signum (vec -9 -1 0 4 5))]) (null? (filter (lambda (x) (not (or (= x -1) (= x 0) (= x 1)))) (vector->list v)))) #t)", "tags": ["linalg", "numeric-instances", "composition", "vec-signum", "property"], "split": "train"}
{"id": "numeric_instances_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: small integration task across module primitives.\n\nApply vec-recip to single negative element.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-recip (vec -2))", "verify_expr": "(equal? (vec-recip (vec -2)) '#(-1/2))", "tags": ["linalg", "numeric-instances", "composition", "vec-recip", "direct"], "split": "train"}
{"id": "numeric_instances_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose vec-recip after vec-pow #(2 3)^(#(2 1)).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-recip (vec-pow (vec 2 3) (vec 2 1)))", "verify_expr": "(equal? (vec-recip (vec-pow (vec 2 3) (vec 2 1))) '#(1/4 1/3))", "tags": ["linalg", "numeric-instances", "composition", "vec-recip", "integration"], "split": "train"}
{"id": "numeric_instances_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff reciprocals multiplied by originals are ones for sample.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([v (vec 2 5)]) (vec-zip-with * (vec-recip v) v))", "verify_expr": "(equal? (let ([v (vec 2 5)]) (vec-zip-with * (vec-recip v) v)) '#(1 1))", "tags": ["linalg", "numeric-instances", "composition", "vec-recip", "property"], "split": "train"}
{"id": "numeric_instances_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: compose existing APIs into one expression.\n\nElementwise power #(2 3 4)^(#(3 2 1)).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-pow (vec 2 3 4) (vec 3 2 1))", "verify_expr": "(equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4))", "tags": ["linalg", "numeric-instances", "composition", "vec-pow", "direct"], "split": "train"}
{"id": "numeric_instances_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn dimension mismatch on vec-pow length mismatch.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-pow (vec 1 2) (vec 3))", "verify_expr": "(equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))", "tags": ["linalg", "numeric-instances", "composition", "vec-pow", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose vec-pow then vec-abs with negative bases and odd/even exponents.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-abs (vec-pow (vec -2 -3) (vec 2 3)))", "verify_expr": "(equal? (vec-abs (vec-pow (vec -2 -3) (vec 2 3))) '#(4 27))", "tags": ["linalg", "numeric-instances", "composition", "vec-pow", "integration"], "split": "train"}
{"id": "numeric_instances_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff x^1 returns x for sample vector.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (vec-pow (vec 5 -2 9) (vec 1 1 1)) (vec 5 -2 9))", "verify_expr": "(equal? (vec-pow (vec 5 -2 9) (vec 1 1 1)) (vec 5 -2 9))", "tags": ["linalg", "numeric-instances", "composition", "vec-pow", "property"], "split": "train"}
{"id": "numeric_instances_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn dimension mismatch for incompatible hadamard inputs.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))))", "verify_expr": "(equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-hadamard", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose scalar-matrix+ then matrix-hadamard.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-hadamard (scalar-matrix+ 1 (matrix-from-lists '((1 2) (3 4)))) (matrix-from-lists '((2 2) (2 2)))))", "verify_expr": "(equal? (matrix->lists (matrix-hadamard (scalar-matrix+ 1 (matrix-from-lists '((1 2) (3 4)))) (matrix-from-lists '((2 2) (2 2))))) '((4 6) (8 10)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-hadamard", "integration"], "split": "train"}
{"id": "numeric_instances_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff hadamard with all-ones matrix preserves input.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((5 6) (7 8))) (matrix-from-lists '((1 1) (1 1)))) ) '((5 6) (7 8)))", "verify_expr": "(equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((5 6) (7 8))) (matrix-from-lists '((1 1) (1 1)))) ) '((5 6) (7 8)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-hadamard", "property"], "split": "train"}
{"id": "numeric_instances_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nElementwise divide ((10 20)(30 40)) by ((2 4)(5 8)).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8)))))", "verify_expr": "(equal? (matrix->lists (matrix/ (matrix-from-lists '((10 20) (30 40))) (matrix-from-lists '((2 4) (5 8))))) '((5 5) (6 5)))", "tags": ["linalg", "numeric-instances", "composition", "matrix/", "direct"], "split": "train"}
{"id": "numeric_instances_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn dimension mismatch on matrix/ shape mismatch.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))))", "verify_expr": "(equal? (matrix/ (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))", "tags": ["linalg", "numeric-instances", "composition", "matrix/", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose matrix-hadamard with matrix/ to recover original matrix.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix/ (matrix-hadamard (matrix-from-lists '((2 3) (4 5))) (matrix-from-lists '((7 11) (13 17)))) (matrix-from-lists '((7 11) (13 17)))))", "verify_expr": "(equal? (matrix->lists (matrix/ (matrix-hadamard (matrix-from-lists '((2 3) (4 5))) (matrix-from-lists '((7 11) (13 17)))) (matrix-from-lists '((7 11) (13 17))))) '((2 3) (4 5)))", "tags": ["linalg", "numeric-instances", "composition", "matrix/", "integration"], "split": "train"}
{"id": "numeric_instances_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply matrix-recip to ((2 4)(5 10)).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10)))))", "verify_expr": "(equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-recip", "direct"], "split": "train"}
{"id": "numeric_instances_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: small integration task across module primitives.\n\nApply matrix-recip to singleton ((1)).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-recip (matrix-from-lists '((1)))))", "verify_expr": "(equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-recip", "edge-case"], "split": "train"}
{"id": "numeric_instances_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose matrix-recip with matrix/ by dividing ones matrix by source.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) (matrix->lists (matrix/ (matrix-from-lists '((1 1) (1 1))) (matrix-from-lists '((2 4) (5 10))))))", "verify_expr": "(equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) (matrix->lists (matrix/ (matrix-from-lists '((1 1) (1 1))) (matrix-from-lists '((2 4) (5 10))))))", "tags": ["linalg", "numeric-instances", "composition", "matrix-recip", "integration"], "split": "train"}
{"id": "numeric_instances_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff reciprocal of reciprocal recovers original for sample.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (matrix->lists (matrix-recip (matrix-recip (matrix-from-lists '((2 4) (5 10)))))) '((2 4) (5 10)))", "verify_expr": "(equal? (matrix->lists (matrix-recip (matrix-recip (matrix-from-lists '((2 4) (5 10)))))) '((2 4) (5 10)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-recip", "property"], "split": "train"}
{"id": "numeric_instances_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd scalar 10 to matrix ((1 2)(3 4)).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4)))))", "verify_expr": "(equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14)))", "tags": ["linalg", "numeric-instances", "composition", "scalar-matrix+", "direct"], "split": "train"}
{"id": "numeric_instances_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd scalar -1 to matrix ((1 0)).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0)))))", "verify_expr": "(equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))", "tags": ["linalg", "numeric-instances", "composition", "scalar-matrix+", "direct"], "split": "train"}
{"id": "numeric_instances_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose scalar-matrix+ then matrix-hadamard with ones.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-hadamard (scalar-matrix+ 3 (matrix-from-lists '((1 2) (3 4)))) (matrix-from-lists '((1 1) (1 1)))))", "verify_expr": "(equal? (matrix->lists (matrix-hadamard (scalar-matrix+ 3 (matrix-from-lists '((1 2) (3 4)))) (matrix-from-lists '((1 1) (1 1))))) '((4 5) (6 7)))", "tags": ["linalg", "numeric-instances", "composition", "scalar-matrix+", "integration"], "split": "train"}
{"id": "numeric_instances_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-signum", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-signum`\nSpec: Map each element to -1, 0, or 1 depending on sign.\n\nWrite exactly one Scheme function definition for `vec-signum`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))", "verify_expr": "(let ()\n  (define (vec-signum v)\n  (vec-map (lambda (x)\n                   (cond [(< x 0) -1]\n                         [(> x 0) 1]\n                         [else 0]))\n           v))\n  (and (equal? (vec-signum (vec -5 0 7)) '#(-1 0 1)) (equal? (vec-signum (vec 0 0)) '#(0 0))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-signum"], "split": "eval"}
{"id": "numeric_instances_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-pow", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `vec-pow`\nSpec: Elementwise exponentiation; require equal vector lengths or return dimension mismatch error.\n\nWrite exactly one Scheme function definition for `vec-pow`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)))\n(let () (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))", "verify_expr": "(let ()\n  (define (vec-pow v1 v2)\n  (vec-zip-with expt v1 v2))\n  (and (equal? (vec-pow (vec 2 3 4) (vec 3 2 1)) '#(8 9 4)) (equal? (vec-pow (vec 1 2) (vec 3)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "vec-pow"], "split": "eval"}
{"id": "numeric_instances_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-recip", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/numeric-instances.ss\nFunction: `matrix-recip`\nSpec: Elementwise reciprocal of matrix entries.\n\nWrite exactly one Scheme function definition for `matrix-recip`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))))\n(let () (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))", "verify_expr": "(let ()\n  (define (matrix-recip m)\n  (matrix-map (lambda (x) (/ 1 x)) m))\n  (and (equal? (matrix->lists (matrix-recip (matrix-from-lists '((2 4) (5 10))))) '((1/2 1/4) (1/5 1/10))) (equal? (matrix->lists (matrix-recip (matrix-from-lists '((1))))) '((1)))))", "tags": ["linalg", "numeric-instances", "spec-to-code", "matrix-recip"], "split": "eval"}
{"id": "numeric_instances_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `vec-abs`\n\n```python\ndef vec_abs(v):\n    return [abs(x) for x in v]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)))\n(let () (equal? (vec-abs (vec)) '#()))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "translation", "python", "vec-abs"], "split": "eval"}
{"id": "numeric_instances_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including dimension mismatch behavior.\n\nTarget function name: `matrix-hadamard`\n\n```python\ndef matrix_hadamard(m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if r1 != r2 or c1 != c2:\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c1)\n    for i in range(r1 * c1):\n        out[i] = d1[i] * d2[i]\n    return ['matrix', r1, c1, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n(let () (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "translation", "python", "matrix-hadamard"], "split": "eval"}
{"id": "numeric_instances_translation_016", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `scalar-matrix+`\n\n```scheme\n(define (s+m k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "translation", "chez", "scalar-matrix+"], "split": "eval"}
{"id": "numeric_instances_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-abs` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Absolute value is not simple negation for positive entries.\n\n```scheme\n(define (vec-abs v)\n  (vec-map (lambda (x) (- x)) v))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Absolute value is not simple negation for positive entries.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-abs v)\n  (vec-map abs v))", "verify_expr": "(let ()\n  (define (vec-abs v)\n  (vec-map abs v))\n  (and (equal? (vec-abs (vec -1 2 -3)) '#(1 2 3)) (equal? (vec-abs (vec)) '#())))", "tags": ["linalg", "numeric-instances", "bugfix", "vec-abs"], "split": "eval"}
{"id": "numeric_instances_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-hadamard` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Hadamard product is elementwise multiplication, not addition.\n\n```scheme\n(define (matrix-hadamard m1 m2)\n  (matrix-add m1 m2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Hadamard product is elementwise multiplication, not addition.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))", "verify_expr": "(let ()\n  (define (matrix-hadamard m1 m2)\n  (let ([r1 (matrix-rows m1)]\n        [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)]\n        [c2 (matrix-cols m2)])\n       (if (or (not (= r1 r2)) (not (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let ([data1 (matrix-data m1)]\n                 [data2 (matrix-data m2)]\n                 [result (make-vector (* r1 c1) 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i (* r1 c1)))\n                    (vector-set! result i (* (vector-ref data1 i)\n                                             (vector-ref data2 i))))\n                (list 'matrix r1 c1 result)))))\n  (and (equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20))) (equal? (matrix-hadamard (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2)))) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "matrix-hadamard"], "split": "eval"}
{"id": "numeric_instances_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `scalar-matrix+` in `lattice/linalg/numeric-instances.ss`.\nKnown issue: Mapped expression must use scalar k, not duplicate x.\n\n```scheme\n(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ x x)) m))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))))\n(let () (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))", "verify_expr": "(let ()\n  (define (scalar-matrix+ k m)\n  (matrix-map (lambda (x) (+ k x)) m))\n  (and (equal? (matrix->lists (scalar-matrix+ 10 (matrix-from-lists '((1 2) (3 4))))) '((11 12) (13 14))) (equal? (matrix->lists (scalar-matrix+ -1 (matrix-from-lists '((1 0))))) '((0 -1)))))", "tags": ["linalg", "numeric-instances", "bugfix", "scalar-matrix+"], "split": "eval"}
{"id": "numeric_instances_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-abs", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply vec-abs to #( -1 2 -3 ).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-abs (vec -1 2 -3))", "verify_expr": "(equal? (vec-abs (vec -1 2 -3)) '#(1 2 3))", "tags": ["linalg", "numeric-instances", "composition", "vec-abs", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "vec-recip", "prompt": "Task mode: small integration task across module primitives.\n\nApply vec-recip to #(2 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-recip (vec 2 4 5))", "verify_expr": "(equal? (vec-recip (vec 2 4 5)) '#(1/2 1/4 1/5))", "tags": ["linalg", "numeric-instances", "composition", "vec-recip", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix-hadamard", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nHadamard multiply two 2x2 matrices.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5)))))", "verify_expr": "(equal? (matrix->lists (matrix-hadamard (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((2 3) (4 5))))) '((2 6) (12 20)))", "tags": ["linalg", "numeric-instances", "composition", "matrix-hadamard", "direct"], "split": "eval"}
{"id": "numeric_instances_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "matrix/", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff dividing matrix by itself yields all ones.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (matrix->lists (matrix/ (matrix-from-lists '((2 4) (5 10))) (matrix-from-lists '((2 4) (5 10))))) '((1 1) (1 1)))", "verify_expr": "(equal? (matrix->lists (matrix/ (matrix-from-lists '((2 4) (5 10))) (matrix-from-lists '((2 4) (5 10))))) '((1 1) (1 1)))", "tags": ["linalg", "numeric-instances", "composition", "matrix/", "property"], "split": "eval"}
{"id": "numeric_instances_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/numeric-instances.ss", "source_test": "lattice/linalg/test-numeric-instances.ss", "source_function": "scalar-matrix+", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff adding 0 leaves matrix unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (matrix->lists (scalar-matrix+ 0 (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))", "verify_expr": "(equal? (matrix->lists (scalar-matrix+ 0 (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))", "tags": ["linalg", "numeric-instances", "composition", "scalar-matrix+", "property"], "split": "eval"}
