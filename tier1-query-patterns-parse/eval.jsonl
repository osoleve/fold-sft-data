{"id": "patterns_parse_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `tags->string`\nSpec: Render a list of tags into one space-separated string using `format-tag`.\n\nWrite exactly one Scheme function definition for `tags->string`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "tags->string"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `tags->string`\nSpec: Render a list of tags into one space-separated string using `format-tag`.\n\nWrite exactly one Scheme function definition for `tags->string`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```"}
{"id": "patterns_parse_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (tags->string tags)\n  ;; TODO: join formatted tags with spaces\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `tags->string`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "tags->string"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (tags->string tags)\n  ;; TODO: join formatted tags with spaces\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `tags->string`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```"}
{"id": "patterns_parse_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `tags->string` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Render a list of tags into one space-separated string using `format-tag`.\n\nRequirements:\n1. Keep the exact function name/signature for `tags->string`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "tags->string"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `tags->string` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Render a list of tags into one space-separated string using `format-tag`.\n\nRequirements:\n1. Keep the exact function name/signature for `tags->string`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```"}
{"id": "patterns_parse_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `tags->string`.\nReturn only the Scheme definition.\n\n```python\ndef tags_to_string(tags):\n    return \" \".join(format_tag(k, v) for (k, v) in tags)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "tags->string"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `tags->string`.\nReturn only the Scheme definition.\n\n```python\ndef tags_to_string(tags):\n    return \" \".join(format_tag(k, v) for (k, v) in tags)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```"}
{"id": "patterns_parse_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `tags->string`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (render-tags tags)\n  (let loop ([ts tags] [acc \"\"])\n    (if (null? ts)\n        acc\n        (loop (cdr ts)\n              (string-append acc\n                             (if (string=? acc \"\") \"\" \" \")\n                             (format-tag (caar ts) (cdar ts)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "tags->string"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `tags->string`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (render-tags tags)\n  (let loop ([ts tags] [acc \"\"])\n    (if (null? ts)\n        acc\n        (loop (cdr ts)\n              (string-append acc\n                             (if (string=? acc \"\") \"\" \" \")\n                             (format-tag (caar ts) (cdar ts)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```"}
{"id": "patterns_parse_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `tags->string`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `tags->string`.\nReturn only the final Scheme definition.\n\n```python\ndef tags_to_string(tags):\n    return \" \".join(format_tag(k, v) for (k, v) in tags)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "tags->string"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `tags->string`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `tags->string`.\nReturn only the final Scheme definition.\n\n```python\ndef tags_to_string(tags):\n    return \" \".join(format_tag(k, v) for (k, v) in tags)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\")\n```"}
{"id": "patterns_parse_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `tags->string` in `lattice/query/patterns-parse.ss`.\nKnown issue: Tags should be separated by spaces in the joined output.\n\n```scheme\n(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (format-tag (caar ts) (cdar ts))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tags should be separated by spaces in the joined output.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "tags->string"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `tags->string` in `lattice/query/patterns-parse.ss`.\nKnown issue: Tags should be separated by spaces in the joined output.\n\n```scheme\n(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (format-tag (caar ts) (cdar ts))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tags should be separated by spaces in the joined output.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```"}
{"id": "patterns_parse_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `tags->string` in `lattice/query/patterns-parse.ss`.\nKnown issue: The accumulator should not inject a leading space before the first tag.\n\n```scheme\n(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \" \"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The accumulator should not inject a leading space before the first tag.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "tags->string"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `tags->string` in `lattice/query/patterns-parse.ss`.\nKnown issue: The accumulator should not inject a leading space before the first tag.\n\n```scheme\n(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \" \"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The accumulator should not inject a leading space before the first tag.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))] [s2 (tags->string '())]) (and (string=? s1 \"@status:done @urgent @scope:core:query\") (string=? s2 \"\"))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\")\n```"}
{"id": "patterns_parse_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: small integration task across module primitives.\n\nParse a deployment line and return `(status urgent?)` using tag lookup helpers.\n\nEnsure `extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `extract-tags`\n- `get-tag`\n- `has-tag?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tags", "lookup"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse a deployment line and return `(status urgent?)` using tag lookup helpers.\n\nEnsure `extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `extract-tags`\n- `get-tag`\n- `has-tag?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "patterns_parse_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInspect the second parsed row and report its key plus whether its value is lexically valid.\n\nEnsure `extract-tag-positions` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second))))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tag-positions", "validation"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nInspect the second parsed row and report its key plus whether its value is lexically valid.\n\nEnsure `extract-tag-positions` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "patterns_parse_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse a hierarchical value and return `(value valid-value?)`.\n\nEnsure `parse-tag-at` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-tag-at`\n- `valid-tag-value?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v)))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "parse-tag-at", "hierarchical"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nParse a hierarchical value and return `(value valid-value?)`.\n\nEnsure `parse-tag-at` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-tag-at`\n- `valid-tag-value?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "patterns_parse_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: small integration task across module primitives.\n\nFilter candidate keys to only valid tag keys.\n\nEnsure `valid-tag-key?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\"))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "valid-tag-key?", "filtering"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nFilter candidate keys to only valid tag keys.\n\nEnsure `valid-tag-key?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "patterns_parse_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: compose existing APIs into one expression.\n\nSafe-extract two path tags, then format both normalized results.\n\nEnsure `format-tag` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "format-tag", "safe-pipeline"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSafe-extract two path tags, then format both normalized results.\n\nEnsure `format-tag` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "patterns_parse_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nSanitize two path-like values and report sanitized outputs plus a traversal check.\n\nEnsure `has-path-traversal?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `has-path-traversal?`\n- `sanitize-tag-value`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2)))", "verify_expr": "(let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f)))", "tags": ["tier1", "query", "patterns-parse", "composition", "has-path-traversal?", "sanitization"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSanitize two path-like values and report sanitized outputs plus a traversal check.\n\nEnsure `has-path-traversal?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `has-path-traversal?`\n- `sanitize-tag-value`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression."}
{"id": "patterns_parse_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: compose existing APIs into one expression.\n\nSafe-extract tags and also render the sanitized result string.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `safe-extract-tags`\n- `tags->string`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags)))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "safe-extract-tags", "render"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSafe-extract tags and also render the sanitized result string.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `safe-extract-tags`\n- `tags->string`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "patterns_parse_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRender safe tags from text that includes a traversal sequence.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `safe-extract-tags`\n- `tags->string`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\"))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "safe-extract-tags", "safe-render"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRender safe tags from text that includes a traversal sequence.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `safe-extract-tags`\n- `tags->string`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "patterns_parse_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: small integration task across module primitives.\n\nSafe-extract, keep only cmd/status tags, then return their values.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status)))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status))) '(\"rm\" \"ok\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "safe-extract-tags", "selective"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nSafe-extract, keep only cmd/status tags, then return their values.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
