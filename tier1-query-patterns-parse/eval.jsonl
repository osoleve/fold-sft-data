{"id": "patterns_parse_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `extract-tags`\nSpec: Extract every valid @tag from text and return alist pairs `(symbol . value-or-#t)`.\n\nWrite exactly one Scheme function definition for `extract-tags`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "extract-tags"], "split": "eval"}
{"id": "patterns_parse_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-tag-at` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Parse one tag beginning at index `i` where `text[i]` is `@`; return parsed tuple or `#f`.\n\nRequirements:\n1. Keep the exact function name/signature for `parse-tag-at`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "parse-tag-at"], "split": "eval"}
{"id": "patterns_parse_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `tags->string`\nSpec: Render a list of tags into one space-separated string using `format-tag`.\n\nWrite exactly one Scheme function definition for `tags->string`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "tags->string"], "split": "eval"}
{"id": "patterns_parse_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `safe-extract-tags` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Extract tags and sanitize string values while preserving flag tags as `#t`.\n\nRequirements:\n1. Keep the exact function name/signature for `safe-extract-tags`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "safe-extract-tags"], "split": "eval"}
{"id": "patterns_parse_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `extract-tags`.\nReturn only the Scheme definition.\n\n```python\ndef extract_tags(text):\n    positions = extract_tag_positions(text)\n    out = []\n    for key, value, _start, _end in positions:\n        out.append((key, True if value is None else value))\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "extract-tags"], "split": "eval"}
{"id": "patterns_parse_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `parse-tag-at`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `parse-tag-at`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_tag_at(text, i):\n    n = len(text)\n    start = i\n    j = i + 1\n    if j >= n:\n        return None\n    if not char_key_start(text[j]):\n        return None\n\n    k = j\n    while k < n and char_key(text[k]):\n        k += 1\n    if k == j:\n        return None\n\n    key = text[j:k].lower()\n    if k < n and text[k] == ':':\n        v = k + 1\n        while v < n and char_value(text[v]):\n            v += 1\n        if v == k + 1:\n            return (key, None, start, k)\n        return (key, text[k + 1:v], start, v)\n\n    return (key, None, start, k)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "parse-tag-at"], "split": "eval"}
{"id": "patterns_parse_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `tags->string`.\nReturn only the Scheme definition.\n\n```python\ndef tags_to_string(tags):\n    return \" \".join(format_tag(k, v) for (k, v) in tags)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")\n```", "ground_truth": "(define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (let ([s1 (tags->string '((status . \"done\") (urgent . #t) (scope . \"core:query\")))]\n      [s2 (tags->string '())])\n  (and (string=? s1 \"@status:done @urgent @scope:core:query\")\n       (string=? s2 \"\")))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "tags->string"], "split": "eval"}
{"id": "patterns_parse_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference logic into canonical Fold Scheme for `safe-extract-tags`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `safe-extract-tags`.\nReturn only the final Scheme definition.\n\n```python\ndef safe_extract_tags(text):\n    out = []\n    for key, value in extract_tags(text):\n        if isinstance(value, str):\n            out.append((key, sanitize_tag_value(value)))\n        else:\n            out.append((key, value))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "safe-extract-tags"], "split": "eval"}
{"id": "patterns_parse_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags like `@todo` should map to `#t`, not `#f`.\n\n```scheme\n(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key val)))\n            positions)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "extract-tags"], "split": "eval"}
{"id": "patterns_parse_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-tag` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags should render as `@key` without a trailing colon.\n\n```scheme\n(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key) \":\")\n      (string-append \"@\" (symbol->string key) \":\" value)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Flag tags should render as `@key` without a trailing colon.\n\nExpected behavior after patch:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "format-tag"], "split": "eval"}
{"id": "patterns_parse_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags must remain `#t` and should not be coerced into empty strings.\n\n```scheme\n(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (sanitize-tag-value (if (string? val) val \"\")))))\n       (extract-tags text)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "safe-extract-tags"], "split": "eval"}
{"id": "patterns_parse_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: small integration task across module primitives.\n\nParse a deployment line and return `(status urgent?)` using tag lookup helpers.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `extract-tags`\n- `get-tag`\n- `has-tag?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tags", "lookup"], "split": "eval"}
{"id": "patterns_parse_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInspect the second parsed row and report its key plus whether its value is lexically valid.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second))))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tag-positions", "validation"], "split": "eval"}
{"id": "patterns_parse_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: small integration task across module primitives.\n\nFilter candidate keys to only valid tag keys.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\"))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "valid-tag-key?", "filtering"], "split": "eval"}
{"id": "patterns_parse_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: compose existing APIs into one expression.\n\nSafe-extract two path tags, then format both normalized results.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "format-tag", "safe-pipeline"], "split": "eval"}
{"id": "patterns_parse_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nSanitize two path-like values and report sanitized outputs plus a traversal check.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `has-path-traversal?`\n- `sanitize-tag-value`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2)))", "verify_expr": "(let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f)))", "tags": ["tier1", "query", "patterns-parse", "composition", "has-path-traversal?", "sanitization"], "split": "eval"}
{"id": "patterns_parse_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: small integration task across module primitives.\n\nSafe-extract, keep only cmd/status tags, then return their values.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status)))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status))) '(\"rm\" \"ok\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "safe-extract-tags", "selective"], "split": "eval"}
