{"id": "patterns_parse_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `extract-tags`\nSpec: Extract every valid @tag from text and return alist pairs `(symbol . value-or-#t)`.\n\nWrite exactly one Scheme function definition for `extract-tags`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "extract-tags"], "split": "train"}
{"id": "patterns_parse_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-tags text)\n  ;; TODO: map tag-position rows to `(key . value-or-#t)` pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-tags`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "extract-tags"], "split": "train"}
{"id": "patterns_parse_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `extract-tags` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Extract every valid @tag from text and return alist pairs `(symbol . value-or-#t)`.\n\nRequirements:\n1. Keep the exact function name/signature for `extract-tags`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "extract-tags"], "split": "train"}
{"id": "patterns_parse_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `extract-tag-positions`\nSpec: Scan text and return `(key value start end)` rows for every valid tag occurrence.\n\nWrite exactly one Scheme function definition for `extract-tag-positions`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([ps (extract-tag-positions \"x @todo:fix y @done\")] [mid (extract-tag-positions \"mail user@example.com\")]) (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19))) (equal? mid '()))))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions)) '(#t #t))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions)) '(#t #t))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-tag-positions text)\n  ;; TODO: scan the string, parse each valid @tag, and collect `(key value start end)` rows\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-tag-positions`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `extract-tag-positions` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Scan text and return `(key value start end)` rows for every valid tag occurrence.\n\nRequirements:\n1. Keep the exact function name/signature for `extract-tag-positions`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `parse-tag-at`\nSpec: Parse one tag beginning at index `i` where `text[i]` is `@`; return parsed tuple or `#f`.\n\nWrite exactly one Scheme function definition for `parse-tag-at`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-tag-at text i)\n  ;; TODO: parse one @tag at index i and return `(key value start end)` or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-tag-at`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-tag-at` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Parse one tag beginning at index `i` where `text[i]` is `@`; return parsed tuple or `#f`.\n\nRequirements:\n1. Keep the exact function name/signature for `parse-tag-at`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `valid-tag-key?`\nSpec: Validate tag keys: non-empty, starts with lowercase letter, then lowercase/digit/hyphen.\n\nWrite exactly one Scheme function definition for `valid-tag-key?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (valid-tag-key? \"status\"))\n(let () (valid-tag-key? \"high-priority2\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))\n```\n\nCheck 2:\n```scheme\n(equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (valid-tag-key? s)\n  ;; TODO: enforce tag-key lexical rules\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `valid-tag-key?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (valid-tag-key? \"status\"))\n(let () (valid-tag-key? \"high-priority2\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `valid-tag-key?` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Validate tag keys: non-empty, starts with lowercase letter, then lowercase/digit/hyphen.\n\nRequirements:\n1. Keep the exact function name/signature for `valid-tag-key?`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))\n```\n\nCheck 2:\n```scheme\n(equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `format-tag`\nSpec: Render a single tag pair as `@key` for flags or `@key:value` for valued tags.\n\nWrite exactly one Scheme function definition for `format-tag`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "format-tag"], "split": "train"}
{"id": "patterns_parse_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-tag key value)\n  ;; TODO: format @key or @key:value\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-tag`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "format-tag"], "split": "train"}
{"id": "patterns_parse_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `format-tag` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Render a single tag pair as `@key` for flags or `@key:value` for valued tags.\n\nRequirements:\n1. Keep the exact function name/signature for `format-tag`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "format-tag"], "split": "train"}
{"id": "patterns_parse_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `has-path-traversal?`\nSpec: Detect unsafe path payloads including absolute paths and `..` traversal contexts.\n\nWrite exactly one Scheme function definition for `has-path-traversal?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (has-path-traversal? s)\n  ;; TODO: detect absolute/traversal paths in tag values\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `has-path-traversal?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([v1 (sanitize-tag-value \"../secret\")] [v2 (sanitize-tag-value \"docs/readme\")]) (list v1 v2 (has-path-traversal? v2))) '(\"\" \"docs/readme\" #f))))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `has-path-traversal?` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Detect unsafe path payloads including absolute paths and `..` traversal contexts.\n\nRequirements:\n1. Keep the exact function name/signature for `has-path-traversal?`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this metadata parser function in Fold-native Scheme.\n\nTarget module: lattice/query/patterns-parse.ss\nFunction: `safe-extract-tags`\nSpec: Extract tags and sanitize string values while preserving flag tags as `#t`.\n\nWrite exactly one Scheme function definition for `safe-extract-tags`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status))) '(\"rm\" \"ok\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (safe-extract-tags \"@cmd:rm&rf @status:ok @scope:core:query\")] [keep (filter-tags-by-key tags (lambda (k) (or (eq? k 'cmd) (eq? k 'status))))]) (list (get-tag keep 'cmd) (get-tag keep 'status))) '(\"rm\" \"ok\"))))", "tags": ["tier1", "query", "patterns-parse", "spec-to-code", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (safe-extract-tags text)\n  ;; TODO: sanitize string values returned by extract-tags\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `safe-extract-tags`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")))", "tags": ["tier1", "query", "patterns-parse", "skeleton-completion", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `safe-extract-tags` directly from this API contract.\n\nModule: `lattice/query/patterns-parse.ss`\nContract focus: Extract tags and sanitize string values while preserving flag tags as `#t`.\n\nRequirements:\n1. Keep the exact function name/signature for `safe-extract-tags`.\n2. Match module behavior on boundary/edge cases.\n3. Return exactly one definition, with no extra helpers or commentary.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))))", "tags": ["tier1", "query", "patterns-parse", "contract-implementation", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `extract-tags`.\nReturn only the Scheme definition.\n\n```python\ndef extract_tags(text):\n    positions = extract_tag_positions(text)\n    out = []\n    for key, value, _start, _end in positions:\n        out.append((key, True if value is None else value))\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `extract-tags`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (collect-tags txt)\n  (map (lambda (row)\n         (let ([k (car row)] [v (cadr row)])\n           (cons k (if v v #t))))\n       (extract-tag-positions txt)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `extract-tags`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `extract-tags`.\nReturn only the final Scheme definition.\n\n```python\ndef extract_tags(text):\n    positions = extract_tag_positions(text)\n    out = []\n    for key, value, _start, _end in positions:\n        out.append((key, True if value is None else value))\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_004", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `extract-tag-positions`.\nReturn only the Scheme definition.\n\n```python\ndef extract_tag_positions(text):\n    i = 0\n    out = []\n    n = len(text)\n    while i < n:\n        if text[i] == '@' and valid_tag_start(text, i):\n            row = parse_tag_at(text, i)\n            if row is not None:\n                out.append(row)\n                i = row[3]\n                continue\n        i += 1\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `extract-tag-positions`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (collect-tag-rows txt)\n  (let ([n (string-length txt)])\n    (let loop ([i 0] [acc '()])\n      (if (>= i n)\n          (reverse acc)\n          (if (and (char=? (string-ref txt i) #\\@)\n                   (valid-tag-start? txt i))\n              (let ([row (parse-tag-at txt i)])\n                (if row\n                    (loop (cadddr row) (cons row acc))\n                    (loop (+ i 1) acc)))\n              (loop (+ i 1) acc))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([ps (extract-tag-positions \"x @todo:fix y @done\")] [mid (extract-tag-positions \"mail user@example.com\")]) (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19))) (equal? mid '()))))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference logic into canonical Fold Scheme for `extract-tag-positions`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `extract-tag-positions`.\nReturn only the final Scheme definition.\n\n```python\ndef extract_tag_positions(text):\n    i = 0\n    out = []\n    n = len(text)\n    while i < n:\n        if text[i] == '@' and valid_tag_start(text, i):\n            row = parse_tag_at(text, i)\n            if row is not None:\n                out.append(row)\n                i = row[3]\n                continue\n        i += 1\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-tag-at`.\nReturn only the Scheme definition.\n\n```python\ndef parse_tag_at(text, i):\n    n = len(text)\n    start = i\n    j = i + 1\n    if j >= n:\n        return None\n    if not char_key_start(text[j]):\n        return None\n\n    k = j\n    while k < n and char_key(text[k]):\n        k += 1\n    if k == j:\n        return None\n\n    key = text[j:k].lower()\n    if k < n and text[k] == ':':\n        v = k + 1\n        while v < n and char_value(text[v]):\n            v += 1\n        if v == k + 1:\n            return (key, None, start, k)\n        return (key, text[k + 1:v], start, v)\n\n    return (key, None, start, k)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-tag-at`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (parse-one-tag txt i)\n  (let* ([n (string-length txt)] [j (+ i 1)])\n    (if (or (>= j n) (not (char-key-start? (string-ref txt j))))\n        #f\n        (let key-loop ([k j])\n          (if (and (< k n) (char-key? (string-ref txt k)))\n              (key-loop (+ k 1))\n              (let ([ks (substring txt j k)]\n                    [sym (string->symbol (string-downcase (substring txt j k)))])\n                (if (and (< k n) (char=? (string-ref txt k) #\\:))\n                    (let val-loop ([v (+ k 1)])\n                      (if (and (< v n) (char-value? (string-ref txt v)))\n                          (val-loop (+ v 1))\n                          (if (= v (+ k 1))\n                              (list sym #f i k)\n                              (list sym (substring txt (+ k 1) v) i v))))\n                    (list sym #f i k)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `parse-tag-at`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `parse-tag-at`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_tag_at(text, i):\n    n = len(text)\n    start = i\n    j = i + 1\n    if j >= n:\n        return None\n    if not char_key_start(text[j]):\n        return None\n\n    k = j\n    while k < n and char_key(text[k]):\n        k += 1\n    if k == j:\n        return None\n\n    key = text[j:k].lower()\n    if k < n and text[k] == ':':\n        v = k + 1\n        while v < n and char_value(text[v]):\n            v += 1\n        if v == k + 1:\n            return (key, None, start, k)\n        return (key, text[k + 1:v], start, v)\n\n    return (key, None, start, k)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `valid-tag-key?`.\nReturn only the Scheme definition.\n\n```python\ndef valid_tag_key(s):\n    if len(s) == 0:\n        return False\n    if not char_key_start(s[0]):\n        return False\n    return all(char_key(ch) for ch in s[1:])\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))\n```\n\nCheck 2:\n```scheme\n(equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `valid-tag-key?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (tag-key-ok? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n         (or (>= i (string-length s))\n             (and (char-key? (string-ref s i))\n                  (loop (+ i 1)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))\n```\n\nCheck 2:\n```scheme\n(equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `valid-tag-key?`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `valid-tag-key?`.\nReturn only the final Scheme definition.\n\n```python\ndef valid_tag_key(s):\n    if len(s) == 0:\n        return False\n    if not char_key_start(s[0]):\n        return False\n    return all(char_key(ch) for ch in s[1:])\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (valid-tag-key? \"status\"))\n(let () (valid-tag-key? \"high-priority2\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))\n```\n\nCheck 2:\n```scheme\n(equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `format-tag`.\nReturn only the Scheme definition.\n\n```python\ndef format_tag(key, value):\n    if value is True:\n        return f\"@{key}\"\n    return f\"@{key}:{value}\" \n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "format-tag"], "split": "train"}
{"id": "patterns_parse_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `format-tag`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (render-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "format-tag"], "split": "train"}
{"id": "patterns_parse_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference logic into canonical Fold Scheme for `format-tag`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `format-tag`.\nReturn only the final Scheme definition.\n\n```python\ndef format_tag(key, value):\n    if value is True:\n        return f\"@{key}\"\n    return f\"@{key}:{value}\" \n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\"))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "format-tag"], "split": "train"}
{"id": "patterns_parse_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `has-path-traversal?`.\nReturn only the Scheme definition.\n\n```python\ndef has_path_traversal(s):\n    if len(s) == 0:\n        return False\n    if s[0] == '/':\n        return True\n    for i in range(len(s) - 1):\n        if s[i] == '.' and s[i + 1] == '.':\n            at_start = (i == 0)\n            at_end = (i + 2 >= len(s))\n            after_slash = (i > 0 and s[i - 1] == '/')\n            before_slash = (i + 2 < len(s) and s[i + 2] in ('/', '\\\\'))\n            if at_start or at_end or after_slash or before_slash:\n                return True\n    return False\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_translation_020", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `has-path-traversal?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (path-traversal? s)\n  (let ([n (string-length s)])\n    (cond\n      [(= n 0) #f]\n      [(char=? (string-ref s 0) #\\/) #t]\n      [else\n       (let loop ([i 0])\n         (cond\n           [(>= i (- n 1)) #f]\n           [(and (char=? (string-ref s i) #\\.)\n                 (char=? (string-ref s (+ i 1)) #\\.))\n            (let ([at-start (= i 0)]\n                  [at-end (>= (+ i 2) n)]\n                  [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                  [before-slash (and (< (+ i 2) n)\n                                     (or (char=? (string-ref s (+ i 2)) #\\/)\n                                         (char=? (string-ref s (+ i 2)) #\\\\)))])\n              (if (or at-start at-end after-slash before-slash)\n                  #t\n                  (loop (+ i 1))))]\n           [else (loop (+ i 1))]))])))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference logic into canonical Fold Scheme for `has-path-traversal?`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `has-path-traversal?`.\nReturn only the final Scheme definition.\n\n```python\ndef has_path_traversal(s):\n    if len(s) == 0:\n        return False\n    if s[0] == '/':\n        return True\n    for i in range(len(s) - 1):\n        if s[i] == '.' and s[i + 1] == '.':\n            at_start = (i == 0)\n            at_end = (i + 2 >= len(s))\n            after_slash = (i > 0 and s[i - 1] == '/')\n            before_slash = (i + 2 < len(s) and s[i + 2] in ('/', '\\\\'))\n            if at_start or at_end or after_slash or before_slash:\n                return True\n    return False\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\"))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `safe-extract-tags`.\nReturn only the Scheme definition.\n\n```python\ndef safe_extract_tags(text):\n    out = []\n    for key, value in extract_tags(text):\n        if isinstance(value, str):\n            out.append((key, sanitize_tag_value(value)))\n        else:\n            out.append((key, value))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")))", "tags": ["tier1", "query", "patterns-parse", "python-to-scheme", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `safe-extract-tags`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (collect-safe-tags txt)\n  (map (lambda (kv)\n         (let ([k (car kv)] [v (cdr kv)])\n           (cons k (if (string? v) (sanitize-tag-value v) v))))\n       (extract-tags txt)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```\n\nCheck 2:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")))", "tags": ["tier1", "query", "patterns-parse", "chez-to-fold", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference logic into canonical Fold Scheme for `safe-extract-tags`.\n\nPreserve observable behavior and edge-case handling exactly.\nKeep the target function name/signature as `safe-extract-tags`.\nReturn only the final Scheme definition.\n\n```python\ndef safe_extract_tags(text):\n    out = []\n    for key, value in extract_tags(text):\n        if isinstance(value, str):\n            out.append((key, sanitize_tag_value(value)))\n        else:\n            out.append((key, value))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (tags->string (safe-extract-tags \"@path:foo/../bar @owner:bob\")) \"@path: @owner:bob\")) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))))", "tags": ["tier1", "query", "patterns-parse", "reference-translation", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags like `@todo` should map to `#t`, not `#f`.\n\n```scheme\n(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key val)))\n            positions)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "extract-tags"], "split": "train"}
{"id": "patterns_parse_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: The current logic silently drops the first parsed tag.\n\n```scheme\n(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            (cdr positions))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The current logic silently drops the first parsed tag.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([a (extract-tags \"Fix @status:done @urgent\")] [b (extract-tags \"email@example.com @ok\")] [c (extract-tags \"@scope:core:query\")]) (and (equal? a '((status . \"done\") (urgent . #t))) (equal? b '((ok . #t))) (equal? c '((scope . \"core:query\"))))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")\n```", "ground_truth": "(define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (let ([a (extract-tags \"Fix @status:done @urgent\")]\n      [b (extract-tags \"email@example.com @ok\")]\n      [c (extract-tags \"@scope:core:query\")])\n  (and (equal? a '((status . \"done\") (urgent . #t)))\n       (equal? b '((ok . #t)))\n       (equal? c '((scope . \"core:query\")))))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-tag? tags key)\n  (and (assq key tags) #t))\n  (define (get-tag tags key)\n  (let ([pair (assq key tags)])\n       (if pair (cdr pair) #f)))\n  (equal? (let* ([tags (extract-tags \"Deploy @status:ready @urgent\")] [status (get-tag tags 'status)] [urgent? (has-tag? tags 'urgent)]) (list status urgent?)) '(\"ready\" #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "extract-tags"], "split": "train"}
{"id": "patterns_parse_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-tag-positions` in `lattice/query/patterns-parse.ss`.\nKnown issue: `@` in the middle of words (for example emails) must not start tags.\n\n```scheme\n(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (char=? (string-ref text i) #\\@)\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([ps (extract-tag-positions \"x @todo:fix y @done\")] [mid (extract-tag-positions \"mail user@example.com\")]) (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19))) (equal? mid '()))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-tag-positions` in `lattice/query/patterns-parse.ss`.\nKnown issue: Recorded start index must point at `@`; shifting it by +1 corrupts reported tag positions.\n\n```scheme\n(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (+ i 1)\n                                   (cons (list (car tag-info)\n                                               (cadr tag-info)\n                                               (+ (caddr tag-info) 1)\n                                               (cadddr tag-info))\n                                         results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Recorded start index must point at `@`; shifting it by +1 corrupts reported tag positions.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([ps (extract-tag-positions \"x @todo:fix y @done\")] [mid (extract-tag-positions \"mail user@example.com\")]) (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19))) (equal? mid '()))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([ps (extract-tag-positions \"x @todo:fix y @done\")] [mid (extract-tag-positions \"mail user@example.com\")]) (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19))) (equal? mid '()))))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions)) '(#t #t))\n```", "ground_truth": "(define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (let ([ps (extract-tag-positions \"x @todo:fix y @done\")]\n      [mid (extract-tag-positions \"mail user@example.com\")])\n  (and (equal? ps '((todo \"fix\" 2 11) (done #f 14 19)))\n       (equal? mid '())))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([positions (extract-tag-positions \"@a @topic:core:query\")] [second (cadr positions)]) (list (car second) (valid-tag-value? (cadr second)))) '(topic #t))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions)) '(#t #t))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "extract-tag-positions"], "split": "train"}
{"id": "patterns_parse_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-tag-at` in `lattice/query/patterns-parse.ss`.\nKnown issue: Tag keys must start with lowercase letters only; leading digits are invalid.\n\n```scheme\n(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag keys must start with lowercase letters only; leading digits are invalid.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-value? s)\n  (and (> (string-length s) 0)\n       (let loop ([i 0])\n            (if (>= i (string-length s))\n                #t\n                (and (char-value? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([p (parse-tag-at \"@scope:lang:scheme:chez\" 0)] [v (cadr p)]) (list v (valid-tag-value? v))) '(\"lang:scheme:chez\" #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-tag-at` in `lattice/query/patterns-parse.ss`.\nKnown issue: `@key:` with an empty value should be treated as a flag (`#f` internal value), not empty string.\n\n```scheme\n(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym \"\" start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: `@key:` with an empty value should be treated as a flag (`#f` internal value), not empty string.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)] [r2 (parse-tag-at \"x @ok\" 2)] [r3 (parse-tag-at \"@9bad\" 0)] [r4 (parse-tag-at \"@todo:\" 0)]) (and (equal? r1 '(topic \"lang:scheme\" 0 18)) (equal? r2 '(ok #f 2 5)) (equal? r3 #f) (equal? r4 '(todo #f 0 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))\n```", "ground_truth": "(define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (let* ([r1 (parse-tag-at \"@topic:lang:scheme\" 0)]\n       [r2 (parse-tag-at \"x @ok\" 2)]\n       [r3 (parse-tag-at \"@9bad\" 0)]\n       [r4 (parse-tag-at \"@todo:\" 0)])\n  (and (equal? r1 '(topic \"lang:scheme\" 0 18))\n       (equal? r2 '(ok #f 2 5))\n       (equal? r3 #f)\n       (equal? r4 '(todo #f 0 5))))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\")) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "parse-tag-at"], "split": "train"}
{"id": "patterns_parse_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `valid-tag-key?` in `lattice/query/patterns-parse.ss`.\nKnown issue: The empty-string guard is wrong and can crash on `(string-ref s 0)`; empty keys must return #f.\n\n```scheme\n(define (valid-tag-key? s)\n  (and (>= (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The empty-string guard is wrong and can crash on `(string-ref s 0)`; empty keys must return #f.\n\nExpected behavior after patch:\n```scheme\n(let () (valid-tag-key? \"status\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))\n```\n\nCheck 2:\n```scheme\n(equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (equal? (filter valid-tag-key? '(\"status\" \"1bad\" \"high-priority\" \"Bad\")) '(\"status\" \"high-priority\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `valid-tag-key?` in `lattice/query/patterns-parse.ss`.\nKnown issue: The first character has stricter rules than subsequent characters.\n\n```scheme\n(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (valid-tag-key? \"status\"))\n(let () (valid-tag-key? \"high-priority2\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))\n```", "ground_truth": "(define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))", "verify_expr": "(and (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (and (valid-tag-key? \"status\")\n     (valid-tag-key? \"high-priority2\")\n     (not (valid-tag-key? \"1status\"))\n     (not (valid-tag-key? \"Bad\"))\n     (not (valid-tag-key? \"\")))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\"))) (let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "valid-tag-key?"], "split": "train"}
{"id": "patterns_parse_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-tag` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags should render as `@key` without a trailing colon.\n\n```scheme\n(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key) \":\")\n      (string-append \"@\" (symbol->string key) \":\" value)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Flag tags should render as `@key` without a trailing colon.\n\nExpected behavior after patch:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "format-tag"], "split": "train"}
{"id": "patterns_parse_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-tag` in `lattice/query/patterns-parse.ss`.\nKnown issue: Value tags must keep `key` before `value` in output.\n\n```scheme\n(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" value \":\" (symbol->string key))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (string=? (format-tag 'todo #t) \"@todo\"))\n(let () (string=? (format-tag 'status \"done\") \"@status:done\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")\n```", "ground_truth": "(define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))", "verify_expr": "(and (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (and (string=? (format-tag 'todo #t) \"@todo\")\n     (string=? (format-tag 'status \"done\") \"@status:done\")\n     (string=? (format-tag 'scope \"lang:scheme\") \"@scope:lang:scheme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @path2:docs/readme\")] [p1 (format-tag (caar tags) (cdar tags))] [p2 (format-tag (caadr tags) (cdadr tags))]) (list p1 p2)) '(\"@path:\" \"@path2:docs/readme\"))) (let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "format-tag"], "split": "train"}
{"id": "patterns_parse_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `has-path-traversal?` in `lattice/query/patterns-parse.ss`.\nKnown issue: Absolute Unix-style paths should be rejected immediately.\n\n```scheme\n(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Absolute Unix-style paths should be rejected immediately.\n\nExpected behavior after patch:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n(let () (has-path-traversal? \"foo/../bar\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `has-path-traversal?` in `lattice/query/patterns-parse.ss`.\nKnown issue: Traversal checks should also handle Windows separator `\\` after `..`.\n\n```scheme\n(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (char=? (string-ref s (+ i 2)) #\\/))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Traversal checks should also handle Windows separator `\\` after `..`.\n\nExpected behavior after patch:\n```scheme\n(let () (has-path-traversal? \"../secret\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))\n```", "ground_truth": "(define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))", "verify_expr": "(and (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (and (has-path-traversal? \"../secret\")\n     (has-path-traversal? \"foo/../bar\")\n     (has-path-traversal? \"/etc/passwd\")\n     (not (has-path-traversal? \"file..name\"))\n     (not (has-path-traversal? \"./current/dir\")))) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\")) (let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "has-path-traversal?"], "split": "train"}
{"id": "patterns_parse_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: Safe extraction must sanitize string values instead of returning raw extracted tags.\n\n```scheme\n(define (safe-extract-tags text)\n  (extract-tags text))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-extract-tags` in `lattice/query/patterns-parse.ss`.\nKnown issue: Flag tags must remain `#t` and should not be coerced into empty strings.\n\n```scheme\n(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (sanitize-tag-value (if (string? val) val \"\")))))\n       (extract-tags text)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))\n```", "ground_truth": "(define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))", "verify_expr": "(and (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (let ([tags (safe-extract-tags \"@path:../secret @cmd:rm&rf @ok:clean @flag\")])\n  (and (equal? tags '((path . \"\") (cmd . \"rm\") (ok . \"clean\") (flag . #t)))\n       (string=? (cdr (assq 'ok tags)) \"clean\")\n       (eq? (cdr (assq 'flag tags)) #t)))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let ([tags (safe-extract-tags \"@path:/etc/passwd @todo\")]) (list tags (tags->string tags))) '(((path . \"\") (todo . #t)) \"@path: @todo\"))) (let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\"))))", "tags": ["tier1", "query", "patterns-parse", "bugfix", "safe-extract-tags"], "split": "train"}
{"id": "patterns_parse_composition_002", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract tags, keep only keys starting with `p`, and return canonical text.\n\nEnsure `extract-tags` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"Refs @priority:high @owner:alice @phase:beta\")] [p-tags (filter-tags-by-key tags (lambda (k) (char=? (string-ref (symbol->string k) 0) #\\p)))]) (tags->string p-tags)) \"@priority:high @phase:beta\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tags", "filtering"], "split": "train"}
{"id": "patterns_parse_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: small integration task across module primitives.\n\nParse a mixed line with an email token and return `(count rendered)` for valid tags only.\n\nEnsure `extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `extract-tags`\n- `tags->string`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"mail user@example.com @ok @kind:note\")] [count (length tags)] [as-text (tags->string tags)]) (list count as-text)) '(2 \"@ok @kind:note\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tags", "render"], "split": "train"}
{"id": "patterns_parse_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tags", "prompt": "Task mode: compose existing APIs into one expression.\n\nRoundtrip parse/format and report whether the first parsed key satisfies key validation.\n\nEnsure `extract-tags` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags (extract-tags \"@status:open @todo\")] [rendered (tags->string tags)] [status-ok (valid-tag-key? (symbol->string (caar tags)))]) (list rendered status-ok)) '(\"@status:open @todo\" #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tags", "roundtrip"], "split": "train"}
{"id": "patterns_parse_composition_005", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract tag rows, then re-parse each start offset and return only parsed keys.\n\nEnsure `extract-tag-positions` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `extract-tag-positions`\n- `parse-tag-at`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"x @todo:fix y @done\"] [positions (extract-tag-positions text)]) (map (lambda (p) (car (parse-tag-at text (caddr p)))) positions)) '(todo done)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tag-positions", "alignment"], "split": "train"}
{"id": "patterns_parse_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: small integration task across module primitives.\n\nParse rows from mixed text and render each parsed key back as a flag tag.\n\nEnsure `extract-tag-positions` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"mail user@example.com @ok @phase:beta\"] [positions (extract-tag-positions text)] [keys (map car positions)]) (map (lambda (k) (format-tag k #t)) keys)) '(\"@ok\" \"@phase\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tag-positions", "formatting"], "split": "train"}
{"id": "patterns_parse_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "extract-tag-positions", "prompt": "Task mode: small integration task across module primitives.\n\nCross-check each extracted position by reparsing at the same offset and verifying key/value agreement.\n\nEnsure `extract-tag-positions` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `extract-tag-positions`\n- `parse-tag-at`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (equal? (let* ([text \"A @kind:doc and @flag\"] [positions (extract-tag-positions text)]) (map (lambda (p) (let ([parsed (parse-tag-at text (caddr p))]) (and parsed (eq? (car parsed) (car p)) (equal? (cadr parsed) (cadr p))))) positions)) '(#t #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "extract-tag-positions", "consistency"], "split": "train"}
{"id": "patterns_parse_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse a tag at a known index and re-render it with `format-tag`.\n\nEnsure `parse-tag-at` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t)))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([text \"x @status:done\"] [p (parse-tag-at text 2)]) (format-tag (car p) (or (cadr p) #t))) \"@status:done\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "parse-tag-at", "render"], "split": "train"}
{"id": "patterns_parse_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse three candidate offsets and summarize key validity plus parsed outputs.\n\nEnsure `parse-tag-at` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-tag-at`\n- `valid-tag-key?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3)))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let* ([text \"@ok not-tag @1bad @todo\"] [r1 (parse-tag-at text 0)] [r2 (parse-tag-at text 12)] [r3 (parse-tag-at text 18)]) (list (valid-tag-key? (symbol->string (car r1))) r2 (car r3) (cadr r3))) '(#t #f todo #f)))", "tags": ["tier1", "query", "patterns-parse", "composition", "parse-tag-at", "offsets"], "split": "train"}
{"id": "patterns_parse_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "parse-tag-at", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nShow that both `@todo:` and `@todo` normalize to flag rendering.\n\nEnsure `parse-tag-at` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t))))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let* ([p1 (parse-tag-at \"@todo:\" 0)] [p2 (parse-tag-at \"@todo\" 0)]) (list (format-tag (car p1) (or (cadr p1) #t)) (format-tag (car p2) (or (cadr p2) #t)))) '(\"@todo\" \"@todo\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "parse-tag-at", "flags"], "split": "train"}
{"id": "patterns_parse_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse tags and return key-validation flags for each parsed symbol.\n\nEnsure `valid-tag-key?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `valid-tag-key?`\n- `extract-tags`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:ok @todo @x-1:yes\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "valid-tag-key?", "parser-integration"], "split": "train"}
{"id": "patterns_parse_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFormat only valid keys as flags and mark invalid ones explicitly.\n\nEnsure `valid-tag-key?` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `valid-tag-key?`\n- `format-tag`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\"))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (map (lambda (k) (if (valid-tag-key? k) (format-tag (string->symbol k) #t) \"invalid\")) '(\"priority\" \"2bad\" \"owner\")) '(\"@priority\" \"invalid\" \"@owner\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "valid-tag-key?", "conditional"], "split": "train"}
{"id": "patterns_parse_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "valid-tag-key?", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun safe extraction, then validate every parsed key symbol.\n\nEnsure `valid-tag-key?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `valid-tag-key?`\n- `safe-extract-tags`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys))", "verify_expr": "(let ()\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../secret @owner:alice\")] [keys (map (lambda (p) (symbol->string (car p))) tags)]) (map valid-tag-key? keys)) '(#t #t)))", "tags": ["tier1", "query", "patterns-parse", "composition", "valid-tag-key?", "safe-pipeline"], "split": "train"}
{"id": "patterns_parse_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRender the first tag directly and also render the full tag list with `tags->string`.\n\nEnsure `format-tag` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (equal? (let* ([tags '((status . \"done\") (urgent . #t) (scope . \"core:query\"))] [joined (tags->string tags)] [first (format-tag (caar tags) (cdar tags))]) (list first joined)) '(\"@status:done\" \"@status:done @urgent @scope:core:query\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "format-tag", "render"], "split": "train"}
{"id": "patterns_parse_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: small integration task across module primitives.\n\nFormat a key/value pair and verify it roundtrips through `extract-tags`.\n\nEnsure `format-tag` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip)))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([rendered (format-tag 'owner \"alice\")] [roundtrip (extract-tags rendered)]) (cdr (car roundtrip))) \"alice\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "format-tag", "roundtrip"], "split": "train"}
{"id": "patterns_parse_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "format-tag", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConditionally format a tag only when the key string is valid.\n\nEnsure `format-tag` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `format-tag`\n- `valid-tag-key?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\"))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (valid-tag-key? s)\n  (and (> (string-length s) 0)\n       (char-key-start? (string-ref s 0))\n       (let loop ([i 1])\n            (if (>= i (string-length s))\n                #t\n                (and (char-key? (string-ref s i))\n                     (loop (+ i 1)))))))\n  (equal? (let ([k \"priority\"]) (if (valid-tag-key? k) (format-tag (string->symbol k) \"high\") \"invalid\")) \"@priority:high\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "format-tag", "conditional"], "split": "train"}
{"id": "patterns_parse_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRoundtrip tags by parsing then rendering the same sequence.\n\nEnsure `tags->string` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(tags->string (extract-tags \"@status:done @urgent\"))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (tags->string (extract-tags \"@status:done @urgent\")) \"@status:done @urgent\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "tags->string", "roundtrip"], "split": "train"}
{"id": "patterns_parse_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRender safely extracted tags where an unsafe path is sanitized away.\n\nEnsure `tags->string` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(tags->string (safe-extract-tags \"@path:../secret @owner:alice\"))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (tags->string (safe-extract-tags \"@path:../secret @owner:alice\")) \"@path: @owner:alice\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "tags->string", "safe-pipeline"], "split": "train"}
{"id": "patterns_parse_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse tags, keep only status/priority, and render the filtered subset.\n\nEnsure `tags->string` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (filter-tags-by-key tags pred)\n  (filter (lambda (pair) (pred (car pair))) tags))\n  (equal? (let* ([tags (extract-tags \"@status:draft @priority:high @owner:bob\")] [filtered (filter-tags-by-key tags (lambda (k) (or (eq? k 'status) (eq? k 'priority))))]) (tags->string filtered)) \"@status:draft @priority:high\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "tags->string", "filtering"], "split": "train"}
{"id": "patterns_parse_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "tags->string", "prompt": "Task mode: compose existing APIs into one expression.\n\nAppend one formatted tag to the rendered base tag string.\n\nEnsure `tags->string` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `tags->string`\n- `extract-tags`\n- `format-tag`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra))", "verify_expr": "(let ()\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (define (tags->string tags)\n  (if (null? tags)\n      \"\"\n      (let loop ([ts tags] [acc \"\"])\n           (if (null? ts)\n               acc\n               (loop (cdr ts)\n                     (string-append acc\n                                    (if (string=? acc \"\") \"\" \" \")\n                                    (format-tag (caar ts) (cdar ts))))))))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (equal? (let* ([tags (extract-tags \"@status:done\")] [base (tags->string tags)] [extra (format-tag 'source \"api\")]) (string-append base \" \" extra)) \"@status:done @source:api\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "tags->string", "concatenation"], "split": "train"}
{"id": "patterns_parse_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nClassify several paths for traversal risk and also include sanitized control value.\n\nEnsure `has-path-traversal?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `has-path-traversal?`\n- `sanitize-tag-value`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe))", "verify_expr": "(let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (equal? (let* ([paths '(\"../secret\" \"docs/readme\" \"/etc/passwd\" \"foo/../bar\" \"file..name\")] [flags (map has-path-traversal? paths)] [safe (sanitize-tag-value \"docs/readme\")]) (list flags safe)) '((#t #f #t #t #f) \"docs/readme\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "has-path-traversal?", "classification"], "split": "train"}
{"id": "patterns_parse_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nSafe-extract tags and check whether sanitized path values still look like traversal.\n\nEnsure `has-path-traversal?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `has-path-traversal?`\n- `safe-extract-tags`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2)))", "verify_expr": "(let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([tags (safe-extract-tags \"@path:../../etc/passwd @ok:docs/readme\")] [p1 (cdr (assq 'path tags))] [p2 (cdr (assq 'ok tags))]) (list (has-path-traversal? p1) (has-path-traversal? p2))) '(#f #f)))", "tags": ["tier1", "query", "patterns-parse", "composition", "has-path-traversal?", "safe-pipeline"], "split": "train"}
{"id": "patterns_parse_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "has-path-traversal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nFormat a path tag as a flag when traversal is detected, otherwise keep the value.\n\nEnsure `has-path-traversal?` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p)))", "verify_expr": "(let ()\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (format-tag key value)\n  (if (eq? value #t)\n      (string-append \"@\" (symbol->string key))\n      (string-append \"@\" (symbol->string key) \":\" value)))\n  (equal? (let ([p \"../x\"]) (if (has-path-traversal? p) (format-tag 'path #t) (format-tag 'path p))) \"@path\"))", "tags": ["tier1", "query", "patterns-parse", "composition", "has-path-traversal?", "conditional"], "split": "train"}
{"id": "patterns_parse_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/patterns-parse.ss", "source_test": "lattice/query/test-patterns-parse.ss", "source_function": "safe-extract-tags", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompare raw extraction vs safe extraction for a path value.\n\nEnsure `safe-extract-tags` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe))))", "verify_expr": "(let ()\n  (define (char-whitespace? c)\n  (or (char=? c #\\space)\n      (char=? c #\\newline)\n      (char=? c #\\tab)\n      (char=? c #\\return)))\n  (define (valid-tag-start? text i)\n  (or (= i 0)\n      (let ([prev-char (string-ref text (- i 1))])\n           (char-whitespace? prev-char))))\n  (define (char-key-start? c)\n  (and (char>=? c #\\a) (char<=? c #\\z)))\n  (define (char-key? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)))\n  (define (char-value? c)\n  (or (and (char>=? c #\\a) (char<=? c #\\z))\n      (and (char>=? c #\\A) (char<=? c #\\Z))\n      (and (char>=? c #\\0) (char<=? c #\\9))\n      (char=? c #\\-)\n      (char=? c #\\.)\n      (char=? c #\\/)\n      (char=? c #\\_)\n      (char=? c #\\:)))\n  (define (string-downcase s)\n  (list->string\n   (map char-downcase (string->list s))))\n  (define (parse-tag-at text i)\n  (let ([len (string-length text)]\n        [start i])\n       (let ([j (+ i 1)])\n            (if (>= j len)\n                #f\n                (let ([first-char (string-ref text j)])\n                     (if (not (char-key-start? first-char))\n                         #f\n                         (let key-loop ([k j])\n                              (if (or (>= k len)\n                                      (not (char-key? (string-ref text k))))\n                                  (if (= k j)\n                                      #f\n                                      (let ([key-str (substring text j k)]\n                                            [key-sym (string->symbol\n                                                      (string-downcase\n                                                       (substring text j k)))])\n                                           (if (and (< k len)\n                                                    (char=? (string-ref text k) #\\:))\n                                               (let value-loop ([v (+ k 1)])\n                                                    (if (or (>= v len)\n                                                            (not (char-value? (string-ref text v))))\n                                                        (if (= v (+ k 1))\n                                                            (list key-sym #f start k)\n                                                            (list key-sym\n                                                                  (substring text (+ k 1) v)\n                                                                  start v))\n                                                        (value-loop (+ v 1))))\n                                               (list key-sym #f start k))))\n                                  (key-loop (+ k 1))))))))))\n  (define (extract-tag-positions text)\n  (let ([len (string-length text)])\n       (let loop ([i 0] [results '()])\n            (if (>= i len)\n                (reverse results)\n                (if (and (char=? (string-ref text i) #\\@)\n                         (valid-tag-start? text i))\n                    (let ([tag-info (parse-tag-at text i)])\n                         (if tag-info\n                             (loop (cadddr tag-info)\n                                   (cons tag-info results))\n                             (loop (+ i 1) results)))\n                    (loop (+ i 1) results))))))\n  (define (extract-tags text)\n  (let ([positions (extract-tag-positions text)])\n       (map (lambda (pos)\n                    (let ([key (car pos)]\n                          [val (cadr pos)])\n                         (cons key (or val #t))))\n            positions)))\n  (define (has-path-traversal? s)\n  (let ([len (string-length s)])\n       (cond\n        [(= len 0) #f]\n        [(char=? (string-ref s 0) #\\/) #t]\n        [else\n         (let loop ([i 0])\n              (cond\n               [(>= i (- len 1)) #f]\n               [(and (char=? (string-ref s i) #\\.)\n                     (char=? (string-ref s (+ i 1)) #\\.))\n                (let ([at-start (= i 0)]\n                      [at-end (>= (+ i 2) len)]\n                      [after-slash (and (> i 0) (char=? (string-ref s (- i 1)) #\\/))]\n                      [before-slash (and (< (+ i 2) len)\n                                         (or (char=? (string-ref s (+ i 2)) #\\/)\n                                             (char=? (string-ref s (+ i 2)) #\\\\)))])\n                     (if (or at-start at-end after-slash before-slash)\n                         #t\n                         (loop (+ i 1))))]\n               [else (loop (+ i 1))]))])))\n  (define (filter pred lst)\n  (cond\n   [(null? lst) '()]\n   [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n   [else (filter pred (cdr lst))]))\n  (define (sanitize-tag-value s)\n  (if (has-path-traversal? s)\n      \"\"\n      (list->string\n       (filter (lambda (c)\n                       (and (char>=? c #\\space)\n                            (char<=? c #\\~)\n                            (not (memv c '(#\\$ #\\` #\\& #\\| #\\; #\\\\)))))\n               (string->list s)))))\n  (define (safe-extract-tags text)\n  (map (lambda (pair)\n               (let ([key (car pair)]\n                     [val (cdr pair)])\n                    (cons key (if (string? val)\n                                  (sanitize-tag-value val)\n                                  val))))\n       (extract-tags text)))\n  (equal? (let* ([raw (extract-tags \"@path:../secret @owner:alice\")] [safe (safe-extract-tags \"@path:../secret @owner:alice\")]) (list (cdr (assq 'path raw)) (cdr (assq 'path safe)))) '(\"../secret\" \"\")))", "tags": ["tier1", "query", "patterns-parse", "composition", "safe-extract-tags", "comparison"], "split": "train"}
