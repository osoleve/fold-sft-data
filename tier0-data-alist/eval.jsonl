{"id": "alist_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-ref/default`\nSpec: Look up key and return default when key is absent.\n\nWrite exactly one Scheme function definition for `alist-ref/default`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-ref/default"], "split": "eval"}
{"id": "alist_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-update`\nSpec: Update key by applying fn to current value (or default when missing), then storing result.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-update"], "split": "eval"}
{"id": "alist_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-keys`\nSpec: Extract keys in current alist order.\n\nWrite exactly one Scheme function definition for `alist-keys`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n(equal? (alist-keys '()) '())\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-keys"], "split": "eval"}
{"id": "alist_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-ref`\n\n```python\ndef alist_ref(alist, key):\n    for k, v in alist:\n        if k is key:\n            return v\n    return False\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n(equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-ref"], "split": "eval"}
{"id": "alist_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-remove`\n\n```python\ndef alist_remove(alist, key):\n    out = []\n    removed = False\n    for pair in alist:\n        if (not removed) and pair[0] is key:\n            removed = True\n            continue\n        out.append(pair)\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n(equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-remove"], "split": "eval"}
{"id": "alist_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-map`\n\n```scheme\n(define (map-values f a)\n  (map (lambda (p) (cons (car p) (f (car p) (cdr p)))) a))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n(equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-map"], "split": "eval"}
{"id": "alist_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-ref` in `lattice/data/alist.ss`.\nKnown issue: Return the value (cdr), not the whole pair.\n\n```scheme\n(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    pair))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n(equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-ref"], "split": "eval"}
{"id": "alist_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-remove` in `lattice/data/alist.ss`.\nKnown issue: Only the first matching key should be removed, not all matches.\n\n```scheme\n(define (alist-remove alist key)\n  (filter (lambda (pair) (not (eq? key (car pair)))) alist))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n(equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-remove"], "split": "eval"}
{"id": "alist_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-map` in `lattice/data/alist.ss`.\nKnown issue: Function arguments are reversed; fn expects (key value).\n\n```scheme\n(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (cdr pair) (car pair))))\n       alist))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n(equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "bugfix", "alist-map"], "split": "eval"}
{"id": "alist_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nLook up key 'b in the alist '((a . 1) (b . 2) (c . 3)).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref '((a . 1) (b . 2) (c . 3)) 'b)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2))", "tags": ["tier0", "data", "alist", "composition", "alist-ref", "direct"], "split": "eval"}
{"id": "alist_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert key 'b => 2 into '((a . 1)) and read back 'b.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-set '((a . 1)) 'b 2) 'b) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-set '((a . 1)) 'b 2) 'b)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-set '((a . 1)) 'b 2) 'b) 2))", "tags": ["tier0", "data", "alist", "composition", "alist-set", "direct"], "split": "eval"}
{"id": "alist_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: small integration task across module primitives.\n\nRemove key 'b from '((a . 1) (b . 2) (c . 3)).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-remove '((a . 1) (b . 2) (c . 3)) 'b)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3))))", "tags": ["tier0", "data", "alist", "composition", "alist-remove", "direct"], "split": "eval"}
{"id": "alist_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge three small alists left-to-right and return final value at 'x.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-merge (alist-merge '((x . 1)) '((y . 2))) '((x . 7))) 'x) 7)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-merge (alist-merge '((x . 1)) '((y . 2))) '((x . 7))) 'x)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-merge (alist-merge '((x . 1)) '((y . 2))) '((x . 7))) 'x) 7))", "tags": ["tier0", "data", "alist", "composition", "alist-merge", "composition"], "split": "eval"}
{"id": "alist_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: small integration task across module primitives.\n\nMap values by adding key-dependent offset, then read value for key 'c.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-map (lambda (k v) (+ v (if (eq? k 'c) 10 0))) '((a . 1) (c . 3))) 'c)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-map (lambda (k v) (+ v (if (eq? k 'c) 10 0))) '((a . 1) (c . 3))) 'c) 13))", "tags": ["tier0", "data", "alist", "composition", "alist-map", "integration"], "split": "eval"}
