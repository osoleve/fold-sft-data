{"id": "alist_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-ref`\nSpec: Look up key with assq/eq? semantics, returning value or #f when key is missing.\n\nWrite exactly one Scheme function definition for `alist-ref`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n(equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-ref"], "split": "train"}
{"id": "alist_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-ref alist key)\n  ;; TODO: return value for key, or #f when missing\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-ref`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n(equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-ref"], "split": "train"}
{"id": "alist_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-ref/default alist key default)\n  ;; TODO: return value for key, or default when missing\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-ref/default`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n(equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-ref/default"], "split": "train"}
{"id": "alist_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-set`\nSpec: Functionally set key to value: replace existing first entry for key or prepend new pair.\n\nWrite exactly one Scheme function definition for `alist-set`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-set"], "split": "train"}
{"id": "alist_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-set alist key value)\n  ;; TODO: set key to value functionally without duplicate key entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-set`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-set"], "split": "train"}
{"id": "alist_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-update alist key fn default)\n  ;; TODO: read current/default value, apply fn, and store updated value\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-update`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n(equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-update"], "split": "train"}
{"id": "alist_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-remove`\nSpec: Remove only the first occurrence of key from alist while preserving order of remaining entries.\n\nWrite exactly one Scheme function definition for `alist-remove`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n(equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-remove"], "split": "train"}
{"id": "alist_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-remove alist key)\n  ;; TODO: remove first entry matching key and keep order for others\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-remove`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-remove"], "split": "train"}
{"id": "alist_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-merge`\nSpec: Merge two alists where entries from b override entries from a on key conflict.\n\nWrite exactly one Scheme function definition for `alist-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'a) 10) (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-merge"], "split": "train"}
{"id": "alist_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-merge a b)\n  ;; TODO: merge with b taking precedence on conflicts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-merge`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'a) 10) (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-merge"], "split": "train"}
{"id": "alist_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-keys alist)\n  ;; TODO: extract key list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-keys`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n(equal? (alist-keys '()) '())\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-keys"], "split": "train"}
{"id": "alist_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/alist.ss\nFunction: `alist-map`\nSpec: Map values with function (key value -> new-value), preserving keys and pair structure.\n\nWrite exactly one Scheme function definition for `alist-map`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n(equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "spec-to-code", "alist-map"], "split": "train"}
{"id": "alist_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-map fn alist)\n  ;; TODO: map values using fn(key, value) while preserving keys\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-map`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "spec-to-code", "skeleton", "alist-map"], "split": "train"}
{"id": "alist_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-ref`\n\n```scheme\n(define (ref a k)\n  (let ([p (assq k a)])\n    (if p (cdr p) #f)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n(equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-ref"], "split": "train"}
{"id": "alist_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-ref/default`\n\n```python\ndef alist_ref_default(alist, key, default):\n    for k, v in alist:\n        if k is key:\n            return v\n    return default\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-ref/default"], "split": "train"}
{"id": "alist_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-ref/default`\n\n```scheme\n(define (ref/default a k d)\n  (let ([p (assq k a)])\n    (if p (cdr p) d)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n(equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-ref/default"], "split": "train"}
{"id": "alist_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-set`\n\n```python\ndef alist_set(alist, key, value):\n    return [(key, value)] + alist_remove(alist, key)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-set"], "split": "train"}
{"id": "alist_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-set`\n\n```scheme\n(define (set-entry a k v)\n  (cons (cons k v) (alist-remove a k)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-set"], "split": "train"}
{"id": "alist_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-update`\n\n```python\ndef alist_update(alist, key, fn, default):\n    cur = alist_ref_default(alist, key, default)\n    return alist_set(alist, key, fn(cur))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n(equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-update"], "split": "train"}
{"id": "alist_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-update`\n\n```scheme\n(define (update-entry a k f d)\n  (let ([cur (alist-ref/default a k d)])\n    (alist-set a k (f cur))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n(equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-update"], "split": "train"}
{"id": "alist_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-remove`\n\n```scheme\n(define (remove-entry a k)\n  (let loop ([rest a] [acc '()])\n    (cond\n      [(null? rest) (reverse acc)]\n      [(eq? k (caar rest)) (append (reverse acc) (cdr rest))]\n      [else (loop (cdr rest) (cons (car rest) acc))])))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-remove"], "split": "train"}
{"id": "alist_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-merge`\n\n```python\ndef alist_merge(a, b):\n    result = a\n    for k, v in b:\n        result = alist_set(result, k, v)\n    return result\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-merge"], "split": "train"}
{"id": "alist_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-merge`\n\n```scheme\n(define (merge-alists a b)\n  (let loop ([rest b] [res a])\n    (if (null? rest)\n        res\n        (loop (cdr rest)\n              (alist-set res (caar rest) (cdar rest))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'a) 10) (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-merge"], "split": "train"}
{"id": "alist_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-keys`\n\n```python\ndef alist_keys(alist):\n    return [k for (k, v) in alist]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n(equal? (alist-keys '()) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-keys"], "split": "train"}
{"id": "alist_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist-keys`\n\n```scheme\n(define (keys a)\n  (map car a))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n(equal? (alist-keys '()) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "translation", "chez", "alist-keys"], "split": "train"}
{"id": "alist_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `alist-map`\n\n```python\ndef alist_map(fn, alist):\n    return [(k, fn(k, v)) for (k, v) in alist]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "translation", "python", "alist-map"], "split": "train"}
{"id": "alist_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-ref` in `lattice/data/alist.ss`.\nKnown issue: Missing keys must return #f, not the empty list.\n\n```scheme\n(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) '())))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (and\n  (equal? (alist-ref '((a . 1) (b . 2) (c . 3)) 'b) 2)\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10)\n  (equal? (alist-ref '() 'z) #f)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-ref"], "split": "train"}
{"id": "alist_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-ref/default` in `lattice/data/alist.ss`.\nKnown issue: Must return the provided default when key is missing.\n\n```scheme\n(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n(equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-ref/default"], "split": "train"}
{"id": "alist_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-ref/default` in `lattice/data/alist.ss`.\nKnown issue: Existing keys must return their stored value, not default.\n\n```scheme\n(define (alist-ref/default alist key default)\n  default)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n(equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (and\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99)\n  (equal? (alist-ref/default '() 'x 0) 0)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-ref/default"], "split": "train"}
{"id": "alist_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-set` in `lattice/data/alist.ss`.\nKnown issue: Existing key entries must be removed to avoid duplicates.\n\n```scheme\n(define (alist-set alist key value)\n  (cons (cons key value) alist))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-set"], "split": "train"}
{"id": "alist_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-set` in `lattice/data/alist.ss`.\nKnown issue: Construct pairs as (key . value), not (value . key).\n\n```scheme\n(define (alist-set alist key value)\n  (cons (cons value key) (alist-remove alist key)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([r (alist-set '((a . 1)) 'b 2)]) (and (equal? (alist-ref r 'a) 1) (equal? (alist-ref r 'b) 2)))\n(let ([r (alist-set '((a . 1) (b . 2)) 'a 10)]) (and (equal? (alist-ref r 'a) 10) (equal? (length r) 2)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (and\n  (let ([r (alist-set '((a . 1)) 'b 2)])\n    (and (equal? (alist-ref r 'a) 1)\n         (equal? (alist-ref r 'b) 2)))\n  (let ([r (alist-set '((a . 1) (b . 2)) 'a 10)])\n    (and (equal? (alist-ref r 'a) 10)\n         (equal? (length r) 2)))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-set"], "split": "train"}
{"id": "alist_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `lattice/data/alist.ss`.\nKnown issue: Must apply fn to current/default value before storing.\n\n```scheme\n(define (alist-update alist key fn default)\n  (alist-set alist key default))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-update"], "split": "train"}
{"id": "alist_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `lattice/data/alist.ss`.\nKnown issue: Missing keys must use the explicit default value, not #f.\n\n```scheme\n(define (alist-update alist key fn default)\n  (let ([current (alist-ref alist key)])\n    (alist-set alist key (fn current))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n(equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))", "verify_expr": "(let ()\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (and\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (+ v 10)) 0) 'b) 10)\n  (equal? (alist-ref (alist-update '() 'x (lambda (v) (* v 2)) 5) 'x) 10)))", "tags": ["tier0", "data", "alist", "bugfix", "alist-update"], "split": "train"}
{"id": "alist_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-remove` in `lattice/data/alist.ss`.\nKnown issue: After removing first match, the remaining tail must be preserved.\n\n```scheme\n(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining))) (reverse acc)]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (and\n  (equal? (alist-remove '((a . 1) (b . 2) (c . 3)) 'b) '((a . 1) (c . 3)))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1)))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3)))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-remove"], "split": "train"}
{"id": "alist_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-merge` in `lattice/data/alist.ss`.\nKnown issue: Entries from b are ignored; merge must upsert each pair from b.\n\n```scheme\n(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining) result))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'a) 10) (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-merge"], "split": "train"}
{"id": "alist_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-merge` in `lattice/data/alist.ss`.\nKnown issue: Conflict resolution is reversed; b must win over a.\n\n```scheme\n(define (alist-merge a b)\n  (let loop ([remaining a] [result b])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result (car (car remaining)) (cdr (car remaining)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'a) 10) (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))", "verify_expr": "(let ()\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))])\n  (and (equal? (alist-ref r 'a) 10)\n       (equal? (alist-ref r 'b) 2)\n       (equal? (alist-ref r 'c) 3))))", "tags": ["tier0", "data", "alist", "bugfix", "alist-merge"], "split": "train"}
{"id": "alist_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-keys` in `lattice/data/alist.ss`.\nKnown issue: Extract keys with car, not values.\n\n```scheme\n(define (alist-keys alist)\n  (map cdr alist))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "bugfix", "alist-keys"], "split": "train"}
{"id": "alist_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-keys` in `lattice/data/alist.ss`.\nKnown issue: Key order should match alist order.\n\n```scheme\n(define (alist-keys alist)\n  (reverse (map car alist)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n(equal? (alist-keys '()) '())\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-keys alist)\n  (map car alist))", "verify_expr": "(let ()\n  (define (alist-keys alist)\n  (map car alist))\n  (and\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c))\n  (equal? (alist-keys '()) '())))", "tags": ["tier0", "data", "alist", "bugfix", "alist-keys"], "split": "train"}
{"id": "alist_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-map` in `lattice/data/alist.ss`.\nKnown issue: Must preserve key/value pair structure in output alist.\n\n```scheme\n(define (alist-map fn alist)\n  (map (lambda (pair)\n         (fn (car pair) (cdr pair)))\n       alist))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n(equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))", "verify_expr": "(let ()\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (and\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1))) '((x . (x 1))))\n  (equal? (alist-map (lambda (k v) v) '()) '())))", "tags": ["tier0", "data", "alist", "bugfix", "alist-map"], "split": "train"}
{"id": "alist_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nLook up missing key 'z and return the not-found sentinel.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref '((a . 1)) 'z) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-ref '((a . 1)) 'z)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref '((a . 1)) 'z) #f))", "tags": ["tier0", "data", "alist", "composition", "alist-ref", "missing"], "split": "train"}
{"id": "alist_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck duplicate-key lookup behavior for '((a . 10) (a . 20)); return first value.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref '((a . 10) (a . 20)) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref '((a . 10) (a . 20)) 'a) 10))", "tags": ["tier0", "data", "alist", "composition", "alist-ref", "duplicates"], "split": "train"}
{"id": "alist_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nSet key 'a to 9, then read it back.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-set '((a . 1) (b . 2)) 'a 9) 'a) 9)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref (alist-set '((a . 1) (b . 2)) 'a 9) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-set '((a . 1) (b . 2)) 'a 9) 'a) 9))", "tags": ["tier0", "data", "alist", "composition", "alist-ref", "integration"], "split": "train"}
{"id": "alist_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead key 'b with default 99 from '((a . 1) (b . 2)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref/default '((a . 1) (b . 2)) 'b 99)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref/default '((a . 1) (b . 2)) 'b 99) 2))", "tags": ["tier0", "data", "alist", "composition", "alist-ref/default", "direct"], "split": "train"}
{"id": "alist_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: small integration task across module primitives.\n\nRead missing key 'z with default 99.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref/default '((a . 1)) 'z 99)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref/default '((a . 1)) 'z 99) 99))", "tags": ["tier0", "data", "alist", "composition", "alist-ref/default", "missing"], "split": "train"}
{"id": "alist_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: compose existing APIs into one expression.\n\nRead key from empty alist with fallback default 7.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-ref/default '() 'x 7)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref/default '() 'x 7) 7))", "tags": ["tier0", "data", "alist", "composition", "alist-ref/default", "edge-case"], "split": "train"}
{"id": "alist_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-ref/default", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove key 'a then read it with default 0.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref/default (alist-remove '((a . 1) (b . 2)) 'a) 'a 0) 0)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-ref/default (alist-remove '((a . 1) (b . 2)) 'a) 'a 0)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref/default (alist-remove '((a . 1) (b . 2)) 'a) 'a 0) 0))", "tags": ["tier0", "data", "alist", "composition", "alist-ref/default", "integration"], "split": "train"}
{"id": "alist_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: compose existing APIs into one expression.\n\nReplace existing key 'a with value 10 and return resulting length.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(length (alist-set '((a . 1) (b . 2)) 'a 10))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (length (alist-set '((a . 1) (b . 2)) 'a 10)) 2))", "tags": ["tier0", "data", "alist", "composition", "alist-set", "replace"], "split": "train"}
{"id": "alist_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply two sets (a=9 then c=3) and return keys order.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-keys (alist-set (alist-set '((a . 1) (b . 2)) 'a 9) 'c 3)) '(c a b))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-keys (alist-set (alist-set '((a . 1) (b . 2)) 'a 9) 'c 3))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-keys (alist-set (alist-set '((a . 1) (b . 2)) 'a 9) 'c 3)) '(c a b)))", "tags": ["tier0", "data", "alist", "composition", "alist-set", "order"], "split": "train"}
{"id": "alist_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-set", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff setting duplicated key 'k makes lookup return the newly written value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-set '((k . 1) (x . 2) (k . 3)) 'k 8) 'k) 8)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (alist-ref (alist-set '((k . 1) (x . 2) (k . 3)) 'k 8) 'k) 8)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-set '((k . 1) (x . 2) (k . 3)) 'k 8) 'k) 8))", "tags": ["tier0", "data", "alist", "composition", "alist-set", "property"], "split": "train"}
{"id": "alist_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: small integration task across module primitives.\n\nIncrement existing key 'a by 10 and return its updated value.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-update '((a . 1) (b . 2)) 'a (lambda (v) (+ v 10)) 0) 'a) 11))", "tags": ["tier0", "data", "alist", "composition", "alist-update", "direct"], "split": "train"}
{"id": "alist_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: small integration task across module primitives.\n\nUpdate missing key 'b using default 5 and fn (* v 2); return new value.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (* v 2)) 5) 'b) 10)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-update '((a . 1)) 'b (lambda (v) (* v 2)) 5) 'b)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-update '((a . 1)) 'b (lambda (v) (* v 2)) 5) 'b) 10))", "tags": ["tier0", "data", "alist", "composition", "alist-update", "default"], "split": "train"}
{"id": "alist_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpdate key 'n twice (+1 then *3) from default 0; return final value.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-update (alist-update '() 'n (lambda (v) (+ v 1)) 0) 'n (lambda (v) (* v 3)) 0) 'n) 3)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-update (alist-update '() 'n (lambda (v) (+ v 1)) 0) 'n (lambda (v) (* v 3)) 0) 'n)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-update (alist-update '() 'n (lambda (v) (+ v 1)) 0) 'n (lambda (v) (* v 3)) 0) 'n) 3))", "tags": ["tier0", "data", "alist", "composition", "alist-update", "composition"], "split": "train"}
{"id": "alist_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-update", "prompt": "Task mode: small integration task across module primitives.\n\nUse update with string append on key 'msg.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-update '((msg . \"hi\")) 'msg (lambda (v) (string-append v \"!\")) \"\") 'msg) \"hi!\")\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref (alist-update '((msg . \"hi\")) 'msg (lambda (v) (string-append v \"!\")) \"\") 'msg)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-update '((msg . \"hi\")) 'msg (lambda (v) (string-append v \"!\")) \"\") 'msg) \"hi!\"))", "tags": ["tier0", "data", "alist", "composition", "alist-update", "string"], "split": "train"}
{"id": "alist_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: small integration task across module primitives.\n\nRemove key 'a from duplicate list and keep only first removal.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-remove '((a . 1) (b . 2) (a . 3)) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-remove '((a . 1) (b . 2) (a . 3)) 'a) '((b . 2) (a . 3))))", "tags": ["tier0", "data", "alist", "composition", "alist-remove", "duplicates"], "split": "train"}
{"id": "alist_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTry removing missing key 'z and return the unchanged alist.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-remove '((a . 1)) 'z)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-remove '((a . 1)) 'z) '((a . 1))))", "tags": ["tier0", "data", "alist", "composition", "alist-remove", "missing"], "split": "train"}
{"id": "alist_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-remove", "prompt": "Task mode: small integration task across module primitives.\n\nSet 'a to 9, then remove 'a, and confirm lookup returns #f.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-ref (alist-remove (alist-set '((a . 1) (b . 2)) 'a 9) 'a) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-remove (alist-set '((a . 1) (b . 2)) 'a 9) 'a) 'a) #f))", "tags": ["tier0", "data", "alist", "composition", "alist-remove", "integration"], "split": "train"}
{"id": "alist_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge disjoint alists and return value for key 'b.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref (alist-merge '((a . 1)) '((b . 2))) 'b)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-merge '((a . 1)) '((b . 2))) 'b) 2))", "tags": ["tier0", "data", "alist", "composition", "alist-merge", "direct"], "split": "train"}
{"id": "alist_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge with conflict on 'a and return merged value for 'a (b must win).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-ref (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3))) 'a) 10)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-ref (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3))) 'a)", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-ref (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3))) 'a) 10))", "tags": ["tier0", "data", "alist", "composition", "alist-merge", "conflict"], "split": "train"}
{"id": "alist_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merge keeps 'b from a and adds 'c from b in this example.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (let ([r (alist-merge '((a . 1) (b . 2)) '((a . 10) (c . 3)))]) (and (equal? (alist-ref r 'b) 2) (equal? (alist-ref r 'c) 3))) #t))", "tags": ["tier0", "data", "alist", "composition", "alist-merge", "property"], "split": "train"}
{"id": "alist_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: small integration task across module primitives.\n\nExtract keys from '((a . 1) (b . 2) (c . 3)).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(alist-keys '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "alist", "composition", "alist-keys", "direct"], "split": "train"}
{"id": "alist_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: small integration task across module primitives.\n\nExtract keys from empty alist.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-keys '())", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-keys '()) '()))", "tags": ["tier0", "data", "alist", "composition", "alist-keys", "edge-case"], "split": "train"}
{"id": "alist_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: compose existing APIs into one expression.\n\nSet key 'z in '((a . 1) (b . 2)) and return resulting key order.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-keys (alist-set '((a . 1) (b . 2)) 'z 9)) '(z a b))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-keys (alist-set '((a . 1) (b . 2)) 'z 9))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-keys (alist-set '((a . 1) (b . 2)) 'z 9)) '(z a b)))", "tags": ["tier0", "data", "alist", "composition", "alist-keys", "order"], "split": "train"}
{"id": "alist_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-keys", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove 'b then return keys.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-keys (alist-remove '((a . 1) (b . 2) (c . 3)) 'b)) '(a c))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-keys (alist-remove '((a . 1) (b . 2) (c . 3)) 'b))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-keys (alist-remove '((a . 1) (b . 2) (c . 3)) 'b)) '(a c)))", "tags": ["tier0", "data", "alist", "composition", "alist-keys", "integration"], "split": "train"}
{"id": "alist_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: compose existing APIs into one expression.\n\nDouble all values in '((a . 1) (b . 2) (c . 3)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-map (lambda (k v) (* v 2)) '((a . 1) (b . 2) (c . 3))) '((a . 2) (b . 4) (c . 6))))", "tags": ["tier0", "data", "alist", "composition", "alist-map", "direct"], "split": "train"}
{"id": "alist_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap each pair to list (key value).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-map (lambda (k v) (list k v)) '((x . 1) (y . 2))) '((x . (x 1)) (y . (y 2))))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(alist-map (lambda (k v) (list k v)) '((x . 1) (y . 2)))", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-map (lambda (k v) (list k v)) '((x . 1) (y . 2))) '((x . (x 1)) (y . (y 2)))))", "tags": ["tier0", "data", "alist", "composition", "alist-map", "key-aware"], "split": "train"}
{"id": "alist_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/alist.ss", "source_test": "lattice/data/test-alist.ss", "source_function": "alist-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap over empty alist and return result.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (alist-map (lambda (k v) v) '()) '())\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(alist-map (lambda (k v) v) '())", "verify_expr": "(let ()\n  (define (alist-ref alist key)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) #f)))\n  (define (alist-ref/default alist key default)\n  (let ([pair (assq key alist)])\n    (if pair (cdr pair) default)))\n  (define (alist-set alist key value)\n  (cons (cons key value) (alist-remove alist key)))\n  (define (alist-update alist key fn default)\n  (let ([current (alist-ref/default alist key default)])\n    (alist-set alist key (fn current))))\n  (define (alist-remove alist key)\n  (let loop ([remaining alist] [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(eq? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (alist-merge a b)\n  (let loop ([remaining b] [result a])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (alist-set result\n                         (car (car remaining))\n                         (cdr (car remaining)))))))\n  (define (alist-keys alist)\n  (map car alist))\n  (define (alist-map fn alist)\n  (map (lambda (pair)\n         (cons (car pair) (fn (car pair) (cdr pair))))\n       alist))\n  (equal? (alist-map (lambda (k v) v) '()) '()))", "tags": ["tier0", "data", "alist", "composition", "alist-map", "edge-case"], "split": "train"}
