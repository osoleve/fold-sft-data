{"id": "fp_parsing_parser_compile_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `advance-pos-range`\nSpec: Advance parser position over input[from..to), including newline-aware line/column updates.\n\nWrite exactly one Scheme function definition for `advance-pos-range`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "advance-pos-range"], "split": "eval"}
{"id": "fp_parsing_parser_compile_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `regex-ast->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Translate regex AST into composable parser combinators preserving AST semantics.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex-ast->parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "regex-ast->parser"], "split": "eval"}
{"id": "fp_parsing_parser_compile_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex->combinator-parser`\nSpec: Compile regex string via AST translation; return parser-fail on invalid regex.\n\nWrite exactly one Scheme function definition for `regex->combinator-parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "regex->combinator-parser"], "split": "eval"}
{"id": "fp_parsing_parser_compile_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `compiled-regex-parse` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Run parser from compiled-regex against input and return parser result.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compiled-regex-parse`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "compiled-regex-parse"], "split": "eval"}
{"id": "fp_parsing_parser_compile_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `advance-pos-range`.\nReturn only the Scheme definition.\n\n```python\ndef advance_pos_range(pos, input_s, frm, to):\n    i, p = frm, pos\n    while i < to:\n        p = advance_pos(p, input_s[i])\n        i += 1\n    return p\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "advance-pos-range"], "split": "eval"}
{"id": "fp_parsing_parser_compile_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex-ast->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex-ast->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_ast_to_parser(ast):\n    if regex_empty_q(ast):\n        return parser_pure(\"\")\n    if regex_lit_q(ast):\n        return parser_map(str, parser_char(regex_lit_char(ast)))\n    if regex_dot_q(ast):\n        return parser_map(str, parser_any_char)\n    if regex_class_q(ast):\n        chars = regex_class_chars(ast)\n        neg = regex_class_negated_q(ast)\n        pred = (lambda c: c not in chars) if neg else (lambda c: c in chars)\n        return parser_map(str, parser_satisfy(pred, \"character class\"))\n    if regex_seq_q(ast):\n        return fold_concat(map(regex_ast_to_parser, regex_seq_exprs(ast)))\n    if regex_alt_q(ast):\n        return parser_choice([parser_try(regex_ast_to_parser(e)) for e in regex_alt_exprs(ast)])\n    if regex_star_q(ast):\n        inner = regex_ast_to_parser(regex_star_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_many(inner))\n    if regex_plus_q(ast):\n        inner = regex_ast_to_parser(regex_plus_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_some(inner))\n    if regex_opt_q(ast):\n        return parser_optional(regex_ast_to_parser(regex_opt_expr(ast)), \"\")\n    if regex_group_q(ast):\n        return regex_ast_to_parser(regex_group_expr(ast))\n    if regex_repeat_q(ast):\n        return compile_repeat_to_parser(regex_ast_to_parser(regex_repeat_expr(ast)), regex_repeat_min(ast), regex_repeat_max(ast))\n    return parser_fail(\"unsupported regex AST node\")\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "regex-ast->parser"], "split": "eval"}
{"id": "fp_parsing_parser_compile_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex->combinator-parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_to_combinator_parser(pattern):\n    result = regex_parse(pattern)\n    if is_left(result):\n        return parser_fail(\"invalid regex: \" + error_message(from_left(result)))\n    return regex_ast_to_parser(from_right(result))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "regex->combinator-parser"], "split": "eval"}
{"id": "fp_parsing_parser_compile_translation_024", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compiled-regex-parse`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compiled-regex-parse`.\nReturn only the final Scheme definition.\n\n```python\ndef compiled_regex_parse(crx, input_s):\n    return parser_parse(compiled_regex_parser(crx), input_s)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "compiled-regex-parse"], "split": "eval"}
{"id": "fp_parsing_parser_compile_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `advance-pos-range` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Range advancement must include the character at `from`; this skips the first consumed character.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  (let loop ([i (+ from 1)] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2)))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "advance-pos-range"], "split": "eval"}
{"id": "fp_parsing_parser_compile_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: regex->parser must use DFA-backed longest-prefix semantics, not ordered combinator alternation semantics.\n\n```scheme\n(define (regex->parser pattern)\n  (regex->combinator-parser pattern))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex->parser"], "split": "eval"}
{"id": "fp_parsing_parser_compile_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compiled-regex-parse` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compiled-regex-parse must return parser result payload, not a boolean matcher result.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  (compiled-regex-matches? crx input))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compiled-regex-parse"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: small integration task across module primitives.\n\nAdvance position over the first two characters of \"abc\" and return resulting column.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p))", "verify_expr": "(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "advance-pos-range", "column"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn longest-prefix result for pattern `a|ab` on input `ab!`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "dfa->parser", "longest"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile repeat `{0,0}` over parser for `a` and return parsed prefix from `bbb`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-repeat-to-parser", "zero-zero"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: small integration task across module primitives.\n\nParse `color` and `colour` variants with regex parser `colou?r` and return whether both succeed.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\")))", "verify_expr": "(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->parser", "optional"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile regex `a|ab` and return parsed prefix from compiled parser on `ab!`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-regex", "longest"], "split": "eval"}
{"id": "fp_parsing_parser_compile_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: small integration task across module primitives.\n\nUse compiled-regex-parse on `[a-z]+` and return parsed prefix from `hello world`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compiled-regex-parse", "letters"], "split": "eval"}
