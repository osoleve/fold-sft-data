{"id": "fp_parsing_parser_compile_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex->combinator-parser`\nSpec: Compile regex string via AST translation; return parser-fail on invalid regex.\n\nWrite exactly one Scheme function definition for `regex->combinator-parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\") (equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex->combinator-parser`\nSpec: Compile regex string via AST translation; return parser-fail on invalid regex.\n\nWrite exactly one Scheme function definition for `regex->combinator-parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  ;; TODO: parse regex; return parser-fail on error; otherwise translate AST\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex->combinator-parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t) (equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  ;; TODO: parse regex; return parser-fail on error; otherwise translate AST\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex->combinator-parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `regex->combinator-parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile regex string via AST translation; return parser-fail on invalid regex.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex->combinator-parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `regex->combinator-parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile regex string via AST translation; return parser-fail on invalid regex.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex->combinator-parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```"}
{"id": "fp_parsing_parser_compile_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex->combinator-parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_to_combinator_parser(pattern):\n    result = regex_parse(pattern)\n    if is_left(result):\n        return parser_fail(\"invalid regex: \" + error_message(from_left(result)))\n    return regex_ast_to_parser(from_right(result))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\") (equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex->combinator-parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_to_combinator_parser(pattern):\n    result = regex_parse(pattern)\n    if is_left(result):\n        return parser_fail(\"invalid regex: \" + error_message(from_left(result)))\n    return regex_ast_to_parser(from_right(result))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```"}
{"id": "fp_parsing_parser_compile_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex->combinator-parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex->comb-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \"\n                                    (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t) (equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex->combinator-parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex->comb-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \"\n                                    (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```"}
{"id": "fp_parsing_parser_compile_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex->combinator-parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex->combinator-parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_to_combinator_parser(pattern):\n    result = regex_parse(pattern)\n    if is_left(result):\n        return parser_fail(\"invalid regex: \" + error_message(from_left(result)))\n    return regex_ast_to_parser(from_right(result))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex->combinator-parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex->combinator-parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_to_combinator_parser(pattern):\n    result = regex_parse(pattern)\n    if is_left(result):\n        return parser_fail(\"invalid regex: \" + error_message(from_left(result)))\n    return regex_ast_to_parser(from_right(result))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->combinator-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Combinator parser must preserve parser-combinator alternation behavior rather than DFA-longest semantics.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex->parser pattern))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Combinator parser must preserve parser-combinator alternation behavior rather than DFA-longest semantics.\n\nExpected behavior after patch:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t) (equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->combinator-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Combinator parser must preserve parser-combinator alternation behavior rather than DFA-longest semantics.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex->parser pattern))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Combinator parser must preserve parser-combinator alternation behavior rather than DFA-longest semantics.\n\nExpected behavior after patch:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->combinator-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Invalid regex should produce parser-fail (parse-time error), not throw an immediate host exception.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-pure \"\")\n        (regex-ast->parser (from-right result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```", "ground_truth": "(define (regex->combinator-parser pattern)\n  (doc 'export #t)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-fail (string-append \"invalid regex: \" (error-message (from-left result))))\n        (regex-ast->parser (from-right result)))))", "verify_expr": "(and (let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (and (right? r1) (equal? (from-right r1) \"a\") (left? r2) (left? r3))) (equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex->combinator-parser"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->combinator-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Invalid regex should produce parser-fail (parse-time error), not throw an immediate host exception.\n\n```scheme\n(define (regex->combinator-parser pattern)\n  (let ([result (regex-parse pattern)])\n    (if (left? result)\n        (parser-pure \"\")\n        (regex-ast->parser (from-right result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (right? r1))\n(let* ([p (regex->combinator-parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"b!\")] [bad (regex->combinator-parser \"[\")] [r3 (parser-parse bad \"x\")]) (equal? (from-right r1) \"a\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")\n```"}
{"id": "fp_parsing_parser_compile_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: small integration task across module primitives.\n\nAdvance position over the first two characters of \"abc\" and return resulting column.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p))", "verify_expr": "(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "advance-pos-range", "column"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nAdvance position over the first two characters of \"abc\" and return resulting column.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn longest-prefix result for pattern `a|ab` on input `ab!`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "dfa->parser", "longest"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn longest-prefix result for pattern `a|ab` on input `ab!`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: small integration task across module primitives.\n\nCompile star AST over `a` and return parsed prefix from `aaab`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex-ast->parser", "star"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompile star AST over `a` and return parsed prefix from `aaab`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile repeat `{0,0}` over parser for `a` and return parsed prefix from `bbb`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-repeat-to-parser", "zero-zero"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile repeat `{0,0}` over parser for `a` and return parsed prefix from `bbb`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: small integration task across module primitives.\n\nParse `color` and `colour` variants with regex parser `colou?r` and return whether both succeed.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\")))", "verify_expr": "(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->parser", "optional"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse `color` and `colour` variants with regex parser `colou?r` and return whether both succeed.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile regex `a|ab` and return parsed prefix from compiled parser on `ab!`.\n\nEnsure `compile-regex` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-regex", "longest"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile regex `a|ab` and return parsed prefix from compiled parser on `ab!`.\n\nEnsure `compile-regex` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether compiled-regex-parse fails on non-matching input for `[0-9]+`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r))", "verify_expr": "(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compiled-regex-parse", "failure"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether compiled-regex-parse fails on non-matching input for `[0-9]+`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse compiled-regex-parse on `a|ab` and return longest-prefix parse result for `ab!`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compiled-regex-parse`\n- `compile-regex`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compiled-regex-parse", "longest"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nUse compiled-regex-parse on `a|ab` and return longest-prefix parse result for `ab!`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compiled-regex-parse`\n- `compile-regex`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: small integration task across module primitives.\n\nUse compiled-regex-parse on `[a-z]+` and return parsed prefix from `hello world`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compiled-regex-parse", "letters"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nUse compiled-regex-parse on `[a-z]+` and return parsed prefix from `hello world`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
