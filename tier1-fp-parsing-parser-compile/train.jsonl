{"id": "fp_parsing_parser_compile_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `advance-pos-range`\nSpec: Advance parser position over input[from..to), including newline-aware line/column updates.\n\nWrite exactly one Scheme function definition for `advance-pos-range`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t) (= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `advance-pos-range`\nSpec: Advance parser position over input[from..to), including newline-aware line/column updates.\n\nWrite exactly one Scheme function definition for `advance-pos-range`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  ;; TODO: advance parser position from index `from` to `to` (exclusive)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `advance-pos-range`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3) (equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  ;; TODO: advance parser position from index `from` to `to` (exclusive)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `advance-pos-range`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `advance-pos-range` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Advance parser position over input[from..to), including newline-aware line/column updates.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `advance-pos-range`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2)) (equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `advance-pos-range` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Advance parser position over input[from..to), including newline-aware line/column updates.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `advance-pos-range`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `dfa->parser`\nSpec: Wrap DFA/NFA as parser that returns longest accepting prefix and parse error otherwise.\n\nWrite exactly one Scheme function definition for `dfa->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "dfa->parser"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `dfa->parser`\nSpec: Wrap DFA/NFA as parser that returns longest accepting prefix and parse error otherwise.\n\nWrite exactly one Scheme function definition for `dfa->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dfa->parser fsm desc)\n  ;; TODO: build parser that tracks longest accepting prefix over DFA transitions\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dfa->parser`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "dfa->parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dfa->parser fsm desc)\n  ;; TODO: build parser that tracks longest accepting prefix over DFA transitions\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dfa->parser`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `dfa->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Wrap DFA/NFA as parser that returns longest accepting prefix and parse error otherwise.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `dfa->parser`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\") (equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "dfa->parser"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `dfa->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Wrap DFA/NFA as parser that returns longest accepting prefix and parse error otherwise.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `dfa->parser`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex-ast->parser`\nSpec: Translate regex AST into composable parser combinators preserving AST semantics.\n\nWrite exactly one Scheme function definition for `regex-ast->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex-ast->parser`\nSpec: Translate regex AST into composable parser combinators preserving AST semantics.\n\nWrite exactly one Scheme function definition for `regex-ast->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex-ast->parser ast)\n  ;; TODO: map regex AST constructors into parser combinator behavior\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex-ast->parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t) (equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex-ast->parser ast)\n  ;; TODO: map regex AST constructors into parser combinator behavior\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex-ast->parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `regex-ast->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Translate regex AST into composable parser combinators preserving AST semantics.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex-ast->parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\") (equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `regex-ast->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Translate regex AST into composable parser combinators preserving AST semantics.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex-ast->parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compile-repeat-to-parser`\nSpec: Compile repeat bounds (min,max) to parser combinator forms for exact/range/unbounded repetition.\n\nWrite exactly one Scheme function definition for `compile-repeat-to-parser`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compile-repeat-to-parser`\nSpec: Compile repeat bounds (min,max) to parser combinator forms for exact/range/unbounded repetition.\n\nWrite exactly one Scheme function definition for `compile-repeat-to-parser`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  ;; TODO: implement {0,0}, {0,}, exact, at-least, and bounded range forms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat-to-parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\") (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  ;; TODO: implement {0,0}, {0,}, exact, at-least, and bounded range forms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat-to-parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat-to-parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile repeat bounds (min,max) to parser combinator forms for exact/range/unbounded repetition.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compile-repeat-to-parser`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\") (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat-to-parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile repeat bounds (min,max) to parser combinator forms for exact/range/unbounded repetition.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compile-repeat-to-parser`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex->parser`\nSpec: Compile regex string to DFA-backed longest-prefix parser.\n\nWrite exactly one Scheme function definition for `regex->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "regex->parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `regex->parser`\nSpec: Compile regex string to DFA-backed longest-prefix parser.\n\nWrite exactly one Scheme function definition for `regex->parser`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex->parser pattern)\n  ;; TODO: compile regex string to DFA-backed parser\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex->parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "regex->parser"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (regex->parser pattern)\n  ;; TODO: compile regex string to DFA-backed parser\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `regex->parser`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `regex->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile regex string to DFA-backed longest-prefix parser.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex->parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\") (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "regex->parser"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `regex->parser` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Compile regex string to DFA-backed longest-prefix parser.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `regex->parser`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compile-regex`\nSpec: Build compiled-regex dual form with pattern, AST, minimized DFA, and DFA-backed parser.\n\nWrite exactly one Scheme function definition for `compile-regex`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t) (equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "compile-regex"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compile-regex`\nSpec: Build compiled-regex dual form with pattern, AST, minimized DFA, and DFA-backed parser.\n\nWrite exactly one Scheme function definition for `compile-regex`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-regex pattern)\n  ;; TODO: compile regex into dual form (pattern ast dfa parser)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-regex`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t) (equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "compile-regex"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-regex pattern)\n  ;; TODO: compile regex into dual form (pattern ast dfa parser)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-regex`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-regex` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Build compiled-regex dual form with pattern, AST, minimized DFA, and DFA-backed parser.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compile-regex`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "compile-regex"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-regex` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Build compiled-regex dual form with pattern, AST, minimized DFA, and DFA-backed parser.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compile-regex`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compiled-regex-parse`\nSpec: Run parser from compiled-regex against input and return parser result.\n\nWrite exactly one Scheme function definition for `compiled-regex-parse`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "spec-to-code", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this parser-compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/parser-compile.ss\nFunction: `compiled-regex-parse`\nSpec: Run parser from compiled-regex against input and return parser result.\n\nWrite exactly one Scheme function definition for `compiled-regex-parse`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  ;; TODO: parse input with compiled-regex parser\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compiled-regex-parse`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\") (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "skeleton-completion", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  ;; TODO: parse input with compiled-regex parser\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compiled-regex-parse`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```"}
{"id": "fp_parsing_parser_compile_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `compiled-regex-parse` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Run parser from compiled-regex against input and return parser result.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compiled-regex-parse`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "contract-implementation", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `compiled-regex-parse` from this parser-compile contract.\n\nModule: `lattice/fp/parsing/parser-compile.ss`\nContract focus: Run parser from compiled-regex against input and return parser result.\n\nRequirements:\n1. Preserve parser semantics and error behavior.\n2. Keep exact function name/signature for `compiled-regex-parse`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `advance-pos-range`.\nReturn only the Scheme definition.\n\n```python\ndef advance_pos_range(pos, input_s, frm, to):\n    i, p = frm, pos\n    while i < to:\n        p = advance_pos(p, input_s[i])\n        i += 1\n    return p\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t) (equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `advance-pos-range`.\nReturn only the Scheme definition.\n\n```python\ndef advance_pos_range(pos, input_s, frm, to):\n    i, p = frm, pos\n    while i < to:\n        p = advance_pos(p, input_s[i])\n        i += 1\n    return p\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `advance-pos-range`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (advance-pos-range* pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to)\n        p\n        (loop (+ i 1)\n              (advance-pos p (string-ref input i))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3) (equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2)))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `advance-pos-range`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (advance-pos-range* pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to)\n        p\n        (loop (+ i 1)\n              (advance-pos p (string-ref input i))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```"}
{"id": "fp_parsing_parser_compile_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `advance-pos-range`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `advance-pos-range`.\nReturn only the final Scheme definition.\n\n```python\ndef advance_pos_range(pos, input_s, frm, to):\n    i, p = frm, pos\n    while i < to:\n        p = advance_pos(p, input_s[i])\n        i += 1\n    return p\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2)) (= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `advance-pos-range`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `advance-pos-range`.\nReturn only the final Scheme definition.\n\n```python\ndef advance_pos_range(pos, input_s, frm, to):\n    i, p = frm, pos\n    while i < to:\n        p = advance_pos(p, input_s[i])\n        i += 1\n    return p\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(= (let* ([st (parser-initial-state \"abc\")] [p (advance-pos-range (parser-state-pos st) \"abc\" 0 2)]) (pos-col p)) 3)\n```"}
{"id": "fp_parsing_parser_compile_translation_004", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `dfa->parser`.\nReturn only the Scheme definition.\n\n```python\ndef dfa_to_parser(fsm, desc):\n    automaton = fsm if fsm_deterministic_q(fsm) else fsm_minimize(nfa_to_dfa(fsm))\n    def run(state):\n        input_s, start, pos = state.input, state.index, state.pos\n        idx = start\n        current = fsm_start(automaton)\n        accepting = set(fsm_accepting(automaton))\n        last_accept = start if current in accepting else None\n        while idx < len(input_s):\n            next_states = fsm_delta(automaton, current, input_s[idx])\n            if not next_states:\n                break\n            current = next_states[0]\n            idx += 1\n            if current in accepting:\n                last_accept = idx\n        if last_accept is None:\n            return parse_error(pos, f\"expected {desc}\")\n        matched = input_s[start:last_accept]\n        new_pos = advance_pos_range(pos, input_s, start, last_accept)\n        return ok(matched, state_with(input_s, last_accept, new_pos))\n    return make_parser(run)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "dfa->parser"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `dfa->parser`.\nReturn only the Scheme definition.\n\n```python\ndef dfa_to_parser(fsm, desc):\n    automaton = fsm if fsm_deterministic_q(fsm) else fsm_minimize(nfa_to_dfa(fsm))\n    def run(state):\n        input_s, start, pos = state.input, state.index, state.pos\n        idx = start\n        current = fsm_start(automaton)\n        accepting = set(fsm_accepting(automaton))\n        last_accept = start if current in accepting else None\n        while idx < len(input_s):\n            next_states = fsm_delta(automaton, current, input_s[idx])\n            if not next_states:\n                break\n            current = next_states[0]\n            idx += 1\n            if current in accepting:\n                last_accept = idx\n        if last_accept is None:\n            return parse_error(pos, f\"expected {desc}\")\n        matched = input_s[start:last_accept]\n        new_pos = advance_pos_range(pos, input_s, start, last_accept)\n        return ok(matched, state_with(input_s, last_accept, new_pos))\n    return make_parser(run)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```"}
{"id": "fp_parsing_parser_compile_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dfa->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (dfa-parser fsm desc)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start] [current init]\n                    [last (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last\n                   (let* ([m (substring input start last)]\n                          [np (advance-pos-range (parser-state-pos state) input start last)])\n                     (right (cons m (parser-make-state input last np))))\n                   (left (make-parse-error (parser-state-pos state)\n                                           (string-append \"expected \" desc)\n                                           (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last\n                         (let* ([m (substring input start last)]\n                                [np (advance-pos-range (parser-state-pos state) input start last)])\n                           (right (cons m (parser-make-state input last np))))\n                         (left (make-parse-error (parser-state-pos state)\n                                                 (string-append \"expected \" desc)\n                                                 (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1) next\n                             (if (pair? (memq next acc)) (+ idx 1) last)))))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "dfa->parser"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dfa->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (dfa-parser fsm desc)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start] [current init]\n                    [last (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last\n                   (let* ([m (substring input start last)]\n                          [np (advance-pos-range (parser-state-pos state) input start last)])\n                     (right (cons m (parser-make-state input last np))))\n                   (left (make-parse-error (parser-state-pos state)\n                                           (string-append \"expected \" desc)\n                                           (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last\n                         (let* ([m (substring input start last)]\n                                [np (advance-pos-range (parser-state-pos state) input start last)])\n                           (right (cons m (parser-make-state input last np))))\n                         (left (make-parse-error (parser-state-pos state)\n                                                 (string-append \"expected \" desc)\n                                                 (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1) next\n                             (if (pair? (memq next acc)) (+ idx 1) last)))))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"a|ab\") \"alt\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `dfa->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `dfa->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef dfa_to_parser(fsm, desc):\n    automaton = fsm if fsm_deterministic_q(fsm) else fsm_minimize(nfa_to_dfa(fsm))\n    def run(state):\n        input_s, start, pos = state.input, state.index, state.pos\n        idx = start\n        current = fsm_start(automaton)\n        accepting = set(fsm_accepting(automaton))\n        last_accept = start if current in accepting else None\n        while idx < len(input_s):\n            next_states = fsm_delta(automaton, current, input_s[idx])\n            if not next_states:\n                break\n            current = next_states[0]\n            idx += 1\n            if current in accepting:\n                last_accept = idx\n        if last_accept is None:\n            return parse_error(pos, f\"expected {desc}\")\n        matched = input_s[start:last_accept]\n        new_pos = advance_pos_range(pos, input_s, start, last_accept)\n        return ok(matched, state_with(input_s, last_accept, new_pos))\n    return make_parser(run)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\") (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "dfa->parser"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `dfa->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `dfa->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef dfa_to_parser(fsm, desc):\n    automaton = fsm if fsm_deterministic_q(fsm) else fsm_minimize(nfa_to_dfa(fsm))\n    def run(state):\n        input_s, start, pos = state.input, state.index, state.pos\n        idx = start\n        current = fsm_start(automaton)\n        accepting = set(fsm_accepting(automaton))\n        last_accept = start if current in accepting else None\n        while idx < len(input_s):\n            next_states = fsm_delta(automaton, current, input_s[idx])\n            if not next_states:\n                break\n            current = next_states[0]\n            idx += 1\n            if current in accepting:\n                last_accept = idx\n        if last_accept is None:\n            return parse_error(pos, f\"expected {desc}\")\n        matched = input_s[start:last_accept]\n        new_pos = advance_pos_range(pos, input_s, start, last_accept)\n        return ok(matched, state_with(input_s, last_accept, new_pos))\n    return make_parser(run)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex-ast->parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_ast_to_parser(ast):\n    if regex_empty_q(ast):\n        return parser_pure(\"\")\n    if regex_lit_q(ast):\n        return parser_map(str, parser_char(regex_lit_char(ast)))\n    if regex_dot_q(ast):\n        return parser_map(str, parser_any_char)\n    if regex_class_q(ast):\n        chars = regex_class_chars(ast)\n        neg = regex_class_negated_q(ast)\n        pred = (lambda c: c not in chars) if neg else (lambda c: c in chars)\n        return parser_map(str, parser_satisfy(pred, \"character class\"))\n    if regex_seq_q(ast):\n        return fold_concat(map(regex_ast_to_parser, regex_seq_exprs(ast)))\n    if regex_alt_q(ast):\n        return parser_choice([parser_try(regex_ast_to_parser(e)) for e in regex_alt_exprs(ast)])\n    if regex_star_q(ast):\n        inner = regex_ast_to_parser(regex_star_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_many(inner))\n    if regex_plus_q(ast):\n        inner = regex_ast_to_parser(regex_plus_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_some(inner))\n    if regex_opt_q(ast):\n        return parser_optional(regex_ast_to_parser(regex_opt_expr(ast)), \"\")\n    if regex_group_q(ast):\n        return regex_ast_to_parser(regex_group_expr(ast))\n    if regex_repeat_q(ast):\n        return compile_repeat_to_parser(regex_ast_to_parser(regex_repeat_expr(ast)), regex_repeat_min(ast), regex_repeat_max(ast))\n    return parser_fail(\"unsupported regex AST node\")\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex-ast->parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_ast_to_parser(ast):\n    if regex_empty_q(ast):\n        return parser_pure(\"\")\n    if regex_lit_q(ast):\n        return parser_map(str, parser_char(regex_lit_char(ast)))\n    if regex_dot_q(ast):\n        return parser_map(str, parser_any_char)\n    if regex_class_q(ast):\n        chars = regex_class_chars(ast)\n        neg = regex_class_negated_q(ast)\n        pred = (lambda c: c not in chars) if neg else (lambda c: c in chars)\n        return parser_map(str, parser_satisfy(pred, \"character class\"))\n    if regex_seq_q(ast):\n        return fold_concat(map(regex_ast_to_parser, regex_seq_exprs(ast)))\n    if regex_alt_q(ast):\n        return parser_choice([parser_try(regex_ast_to_parser(e)) for e in regex_alt_exprs(ast)])\n    if regex_star_q(ast):\n        inner = regex_ast_to_parser(regex_star_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_many(inner))\n    if regex_plus_q(ast):\n        inner = regex_ast_to_parser(regex_plus_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_some(inner))\n    if regex_opt_q(ast):\n        return parser_optional(regex_ast_to_parser(regex_opt_expr(ast)), \"\")\n    if regex_group_q(ast):\n        return regex_ast_to_parser(regex_group_expr(ast))\n    if regex_repeat_q(ast):\n        return compile_repeat_to_parser(regex_ast_to_parser(regex_repeat_expr(ast)), regex_repeat_min(ast), regex_repeat_max(ast))\n    return parser_fail(\"unsupported regex AST node\")\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")\n```"}
{"id": "fp_parsing_parser_compile_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex-ast->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex-ast->parser* ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)] [neg? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy (if neg?\n                            (lambda (c) (not (pair? (memv c chars))))\n                            (lambda (c) (pair? (memv c chars))))\n                       \"character class\")))]\n   [(regex-seq? ast)\n    (let ([ps (map regex-ast->parser* (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 ps))]\n   [(regex-alt? ast)\n    (parser-choice\n     (map (lambda (e) (parser-try (regex-ast->parser* e)))\n          (regex-alt-exprs ast)))]\n   [else (parser-fail \"unsupported regex AST node\")]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex-ast->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex-ast->parser* ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)] [neg? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy (if neg?\n                            (lambda (c) (not (pair? (memv c chars))))\n                            (lambda (c) (pair? (memv c chars))))\n                       \"character class\")))]\n   [(regex-seq? ast)\n    (let ([ps (map regex-ast->parser* (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 ps))]\n   [(regex-alt? ast)\n    (parser-choice\n     (map (lambda (e) (parser-try (regex-ast->parser* e)))\n          (regex-alt-exprs ast)))]\n   [else (parser-fail \"unsupported regex AST node\")]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex-ast->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex-ast->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_ast_to_parser(ast):\n    if regex_empty_q(ast):\n        return parser_pure(\"\")\n    if regex_lit_q(ast):\n        return parser_map(str, parser_char(regex_lit_char(ast)))\n    if regex_dot_q(ast):\n        return parser_map(str, parser_any_char)\n    if regex_class_q(ast):\n        chars = regex_class_chars(ast)\n        neg = regex_class_negated_q(ast)\n        pred = (lambda c: c not in chars) if neg else (lambda c: c in chars)\n        return parser_map(str, parser_satisfy(pred, \"character class\"))\n    if regex_seq_q(ast):\n        return fold_concat(map(regex_ast_to_parser, regex_seq_exprs(ast)))\n    if regex_alt_q(ast):\n        return parser_choice([parser_try(regex_ast_to_parser(e)) for e in regex_alt_exprs(ast)])\n    if regex_star_q(ast):\n        inner = regex_ast_to_parser(regex_star_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_many(inner))\n    if regex_plus_q(ast):\n        inner = regex_ast_to_parser(regex_plus_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_some(inner))\n    if regex_opt_q(ast):\n        return parser_optional(regex_ast_to_parser(regex_opt_expr(ast)), \"\")\n    if regex_group_q(ast):\n        return regex_ast_to_parser(regex_group_expr(ast))\n    if regex_repeat_q(ast):\n        return compile_repeat_to_parser(regex_ast_to_parser(regex_repeat_expr(ast)), regex_repeat_min(ast), regex_repeat_max(ast))\n    return parser_fail(\"unsupported regex AST node\")\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\") (equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex-ast->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex-ast->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_ast_to_parser(ast):\n    if regex_empty_q(ast):\n        return parser_pure(\"\")\n    if regex_lit_q(ast):\n        return parser_map(str, parser_char(regex_lit_char(ast)))\n    if regex_dot_q(ast):\n        return parser_map(str, parser_any_char)\n    if regex_class_q(ast):\n        chars = regex_class_chars(ast)\n        neg = regex_class_negated_q(ast)\n        pred = (lambda c: c not in chars) if neg else (lambda c: c in chars)\n        return parser_map(str, parser_satisfy(pred, \"character class\"))\n    if regex_seq_q(ast):\n        return fold_concat(map(regex_ast_to_parser, regex_seq_exprs(ast)))\n    if regex_alt_q(ast):\n        return parser_choice([parser_try(regex_ast_to_parser(e)) for e in regex_alt_exprs(ast)])\n    if regex_star_q(ast):\n        inner = regex_ast_to_parser(regex_star_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_many(inner))\n    if regex_plus_q(ast):\n        inner = regex_ast_to_parser(regex_plus_expr(ast))\n        return parser_map(lambda parts: \"\".join(parts), parser_some(inner))\n    if regex_opt_q(ast):\n        return parser_optional(regex_ast_to_parser(regex_opt_expr(ast)), \"\")\n    if regex_group_q(ast):\n        return regex_ast_to_parser(regex_group_expr(ast))\n    if regex_repeat_q(ast):\n        return compile_repeat_to_parser(regex_ast_to_parser(regex_repeat_expr(ast)), regex_repeat_min(ast), regex_repeat_max(ast))\n    return parser_fail(\"unsupported regex AST node\")\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat-to-parser`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat_to_parser(inner, mn, mx):\n    if mn == 0 and mx == 0:\n        return parser_pure(\"\")\n    if mn == 0 and mx is None:\n        return parser_map(\"\".join, parser_many(inner))\n    if mn == mx:\n        return parser_map(\"\".join, parser_count(mn, inner))\n    if mx is None:\n        return parser_map(\"\".join, at_least(mn, inner))\n    return parser_map(\"\".join, range_of(mn, mx, inner))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat-to-parser`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat_to_parser(inner, mn, mx):\n    if mn == 0 and mx == 0:\n        return parser_pure(\"\")\n    if mn == 0 and mx is None:\n        return parser_map(\"\".join, parser_many(inner))\n    if mn == mx:\n        return parser_map(\"\".join, parser_count(mn, inner))\n    if mx is None:\n        return parser_map(\"\".join, at_least(mn, inner))\n    return parser_map(\"\".join, range_of(mn, mx, inner))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")\n```"}
{"id": "fp_parsing_parser_compile_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat-to-parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat-p inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0)) (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\") (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat-to-parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat-p inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0)) (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat-to-parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compile-repeat-to-parser`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat_to_parser(inner, mn, mx):\n    if mn == 0 and mx == 0:\n        return parser_pure(\"\")\n    if mn == 0 and mx is None:\n        return parser_map(\"\".join, parser_many(inner))\n    if mn == mx:\n        return parser_map(\"\".join, parser_count(mn, inner))\n    if mx is None:\n        return parser_map(\"\".join, at_least(mn, inner))\n    return parser_map(\"\".join, range_of(mn, mx, inner))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\") (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat-to-parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compile-repeat-to-parser`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat_to_parser(inner, mn, mx):\n    if mn == 0 and mx == 0:\n        return parser_pure(\"\")\n    if mn == 0 and mx is None:\n        return parser_map(\"\".join, parser_many(inner))\n    if mn == mx:\n        return parser_map(\"\".join, parser_count(mn, inner))\n    if mx is None:\n        return parser_map(\"\".join, at_least(mn, inner))\n    return parser_map(\"\".join, range_of(mn, mx, inner))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```"}
{"id": "fp_parsing_parser_compile_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex->parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_to_parser(pattern):\n    return dfa_to_parser(regex_to_dfa(pattern), pattern)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t) (equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "regex->parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `regex->parser`.\nReturn only the Scheme definition.\n\n```python\ndef regex_to_parser(pattern):\n    return dfa_to_parser(regex_to_dfa(pattern), pattern)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex->parser* pattern)\n  (dfa->parser (regex->dfa pattern) pattern))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "regex->parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `regex->parser`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (regex->parser* pattern)\n  (dfa->parser (regex->dfa pattern) pattern))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_to_parser(pattern):\n    return dfa_to_parser(regex_to_dfa(pattern), pattern)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\") (equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "regex->parser"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `regex->parser`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `regex->parser`.\nReturn only the final Scheme definition.\n\n```python\ndef regex_to_parser(pattern):\n    return dfa_to_parser(regex_to_dfa(pattern), pattern)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-regex`.\nReturn only the Scheme definition.\n\n```python\ndef compile_regex(pattern):\n    parsed = regex_parse(pattern)\n    if is_left(parsed):\n        raise ValueError(\"invalid regex: \" + error_message(from_left(parsed)))\n    ast = from_right(parsed)\n    nfa = regex_compile(ast, default_universe)\n    dfa = fsm_minimize(nfa)\n    p = dfa_to_parser(dfa, pattern)\n    return make_compiled_regex(pattern, ast, dfa, p)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "compile-regex"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-regex`.\nReturn only the Scheme definition.\n\n```python\ndef compile_regex(pattern):\n    parsed = regex_parse(pattern)\n    if is_left(parsed):\n        raise ValueError(\"invalid regex: \" + error_message(from_left(parsed)))\n    ast = from_right(parsed)\n    nfa = regex_compile(ast, default_universe)\n    dfa = fsm_minimize(nfa)\n    p = dfa_to_parser(dfa, pattern)\n    return make_compiled_regex(pattern, ast, dfa, p)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_020", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-regex`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-regex* pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                                   (error-message (from-left parse-result)))))])\n    (let* ([nfa (regex-compile ast *default-universe*)]\n           [d (fsm-minimize nfa)]\n           [p (dfa->parser d pattern)])\n      (make-compiled-regex pattern ast d p))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "compile-regex"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-regex`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-regex* pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                                   (error-message (from-left parse-result)))))])\n    (let* ([nfa (regex-compile ast *default-universe*)]\n           [d (fsm-minimize nfa)]\n           [p (dfa->parser d pattern)])\n      (make-compiled-regex pattern ast d p))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-regex`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compile-regex`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_regex(pattern):\n    parsed = regex_parse(pattern)\n    if is_left(parsed):\n        raise ValueError(\"invalid regex: \" + error_message(from_left(parsed)))\n    ast = from_right(parsed)\n    nfa = regex_compile(ast, default_universe)\n    dfa = fsm_minimize(nfa)\n    p = dfa_to_parser(dfa, pattern)\n    return make_compiled_regex(pattern, ast, dfa, p)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "compile-regex"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-regex`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compile-regex`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_regex(pattern):\n    parsed = regex_parse(pattern)\n    if is_left(parsed):\n        raise ValueError(\"invalid regex: \" + error_message(from_left(parsed)))\n    ast = from_right(parsed)\n    nfa = regex_compile(ast, default_universe)\n    dfa = fsm_minimize(nfa)\n    p = dfa_to_parser(dfa, pattern)\n    return make_compiled_regex(pattern, ast, dfa, p)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_translation_022", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compiled-regex-parse`.\nReturn only the Scheme definition.\n\n```python\ndef compiled_regex_parse(crx, input_s):\n    return parser_parse(compiled_regex_parser(crx), input_s)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "python-to-scheme", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compiled-regex-parse`.\nReturn only the Scheme definition.\n\n```python\ndef compiled_regex_parse(crx, input_s):\n    return parser_parse(compiled_regex_parser(crx), input_s)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```"}
{"id": "fp_parsing_parser_compile_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compiled-regex-parse`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compiled-regex-parse* crx input)\n  (parser-parse (compiled-regex-parser crx) input))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\") (equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "chez-to-fold", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compiled-regex-parse`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compiled-regex-parse* crx input)\n  (parser-parse (compiled-regex-parser crx) input))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_translation_024", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compiled-regex-parse`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compiled-regex-parse`.\nReturn only the final Scheme definition.\n\n```python\ndef compiled_regex_parse(crx, input_s):\n    return parser_parse(compiled_regex_parser(crx), input_s)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "reference-translation", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compiled-regex-parse`.\n\nPreserve parser behavior exactly (including failure behavior).\nKeep the target function name/signature as `compiled-regex-parse`.\nReturn only the final Scheme definition.\n\n```python\ndef compiled_regex_parse(crx, input_s):\n    return parser_parse(compiled_regex_parser(crx), input_s)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `advance-pos-range` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Range advancement must include the character at `from`; this skips the first consumed character.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  (let loop ([i (+ from 1)] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2)) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `advance-pos-range` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Range advancement must include the character at `from`; this skips the first consumed character.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  (let loop ([i (+ from 1)] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `advance-pos-range` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Position advancement must use actual consumed characters so newline transitions update line/column correctly.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p #\\space)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Position advancement must use actual consumed characters so newline transitions update line/column correctly.\n\nExpected behavior after patch:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```", "ground_truth": "(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p (string-ref input i))))))", "verify_expr": "(and (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (and (= (pos-line p1) 2) (= (pos-col p1) 2) (= (pos-line p2) 2) (= (pos-col p2) 2))) (equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t) (equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "advance-pos-range"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `advance-pos-range` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Position advancement must use actual consumed characters so newline transitions update line/column correctly.\n\n```scheme\n(define (advance-pos-range pos input from to)\n  (let loop ([i from] [p pos])\n    (if (>= i to) p\n        (loop (+ i 1) (advance-pos p #\\space)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Position advancement must use actual consumed characters so newline transitions update line/column correctly.\n\nExpected behavior after patch:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-line p1) 2))\n(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos-range p0 s 1 3)]) (= (pos-col p1) 2))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dfa->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Parser must return the longest accepting prefix when traversal later hits a dead transition.\n\n```scheme\n(define (dfa->parser fsm desc)\n  (make-parser\n   (lambda (state)\n     (left (make-parse-error (parser-state-pos state)\n                             (string-append \"expected \" desc)\n                             (list desc))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Parser must return the longest accepting prefix when traversal later hits a dead transition.\n\nExpected behavior after patch:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\") (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "dfa->parser"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dfa->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Parser must return the longest accepting prefix when traversal later hits a dead transition.\n\n```scheme\n(define (dfa->parser fsm desc)\n  (make-parser\n   (lambda (state)\n     (left (make-parse-error (parser-state-pos state)\n                             (string-append \"expected \" desc)\n                             (list desc))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Parser must return the longest accepting prefix when traversal later hits a dead transition.\n\nExpected behavior after patch:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dfa->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: DFA-backed parsing should continue scanning past early accepts to preserve longest-prefix behavior.\n\n```scheme\n(define (dfa->parser fsm desc)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (if (>= start len)\n             (left (make-parse-error (parser-state-pos state)\n                                     (string-append \"expected \" desc)\n                                     (list desc)))\n             (let ([next-states (fsm-delta automaton init (string-ref input start))])\n               (if (or (null? next-states)\n                       (not (pair? (memq (car next-states) acc))))\n                   (left (make-parse-error (parser-state-pos state)\n                                           (string-append \"expected \" desc)\n                                           (list desc)))\n                   (let* ([end (+ start 1)]\n                          [matched (substring input start end)]\n                          [new-pos (advance-pos-range (parser-state-pos state) input start end)])\n                     (right (cons matched (parser-make-state input end new-pos))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (dfa->parser fsm desc)\n  (doc 'export #t)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (let loop ([idx start]\n                    [current init]\n                    [last-accept-idx\n                     (if (pair? (memq init acc)) start #f)])\n           (if (>= idx len)\n               (if last-accept-idx\n                   (let* ([matched (substring input start last-accept-idx)]\n                          [new-pos (advance-pos-range\n                                    (parser-state-pos state) input start last-accept-idx)])\n                     (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                   (left (make-parse-error\n                          (parser-state-pos state)\n                          (string-append \"expected \" desc)\n                          (list desc))))\n               (let ([next-states (fsm-delta automaton current (string-ref input idx))])\n                 (if (null? next-states)\n                     (if last-accept-idx\n                         (let* ([matched (substring input start last-accept-idx)]\n                                [new-pos (advance-pos-range\n                                          (parser-state-pos state) input start last-accept-idx)])\n                           (right (cons matched (parser-make-state input last-accept-idx new-pos))))\n                         (left (make-parse-error\n                                (parser-state-pos state)\n                                (string-append \"expected \" desc)\n                                (list desc))))\n                     (let ([next (car next-states)])\n                       (loop (+ idx 1)\n                             next\n                             (if (pair? (memq next acc))\n                                 (+ idx 1)\n                                 last-accept-idx))))))))))))", "verify_expr": "(and (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (and (right? r1) (equal? (from-right r1) \"42\") (left? r2) (right? r3) (equal? (from-right r3) \"007\"))) (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\") (equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "dfa->parser"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dfa->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: DFA-backed parsing should continue scanning past early accepts to preserve longest-prefix behavior.\n\n```scheme\n(define (dfa->parser fsm desc)\n  (let ([automaton (if (fsm-deterministic? fsm) fsm (fsm-minimize (nfa->dfa fsm)))])\n    (make-parser\n     (lambda (state)\n       (let* ([input (parser-state-input state)]\n              [start (parser-state-index state)]\n              [len (string-length input)]\n              [init (fsm-start automaton)]\n              [acc (fsm-accepting automaton)])\n         (if (>= start len)\n             (left (make-parse-error (parser-state-pos state)\n                                     (string-append \"expected \" desc)\n                                     (list desc)))\n             (let ([next-states (fsm-delta automaton init (string-ref input start))])\n               (if (or (null? next-states)\n                       (not (pair? (memq (car next-states) acc))))\n                   (left (make-parse-error (parser-state-pos state)\n                                           (string-append \"expected \" desc)\n                                           (list desc)))\n                   (let* ([end (+ start 1)]\n                          [matched (substring input start end)]\n                          [new-pos (advance-pos-range (parser-state-pos state) input start end)])\n                     (right (cons matched (parser-make-state input end new-pos))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (right? r1))\n(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r1 (parser-parse p \"42abc\")] [r2 (parser-parse p \"abc\")] [r3 (parser-parse p \"007!\")]) (equal? (from-right r1) \"42\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex-ast->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Kleene star must allow zero repetitions; using parser-some incorrectly requires one-or-more matches.\n\n```scheme\n(define (regex-ast->parser ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n   [else\n    (parser-fail \"unsupported regex AST node\")]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Kleene star must allow zero repetitions; using parser-some incorrectly requires one-or-more matches.\n\nExpected behavior after patch:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex-ast->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Kleene star must allow zero repetitions; using parser-some incorrectly requires one-or-more matches.\n\n```scheme\n(define (regex-ast->parser ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n   [else\n    (parser-fail \"unsupported regex AST node\")]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Kleene star must allow zero repetitions; using parser-some incorrectly requires one-or-more matches.\n\nExpected behavior after patch:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex-ast->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Negated character classes must invert membership; this version treats both modes as positive classes.\n\n```scheme\n(define (regex-ast->parser ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (pair? (memv c chars)))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n   [else\n    (parser-fail \"unsupported regex AST node\")]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Negated character classes must invert membership; this version treats both modes as positive classes.\n\nExpected behavior after patch:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (regex-ast->parser ast)\n  (doc 'export #t)\n  (cond\n   [(regex-empty? ast)\n    (parser-pure \"\")]\n\n   [(regex-lit? ast)\n    (parser-map string (parser-char (regex-lit-char ast)))]\n\n   [(regex-dot? ast)\n    (parser-map string parser-any-char)]\n\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (not (pair? (memv c chars))))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n\n   [else\n    (parser-fail \"unsupported regex AST node\")]))", "verify_expr": "(and (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (and (right? r1) (equal? (from-right r1) \"abbbc\") (right? r2) (equal? (from-right r2) \"ac\") (left? r3) (right? rn1) (equal? (from-right rn1) \"x\") (left? rn2))) (equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t) (equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex-ast->parser"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex-ast->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Negated character classes must invert membership; this version treats both modes as positive classes.\n\n```scheme\n(define (regex-ast->parser ast)\n  (cond\n   [(regex-empty? ast) (parser-pure \"\")]\n   [(regex-lit? ast) (parser-map string (parser-char (regex-lit-char ast)))]\n   [(regex-dot? ast) (parser-map string parser-any-char)]\n   [(regex-class? ast)\n    (let ([chars (regex-class-chars ast)]\n          [negated? (regex-class-negated? ast)])\n      (parser-map string\n        (parser-satisfy\n         (if negated?\n             (lambda (c) (pair? (memv c chars)))\n             (lambda (c) (pair? (memv c chars))))\n         \"character class\")))]\n   [(regex-seq? ast)\n    (let ([parsers (map regex-ast->parser (regex-seq-exprs ast))])\n      (fold-left (lambda (acc p)\n                   (parser-bind acc\n                     (lambda (s1)\n                       (parser-map (lambda (s2) (string-append s1 s2)) p))))\n                 (parser-pure \"\")\n                 parsers))]\n   [(regex-alt? ast)\n    (let ([parsers (map (lambda (e) (parser-try (regex-ast->parser e)))\n                        (regex-alt-exprs ast))])\n      (parser-choice parsers))]\n   [(regex-star? ast)\n    (let ([inner (regex-ast->parser (regex-star-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-many inner)))]\n   [(regex-plus? ast)\n    (let ([inner (regex-ast->parser (regex-plus-expr ast))])\n      (parser-map (lambda (parts) (apply string-append parts))\n                  (parser-some inner)))]\n   [(regex-opt? ast)\n    (let ([inner (regex-ast->parser (regex-opt-expr ast))])\n      (parser-optional inner \"\"))]\n   [(regex-group? ast)\n    (regex-ast->parser (regex-group-expr ast))]\n   [(regex-repeat? ast)\n    (compile-repeat-to-parser\n     (regex-ast->parser (regex-repeat-expr ast))\n     (regex-repeat-min ast)\n     (regex-repeat-max ast))]\n   [else\n    (parser-fail \"unsupported regex AST node\")]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Negated character classes must invert membership; this version treats both modes as positive classes.\n\nExpected behavior after patch:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (right? r1))\n(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-star (regex-lit #\\b)) (regex-lit #\\c)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"abbbc!\")] [r2 (parser-parse p \"ac!\")] [r3 (parser-parse p \"abbd\")] [pneg (regex-ast->parser (regex-class (list #\\a #\\b) #t))] [rn1 (parser-parse pneg \"x\")] [rn2 (parser-parse pneg \"a\")]) (equal? (from-right r1) \"abbbc\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([ast (regex-star (regex-lit #\\a))] [p (regex-ast->parser ast)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat-to-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: {0,0} repeat must parse as empty string, not immediate parser failure.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-fail \"expected empty\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: {0,0} repeat must parse as empty string, not immediate parser failure.\n\nExpected behavior after patch:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat-to-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: {0,0} repeat must parse as empty string, not immediate parser failure.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-fail \"expected empty\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: {0,0} repeat must parse as empty string, not immediate parser failure.\n\nExpected behavior after patch:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat-to-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Unbounded upper repeats {n,} require at-least behavior, not exactly-n behavior.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```", "ground_truth": "(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (at-least min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))", "verify_expr": "(and (let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (and (right? r0) (equal? (from-right r0) \"\") (right? r1) (equal? (from-right r1) \"aaa\") (left? r2) (right? r3) (equal? (from-right r3) \"aaaa\") (left? r4))) (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\") (equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compile-repeat-to-parser"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat-to-parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Unbounded upper repeats {n,} require at-least behavior, not exactly-n behavior.\n\n```scheme\n(define (compile-repeat-to-parser inner min max)\n  (cond\n   [(and (= min 0) (eqv? max 0))\n    (parser-pure \"\")]\n   [(and (= min 0) (not max))\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-many inner))]\n   [(eqv? min max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [(not max)\n    (parser-map (lambda (parts) (apply string-append parts))\n                (parser-count min inner))]\n   [else\n    (parser-map (lambda (parts) (apply string-append parts))\n                (range-of min max inner))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (right? r0))\n(let* ([inner (parser-map string (parser-char #\\a))] [p0 (compile-repeat-to-parser inner 0 0)] [p1 (compile-repeat-to-parser inner 2 4)] [p2 (compile-repeat-to-parser inner 2 #f)] [r0 (parser-parse p0 \"bbb\")] [r1 (parser-parse p1 \"aaab\")] [r2 (parser-parse p1 \"ab\")] [r3 (parser-parse p2 \"aaaa!\")] [r4 (parser-parse p2 \"a!\")]) (equal? (from-right r0) \"\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 0 0)] [r (parser-parse p \"bbb\")]) (if (right? r) (from-right r) \"<fail>\")) \"\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: regex->parser must use DFA-backed longest-prefix semantics, not ordered combinator alternation semantics.\n\n```scheme\n(define (regex->parser pattern)\n  (regex->combinator-parser pattern))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex->parser"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: regex->parser must use DFA-backed longest-prefix semantics, not ordered combinator alternation semantics.\n\n```scheme\n(define (regex->parser pattern)\n  (regex->combinator-parser pattern))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: regex->parser should return prefix parser behavior; forcing EOF incorrectly requires full-input matches.\n\n```scheme\n(define (regex->parser pattern)\n  (parser-left (dfa->parser (regex->dfa pattern) pattern) parser-eof))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```", "ground_truth": "(define (regex->parser pattern)\n  (doc 'export #t)\n  (dfa->parser (regex->dfa pattern) pattern))", "verify_expr": "(and (let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (and (right? r1) (equal? (from-right r1) \"ab\") (right? r2) (equal? (from-right r2) \"a\") (left? r3))) (equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "regex->parser"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `regex->parser` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: regex->parser should return prefix parser behavior; forcing EOF incorrectly requires full-input matches.\n\n```scheme\n(define (regex->parser pattern)\n  (parser-left (dfa->parser (regex->dfa pattern) pattern) parser-eof))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (right? r1))\n(let* ([p (regex->parser \"a|ab\")] [r1 (parser-parse p \"ab!\")] [r2 (parser-parse p \"a!\")] [r3 (parser-parse p \"b!\")]) (equal? (from-right r1) \"ab\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([p (regex->parser \"colou?r\")] [r1 (parser-parse p \"color!\")] [r2 (parser-parse p \"colour!\")]) (and (right? r1) (equal? (from-right r1) \"color\") (right? r2) (equal? (from-right r2) \"colour\"))) #t)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-regex` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compile-regex must store DFA-backed parser to preserve longest-prefix behavior across dual-form APIs.\n\n```scheme\n(define (compile-regex pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (regex->combinator-parser pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compile-regex must store DFA-backed parser to preserve longest-prefix behavior across dual-form APIs.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compile-regex"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-regex` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compile-regex must store DFA-backed parser to preserve longest-prefix behavior across dual-form APIs.\n\n```scheme\n(define (compile-regex pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (regex->combinator-parser pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compile-regex must store DFA-backed parser to preserve longest-prefix behavior across dual-form APIs.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-regex` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Compiled-regex should preserve the original pattern string in metadata.\n\n```scheme\n(define (compile-regex pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex \"<compiled>\" ast the-dfa the-parser)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Compiled-regex should preserve the original pattern string in metadata.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(= (let* ([crx (compile-regex \"[0-9]+\")] [combined (parser-bind (compiled-regex-parser crx) (lambda (s) (parser-pure (string-length s))))] [r (parser-parse combined \"12345\")]) (if (right? r) (from-right r) -1)) 5)\n```", "ground_truth": "(define (compile-regex pattern)\n  (doc 'export #t)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex pattern ast the-dfa the-parser)))", "verify_expr": "(and (let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\") (compiled-regex-matches? crx \"a\") (compiled-regex-matches? crx \"ab\") (not (compiled-regex-matches? crx \"b\")) (right? r) (equal? (from-right r) \"ab\"))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (= (let* ([crx (compile-regex \"[0-9]+\")] [combined (parser-bind (compiled-regex-parser crx) (lambda (s) (parser-pure (string-length s))))] [r (parser-parse combined \"12345\")]) (if (right? r) (from-right r) -1)) 5))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compile-regex"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-regex` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: Compiled-regex should preserve the original pattern string in metadata.\n\n```scheme\n(define (compile-regex pattern)\n  (let* ([parse-result (regex-parse pattern)]\n         [ast (if (right? parse-result)\n                  (from-right parse-result)\n                  (error 'compile-regex\n                    (string-append \"invalid regex: \"\n                      (error-message (from-left parse-result)))))]\n         [nfa (regex-compile ast *default-universe*)]\n         [the-dfa (fsm-minimize nfa)]\n         [the-parser (dfa->parser the-dfa pattern)])\n    (make-compiled-regex \"<compiled>\" ast the-dfa the-parser)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Compiled-regex should preserve the original pattern string in metadata.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (compiled-regex? crx))\n(let* ([crx (compile-regex \"a|ab\")] [p (compiled-regex-parser crx)] [r (parser-parse p \"ab!\")]) (equal? (compiled-regex-pattern crx) \"a|ab\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (parser-parse (compiled-regex-parser crx) \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(= (let* ([crx (compile-regex \"[0-9]+\")] [combined (parser-bind (compiled-regex-parser crx) (lambda (s) (parser-pure (string-length s))))] [r (parser-parse combined \"12345\")]) (if (right? r) (from-right r) -1)) 5)\n```"}
{"id": "fp_parsing_parser_compile_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compiled-regex-parse` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compiled-regex-parse should parse prefixes via parser-parse, not require full-input consumption.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  (parse-all (compiled-regex-parser crx) input))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compiled-regex-parse should parse prefixes via parser-parse, not require full-input consumption.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\") (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\"))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compiled-regex-parse` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compiled-regex-parse should parse prefixes via parser-parse, not require full-input consumption.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  (parse-all (compiled-regex-parser crx) input))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compiled-regex-parse should parse prefixes via parser-parse, not require full-input consumption.\n\nExpected behavior after patch:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"a|ab\")] [r (compiled-regex-parse crx \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```"}
{"id": "fp_parsing_parser_compile_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compiled-regex-parse` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compiled-regex-parse must return parser result payload, not a boolean matcher result.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  (compiled-regex-matches? crx input))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t)\n```", "ground_truth": "(define (compiled-regex-parse crx input)\n  (doc 'export #t)\n  (parser-parse (compiled-regex-parser crx) input))", "verify_expr": "(and (let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (and (right? r1) (equal? (from-right r1) \"123\") (left? r2))) (equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\") (equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t))", "tags": ["tier1", "fp", "parsing", "parser-compile", "bugfix", "compiled-regex-parse"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compiled-regex-parse` in `lattice/fp/parsing/parser-compile.ss`.\nKnown issue: compiled-regex-parse must return parser result payload, not a boolean matcher result.\n\n```scheme\n(define (compiled-regex-parse crx input)\n  (compiled-regex-matches? crx input))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (right? r1))\n(let* ([crx (compile-regex \"[0-9]+\")] [r1 (compiled-regex-parse crx \"123abc\")] [r2 (compiled-regex-parse crx \"abc\")]) (equal? (from-right r1) \"123\"))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([crx (compile-regex \"[a-z]+\")] [r (compiled-regex-parse crx \"hello world\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"abc\")]) (left? r)) #t)\n```"}
{"id": "fp_parsing_parser_compile_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdvance position over \"a\\nb\" and return resulting line/column pair.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p)))", "verify_expr": "(equal? (let* ([s (string-append \"a\" (string #\\newline) \"b\")] [st (parser-initial-state s)] [p (advance-pos-range (parser-state-pos st) s 0 3)]) (list (pos-line p) (pos-col p))) '(2 2))", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "advance-pos-range", "newline"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nAdvance position over \"a\\nb\" and return resulting line/column pair.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether advancing over an empty index range leaves parser position unchanged.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1))))", "verify_expr": "(equal? (let* ([st (parser-initial-state \"xyz\")] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 \"xyz\" 1 1)]) (and (= (pos-line p0) (pos-line p1)) (= (pos-col p0) (pos-col p1)))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "advance-pos-range", "identity"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether advancing over an empty index range leaves parser position unchanged.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "advance-pos-range", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether advancing full range equals manual fold with advance-pos over each character.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2))))", "verify_expr": "(equal? (let* ([s (string-append \"q\" (string #\\newline) \"w\")] [st (parser-initial-state s)] [p0 (parser-state-pos st)] [p1 (advance-pos-range p0 s 0 3)] [p2 (advance-pos (advance-pos (advance-pos p0 (string-ref s 0)) (string-ref s 1)) (string-ref s 2))]) (and (= (pos-line p1) (pos-line p2)) (= (pos-col p1) (pos-col p2)))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "advance-pos-range", "equivalence"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether advancing full range equals manual fold with advance-pos over each character.\n\nEnsure `advance-pos-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a DFA-backed parser for `[0-9]+` and parse prefix from `42abc`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "dfa->parser", "prefix"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild a DFA-backed parser for `[0-9]+` and parse prefix from `42abc`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether DFA-backed parser for `[0-9]+` fails on non-matching input `abc`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r))", "verify_expr": "(equal? (let* ([p (dfa->parser (regex->dfa \"[0-9]+\") \"digits\")] [r (parser-parse p \"abc\")]) (left? r)) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "dfa->parser", "failure"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether DFA-backed parser for `[0-9]+` fails on non-matching input `abc`.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "dfa->parser", "prompt": "Task mode: small integration task across module primitives.\n\nCompose DFA parser with `!` suffix using parse-all and return matched token.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (parser-left (dfa->parser (regex->dfa \"[0-9]+\") \"digits\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "dfa->parser", "composition"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompose DFA parser with `!` suffix using parse-all and return matched token.\n\nEnsure `dfa->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile literal AST `x` to parser and return parsed prefix from `xyz`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (regex-ast->parser (regex-lit #\\x))] [r (parser-parse p \"xyz\")]) (if (right? r) (from-right r) \"<fail>\")) \"x\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex-ast->parser", "literal"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile literal AST `x` to parser and return parsed prefix from `xyz`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile sequence AST for `ab` and return parsed prefix from `abc`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([ast (regex-seq (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r (parser-parse p \"abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex-ast->parser", "sequence"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile sequence AST for `ab` and return parsed prefix from `abc`.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex-ast->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile alternation AST for `a|b` and return whether both branches parse correctly.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\")))", "verify_expr": "(equal? (let* ([ast (regex-alt (list (regex-lit #\\a) (regex-lit #\\b)))] [p (regex-ast->parser ast)] [r1 (parser-parse p \"a\")] [r2 (parser-parse p \"b\")]) (and (right? r1) (equal? (from-right r1) \"a\") (right? r2) (equal? (from-right r2) \"b\"))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex-ast->parser", "alternation"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile alternation AST for `a|b` and return whether both branches parse correctly.\n\nEnsure `regex-ast->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile repeat `{2,4}` and parse prefix from `aaab`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 4)] [r (parser-parse p \"aaab\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaa\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-repeat-to-parser", "bounded"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile repeat `{2,4}` and parse prefix from `aaab`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: small integration task across module primitives.\n\nCompile repeat `{2,}` and parse prefix from `aaaa!`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"aaaa!\")]) (if (right? r) (from-right r) \"<fail>\")) \"aaaa\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-repeat-to-parser", "at-least"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompile repeat `{2,}` and parse prefix from `aaaa!`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-repeat-to-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether repeat `{2,}` fails on input `a!`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r))", "verify_expr": "(equal? (let* ([inner (parser-map string (parser-char #\\a))] [p (compile-repeat-to-parser inner 2 #f)] [r (parser-parse p \"a!\")]) (left? r)) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-repeat-to-parser", "min-bound"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether repeat `{2,}` fails on input `a!`.\n\nEnsure `compile-repeat-to-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile regex parser for `[0-9]+` and return parsed prefix from `42abc`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"42abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"42\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->parser", "digits"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile regex parser for `[0-9]+` and return parsed prefix from `42abc`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn longest-prefix result of regex parser for `a|ab` on `ab!`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (regex->parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"ab\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->parser", "longest"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn longest-prefix result of regex parser for `a|ab` on `ab!`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->parser", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether regex parser for `[0-9]+` fails on input `abc`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r))", "verify_expr": "(equal? (let* ([p (regex->parser \"[0-9]+\")] [r (parser-parse p \"abc\")]) (left? r)) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->parser", "failure"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether regex parser for `[0-9]+` fails on input `abc`.\n\nEnsure `regex->parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: small integration task across module primitives.\n\nCompile combinator parser for `[a-z]+` and return parsed prefix from `hello42`.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (regex->combinator-parser \"[a-z]+\")] [r (parser-parse p \"hello42\")]) (if (right? r) (from-right r) \"<fail>\")) \"hello\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->combinator-parser", "letters"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompile combinator parser for `[a-z]+` and return parsed prefix from `hello42`.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn ordered-choice result for combinator parser `a|ab` on input `ab!`.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (regex->combinator-parser \"a|ab\")] [r (parser-parse p \"ab!\")]) (if (right? r) (from-right r) \"<fail>\")) \"a\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->combinator-parser", "ordered-choice"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn ordered-choice result for combinator parser `a|ab` on input `ab!`.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_parser_compile_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether combinator parser creation for invalid regex `[` yields parser failure at parse time.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r))", "verify_expr": "(equal? (let* ([p (regex->combinator-parser \"[\")] [r (parser-parse p \"x\")]) (left? r)) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->combinator-parser", "invalid-regex"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether combinator parser creation for invalid regex `[` yields parser failure at parse time.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "regex->combinator-parser", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose combinator regex parser `[0-9]+` with trailing `!` via parse-all and return parsed token.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([p (parser-left (regex->combinator-parser \"[0-9]+\") (parser-char #\\!))] [r (parse-all p \"123!\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "regex->combinator-parser", "composition"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompose combinator regex parser `[0-9]+` with trailing `!` via parse-all and return parsed token.\n\nEnsure `regex->combinator-parser` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: small integration task across module primitives.\n\nCompile regex `a|ab` and return whether compiled object metadata is valid and preserves pattern.\n\nEnsure `compile-regex` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\")))", "verify_expr": "(equal? (let ([crx (compile-regex \"a|ab\")]) (and (compiled-regex? crx) (equal? (compiled-regex-pattern crx) \"a|ab\"))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-regex", "metadata"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompile regex `a|ab` and return whether compiled object metadata is valid and preserves pattern.\n\nEnsure `compile-regex` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile regex `ab+` and return matcher agreement for accepted/rejected strings.\n\nEnsure `compile-regex` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\"))))", "verify_expr": "(equal? (let ([crx (compile-regex \"ab+\")]) (and (compiled-regex-matches? crx \"abbb\") (not (compiled-regex-matches? crx \"a\")) (not (compiled-regex-matches? crx \"bb\")))) #t)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-regex", "matcher"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile regex `ab+` and return matcher agreement for accepted/rejected strings.\n\nEnsure `compile-regex` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_parser_compile_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compile-regex", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile regex `[0-9]+` and compose compiled parser to return matched-token length.\n\nEnsure `compile-regex` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([crx (compile-regex \"[0-9]+\")] [combined (parser-bind (compiled-regex-parser crx) (lambda (s) (parser-pure (string-length s))))] [r (parser-parse combined \"12345\")]) (if (right? r) (from-right r) -1))", "verify_expr": "(= (let* ([crx (compile-regex \"[0-9]+\")] [combined (parser-bind (compiled-regex-parser crx) (lambda (s) (parser-pure (string-length s))))] [r (parser-parse combined \"12345\")]) (if (right? r) (from-right r) -1)) 5)", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compile-regex", "composition"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile regex `[0-9]+` and compose compiled parser to return matched-token length.\n\nEnsure `compile-regex` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_parser_compile_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/parser-compile.ss", "source_test": "lattice/fp/parsing/test-parser-compile.ss", "source_function": "compiled-regex-parse", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse compiled-regex-parse on `[0-9]+` and return parsed prefix from `123abc`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\"))", "verify_expr": "(equal? (let* ([crx (compile-regex \"[0-9]+\")] [r (compiled-regex-parse crx \"123abc\")]) (if (right? r) (from-right r) \"<fail>\")) \"123\")", "tags": ["tier1", "fp", "parsing", "parser-compile", "composition", "compiled-regex-parse", "prefix"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nUse compiled-regex-parse on `[0-9]+` and return parsed prefix from `123abc`.\n\nEnsure `compiled-regex-parse` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
