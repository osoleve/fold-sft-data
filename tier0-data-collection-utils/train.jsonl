{"id": "collection_utils_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `foldr`\nSpec: Right-associative fold over lists: f x1 (f x2 (... init)).\n\nWrite exactly one Scheme function definition for `foldr`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "spec-to-code", "foldr"], "split": "train"}
{"id": "collection_utils_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (foldr f init lst)\n  ;; TODO: right-associative list fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `foldr`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "skeleton-completion", "foldr"], "split": "train"}
{"id": "collection_utils_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-hashes collection)\n  ;; TODO: return refs as a list preserving vector order\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-hashes`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-hashes"], "split": "train"}
{"id": "collection_utils_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-size`\nSpec: Return number of refs in a collection block.\n\nWrite exactly one Scheme function definition for `collection-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-size"], "split": "train"}
{"id": "collection_utils_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-size collection)\n  ;; TODO: number of references in collection\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-size`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-size"], "split": "train"}
{"id": "collection_utils_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-empty? collection)\n  ;; TODO: check whether collection has zero members\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-empty?"], "split": "train"}
{"id": "collection_utils_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `make-collection-from-blocks`\nSpec: Build a collection block from a list of blocks by hashing each member.\n\nWrite exactly one Scheme function definition for `make-collection-from-blocks`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "spec-to-code", "make-collection-from-blocks"], "split": "train"}
{"id": "collection_utils_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-collection-from-blocks tag name blocks)\n  ;; TODO: hash each block and create a new collection block\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-collection-from-blocks`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "skeleton-completion", "make-collection-from-blocks"], "split": "train"}
{"id": "collection_utils_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-add collection new-member)\n  ;; TODO: create new immutable collection with one additional member hash\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-add`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-add"], "split": "train"}
{"id": "collection_utils_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-remove`\nSpec: Return a new collection with all refs equal to member-hash removed.\n\nWrite exactly one Scheme function definition for `collection-remove`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-remove"], "split": "train"}
{"id": "collection_utils_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-remove collection member-hash)\n  ;; TODO: remove matching hash values from refs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-remove`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-remove"], "split": "train"}
{"id": "collection_utils_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-merge`\nSpec: Return a new collection combining refs from coll1 then coll2.\n\nWrite exactly one Scheme function definition for `collection-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-merge"], "split": "train"}
{"id": "collection_utils_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (collection-merge coll1 coll2)\n  ;; TODO: concatenate refs from coll1 then coll2 into a new block\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `collection-merge`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "skeleton-completion", "collection-merge"], "split": "train"}
{"id": "collection_utils_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `foldr`.\nReturn only the Scheme definition.\n\n```python\ndef foldr(f, init, xs):\n    if not xs:\n        return init\n    return f(xs[0], foldr(f, init, xs[1:]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "python-to-scheme", "foldr"], "split": "train"}
{"id": "collection_utils_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `foldr`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (fold-right f z xs)\n  (if (null? xs)\n      z\n      (f (car xs) (fold-right f z (cdr xs)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "chez-to-fold", "foldr"], "split": "train"}
{"id": "collection_utils_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-hashes`.\nReturn only the Scheme definition.\n\n```python\ndef collection_hashes(collection):\n    refs = block_refs(collection)\n    out = []\n    for i in range(len(refs)):\n        out.append(refs[i])\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-hashes"], "split": "train"}
{"id": "collection_utils_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-hashes`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (hashes-of coll)\n  (let ((refs (block-refs coll)))\n    (let loop ((i 0) (acc '()))\n      (if (>= i (vector-length refs))\n          (reverse acc)\n          (loop (+ i 1) (cons (vector-ref refs i) acc))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-hashes"], "split": "train"}
{"id": "collection_utils_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (coll-size coll)\n  (vector-length (block-refs coll)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-size"], "split": "train"}
{"id": "collection_utils_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef collection_empty(collection):\n    return len(block_refs(collection)) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(collection-empty? (make-block 'collection (string->utf8 \"e\") (vector)))\n(not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-empty?"], "split": "train"}
{"id": "collection_utils_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (coll-empty? coll)\n  (= (vector-length (block-refs coll)) 0))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(collection-empty? (make-block 'collection (string->utf8 \"e\") (vector)))\n(not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-empty?"], "split": "train"}
{"id": "collection_utils_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-collection-from-blocks`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-collection tag name blocks)\n  (let ((hs (map hash-block blocks)))\n    (make-block tag\n                (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                (list->vector hs))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "chez-to-fold", "make-collection-from-blocks"], "split": "train"}
{"id": "collection_utils_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-add`.\nReturn only the Scheme definition.\n\n```python\ndef collection_add(collection, new_member):\n    old_refs = block_refs(collection)\n    new_hash = hash_block(new_member)\n    new_refs = list_to_vector([new_hash] + vector_to_list(old_refs))\n    return make_block(block_tag(collection), block_payload(collection), new_refs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-add"], "split": "train"}
{"id": "collection_utils_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-add`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (coll-add coll member)\n  (let* ((old (block-refs coll))\n         (h (hash-block member))\n         (new (list->vector (cons h (vector->list old)))))\n    (make-block (block-tag coll) (block-payload coll) new)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-add"], "split": "train"}
{"id": "collection_utils_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-remove`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (coll-remove coll h)\n  (let* ((old (block-refs coll))\n         (new (list->vector (filter (lambda (x) (not (equal? x h))) (vector->list old)))))\n    (make-block (block-tag coll) (block-payload coll) new)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-remove"], "split": "train"}
{"id": "collection_utils_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-merge`.\nReturn only the Scheme definition.\n\n```python\ndef collection_merge(coll1, coll2):\n    refs1 = block_refs(coll1)\n    refs2 = block_refs(coll2)\n    combined = vector_to_list(refs1) + vector_to_list(refs2)\n    return make_block(block_tag(coll1), utf8(f\"merged ({len(combined)} members)\"), list_to_vector(combined))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-merge"], "split": "train"}
{"id": "collection_utils_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `collection-merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (coll-merge a b)\n  (let* ((r1 (block-refs a))\n         (r2 (block-refs b))\n         (combined (append (vector->list r1) (vector->list r2))))\n    (make-block (block-tag a)\n                (string->utf8 (format \"merged (~a members)\" (length combined)))\n                (list->vector combined))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "chez-to-fold", "collection-merge"], "split": "train"}
{"id": "collection_utils_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `foldr` in `lattice/data/collection-utils.ss`.\nKnown issue: Non-empty lists must apply f recursively.\n\n```scheme\n(define (foldr f init lst)\n  init)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "bugfix", "foldr"], "split": "train"}
{"id": "collection_utils_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-hashes` in `lattice/data/collection-utils.ss`.\nKnown issue: Hashes must be returned in collection ref order, not reversed.\n\n```scheme\n(define (collection-hashes collection)\n  (reverse (vector->list (block-refs collection))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "bugfix", "collection-hashes"], "split": "train"}
{"id": "collection_utils_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-hashes` in `lattice/data/collection-utils.ss`.\nKnown issue: Must return all member hashes from refs.\n\n```scheme\n(define (collection-hashes collection)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "bugfix", "collection-hashes"], "split": "train"}
{"id": "collection_utils_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-size` in `lattice/data/collection-utils.ss`.\nKnown issue: Size should equal the exact vector length.\n\n```scheme\n(define (collection-size collection)\n  (+ 1 (vector-length (block-refs collection))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "bugfix", "collection-size"], "split": "train"}
{"id": "collection_utils_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-size` in `lattice/data/collection-utils.ss`.\nKnown issue: Non-empty collections must report their actual size.\n\n```scheme\n(define (collection-size collection)\n  0)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "bugfix", "collection-size"], "split": "train"}
{"id": "collection_utils_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-empty?` in `lattice/data/collection-utils.ss`.\nKnown issue: Empty collections must return #t.\n\n```scheme\n(define (collection-empty? collection)\n  #f)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "bugfix", "collection-empty?"], "split": "train"}
{"id": "collection_utils_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-empty?` in `lattice/data/collection-utils.ss`.\nKnown issue: Predicate should check for zero members.\n\n```scheme\n(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(collection-empty? (make-block 'collection (string->utf8 \"e\") (vector)))\n(not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "bugfix", "collection-empty?"], "split": "train"}
{"id": "collection_utils_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-collection-from-blocks` in `lattice/data/collection-utils.ss`.\nKnown issue: Result should preserve the caller-supplied tag and payload format.\n\n```scheme\n(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block 'collection (string->utf8 name) (list->vector hashes))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "bugfix", "make-collection-from-blocks"], "split": "train"}
{"id": "collection_utils_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-add` in `lattice/data/collection-utils.ss`.\nKnown issue: Must return a new collection with the new member hash inserted.\n\n```scheme\n(define (collection-add collection new-member)\n  collection)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "bugfix", "collection-add"], "split": "train"}
{"id": "collection_utils_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-add` in `lattice/data/collection-utils.ss`.\nKnown issue: Module semantics prepend new member hash to refs.\n\n```scheme\n(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (append (vector->list old-refs) (list new-hash)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "bugfix", "collection-add"], "split": "train"}
{"id": "collection_utils_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-remove` in `lattice/data/collection-utils.ss`.\nKnown issue: Must remove matching hashes from refs.\n\n```scheme\n(define (collection-remove collection member-hash)\n  collection)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "bugfix", "collection-remove"], "split": "train"}
{"id": "collection_utils_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-remove` in `lattice/data/collection-utils.ss`.\nKnown issue: Predicate is inverted; this keeps only the removed hash.\n\n```scheme\n(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector (filter (lambda (h) (equal? h member-hash)) (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "bugfix", "collection-remove"], "split": "train"}
{"id": "collection_utils_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-merge` in `lattice/data/collection-utils.ss`.\nKnown issue: Merge must include refs from both collections.\n\n```scheme\n(define (collection-merge coll1 coll2)\n  coll1)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "bugfix", "collection-merge"], "split": "train"}
{"id": "collection_utils_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse foldr with cons to reconstruct '(a b c).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (foldr cons '() '(a b c)) '(a b c))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(foldr cons '() '(a b c))", "verify_expr": "(equal? (foldr cons '() '(a b c)) '(a b c))", "tags": ["data", "collection-utils", "composition", "foldr", "direct"], "split": "train"}
{"id": "collection_utils_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn number of hashes in a 2-member collection.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (length (collection-hashes c))) 2)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (length (collection-hashes c)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (length (collection-hashes c))) 2)", "tags": ["data", "collection-utils", "composition", "collection-hashes", "direct"], "split": "train"}
{"id": "collection_utils_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn first hash after collection-add prepends a member.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2))) #t)", "tags": ["data", "collection-utils", "composition", "collection-hashes", "direct"], "split": "train"}
{"id": "collection_utils_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn size of a collection with refs vector '(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (collection-size (make-block 'collection (string->utf8 \"x\") (vector 1 2 3))) 3)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(collection-size (make-block 'collection (string->utf8 \"x\") (vector 1 2 3)))", "verify_expr": "(equal? (collection-size (make-block 'collection (string->utf8 \"x\") (vector 1 2 3))) 3)", "tags": ["data", "collection-utils", "composition", "collection-size", "direct"], "split": "train"}
{"id": "collection_utils_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn size of an empty collection block.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (collection-size (make-block 'collection (string->utf8 \"x\") (vector))) 0)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(collection-size (make-block 'collection (string->utf8 \"x\") (vector)))", "verify_expr": "(equal? (collection-size (make-block 'collection (string->utf8 \"x\") (vector))) 0)", "tags": ["data", "collection-utils", "composition", "collection-size", "direct"], "split": "train"}
{"id": "collection_utils_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck whether empty collection block is empty.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(collection-empty? (make-block 'collection (string->utf8 \"empty\") (vector)))", "verify_expr": "(equal? (collection-empty? (make-block 'collection (string->utf8 \"empty\") (vector))) #t)", "tags": ["data", "collection-utils", "composition", "collection-empty?", "direct"], "split": "train"}
{"id": "collection_utils_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck whether non-empty collection block is empty.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (collection-empty? (make-block 'collection (string->utf8 \"full\") (vector 1))) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(collection-empty? (make-block 'collection (string->utf8 \"full\") (vector 1)))", "verify_expr": "(equal? (collection-empty? (make-block 'collection (string->utf8 \"full\") (vector 1))) #f)", "tags": ["data", "collection-utils", "composition", "collection-empty?", "direct"], "split": "train"}
{"id": "collection_utils_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate collection and return whether tag is preserved.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c (make-collection-from-blocks 'custom \"demo\" (list b1))]) (eq? (block-tag c) 'custom)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c (make-collection-from-blocks 'custom \"demo\" (list b1))]) (eq? (block-tag c) 'custom))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c (make-collection-from-blocks 'custom \"demo\" (list b1))]) (eq? (block-tag c) 'custom)) #t)", "tags": ["data", "collection-utils", "composition", "make-collection-from-blocks", "direct"], "split": "train"}
{"id": "collection_utils_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd a block to a 1-member collection and return new size.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (collection-size c2)) 2)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (collection-size c2))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (collection-size c2)) 2)", "tags": ["data", "collection-utils", "composition", "collection-add", "direct"], "split": "train"}
{"id": "collection_utils_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: small integration task across module primitives.\n\nAdd a member and check that its hash appears first in refs.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (equal? (car (collection-hashes c2)) (hash-block b2))) #t)", "tags": ["data", "collection-utils", "composition", "collection-add", "direct"], "split": "train"}
{"id": "collection_utils_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove a known member hash and return resulting size.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))] [c2 (collection-remove c (hash-block b1))]) (collection-size c2))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))] [c2 (collection-remove c (hash-block b1))]) (collection-size c2)) 1)", "tags": ["data", "collection-utils", "composition", "collection-remove", "direct"], "split": "train"}
{"id": "collection_utils_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove a missing hash and confirm size stays unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-remove c 123456)]) (= (collection-size c2) (collection-size c)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-remove c 123456)]) (= (collection-size c2) (collection-size c))) #t)", "tags": ["data", "collection-utils", "composition", "collection-remove", "direct"], "split": "train"}
{"id": "collection_utils_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge 2-member and 1-member collections and return size.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (collection-size m))", "verify_expr": "(equal? (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (collection-size m)) 3)", "tags": ["data", "collection-utils", "composition", "collection-merge", "direct"], "split": "train"}
{"id": "collection_utils_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two collections and check resulting tag comes from first collection.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c1 (make-collection-from-blocks 'left \"x\" (list a))] [c2 (make-collection-from-blocks 'right \"y\" (list b))] [m (collection-merge c1 c2)]) (eq? (block-tag m) 'left)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c1 (make-collection-from-blocks 'left \"x\" (list a))] [c2 (make-collection-from-blocks 'right \"y\" (list b))] [m (collection-merge c1 c2)]) (eq? (block-tag m) 'left))", "verify_expr": "(equal? (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c1 (make-collection-from-blocks 'left \"x\" (list a))] [c2 (make-collection-from-blocks 'right \"y\" (list b))] [m (collection-merge c1 c2)]) (eq? (block-tag m) 'left)) #t)", "tags": ["data", "collection-utils", "composition", "collection-merge", "direct"], "split": "train"}
{"id": "collection_utils_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff collection-hashes length matches collection-size.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (= (length (collection-hashes c)) (collection-size c)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (= (length (collection-hashes c)) (collection-size c))) #t)", "tags": ["data", "collection-utils", "composition", "collection-hashes", "property"], "split": "train"}
{"id": "collection_utils_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff collection-size is non-negative for any constructed collection.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([c (make-block 'collection (string->utf8 \"x\") (vector 1 2 3))]) (>= (collection-size c) 0)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([c (make-block 'collection (string->utf8 \"x\") (vector 1 2 3))]) (>= (collection-size c) 0))", "verify_expr": "(equal? (let ([c (make-block 'collection (string->utf8 \"x\") (vector 1 2 3))]) (>= (collection-size c) 0)) #t)", "tags": ["data", "collection-utils", "composition", "collection-size", "property"], "split": "train"}
{"id": "collection_utils_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff collection-empty? agrees with size==0.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([c (make-block 'collection (string->utf8 \"x\") (vector))]) (equal? (collection-empty? c) (= (collection-size c) 0)))", "verify_expr": "(equal? (let ([c (make-block 'collection (string->utf8 \"x\") (vector))]) (equal? (collection-empty? c) (= (collection-size c) 0))) #t)", "tags": ["data", "collection-utils", "composition", "collection-empty?", "property"], "split": "train"}
{"id": "collection_utils_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff making a collection from empty block list yields an empty collection.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(collection-empty? (make-collection-from-blocks 'group \"empty\" '()))", "verify_expr": "(equal? (collection-empty? (make-collection-from-blocks 'group \"empty\" '())) #t)", "tags": ["data", "collection-utils", "composition", "make-collection-from-blocks", "property"], "split": "train"}
{"id": "collection_utils_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff collection-add preserves original collection size (immutability check).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (= (collection-size c) 1)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (= (collection-size c) 1))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (= (collection-size c) 1)) #t)", "tags": ["data", "collection-utils", "composition", "collection-add", "property"], "split": "train"}
{"id": "collection_utils_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff removing an existing hash decreases size by one.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))] [c2 (collection-remove c (hash-block b1))]) (= (collection-size c2) (- (collection-size c) 1))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))] [c2 (collection-remove c (hash-block b1))]) (= (collection-size c2) (- (collection-size c) 1)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))] [c2 (collection-remove c (hash-block b1))]) (= (collection-size c2) (- (collection-size c) 1))) #t)", "tags": ["data", "collection-utils", "composition", "collection-remove", "property"], "split": "train"}
{"id": "collection_utils_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap doubling over '(1 2 3) via foldr and cons.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (foldr (lambda (x acc) (cons (* 2 x) acc)) '() '(1 2 3)) '(2 4 6))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(foldr (lambda (x acc) (cons (* 2 x) acc)) '() '(1 2 3))", "verify_expr": "(equal? (foldr (lambda (x acc) (cons (* 2 x) acc)) '() '(1 2 3)) '(2 4 6))", "tags": ["data", "collection-utils", "composition", "foldr", "fold"], "split": "train"}
{"id": "collection_utils_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a collection from three blocks, then return hashes count via foldr over collection-hashes.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))]) (foldr (lambda (h acc) (+ acc 1)) 0 (collection-hashes c)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))]) (foldr (lambda (h acc) (+ acc 1)) 0 (collection-hashes c))) 3)", "tags": ["data", "collection-utils", "composition", "collection-hashes", "integration"], "split": "train"}
{"id": "collection_utils_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: small integration task across module primitives.\n\nUse named-let to add two members and return final collection-size.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c0 (make-collection-from-blocks 'group \"demo\" (list b1))]) (let loop ([members (list b2 b3)] [acc c0]) (if (null? members) (collection-size acc) (loop (cdr members) (collection-add acc (car members)))))) 3)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c0 (make-collection-from-blocks 'group \"demo\" (list b1))]) (let loop ([members (list b2 b3)] [acc c0]) (if (null? members) (collection-size acc) (loop (cdr members) (collection-add acc (car members))))))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c0 (make-collection-from-blocks 'group \"demo\" (list b1))]) (let loop ([members (list b2 b3)] [acc c0]) (if (null? members) (collection-size acc) (loop (cdr members) (collection-add acc (car members)))))) 3)", "tags": ["data", "collection-utils", "composition", "collection-size", "loop"], "split": "train"}
{"id": "collection_utils_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd one block to an empty collection and test emptiness.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c0 (make-collection-from-blocks 'group \"e\" '())] [c1 (collection-add c0 b1)]) (collection-empty? c1)) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c0 (make-collection-from-blocks 'group \"e\" '())] [c1 (collection-add c0 b1)]) (collection-empty? c1))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [c0 (make-collection-from-blocks 'group \"e\" '())] [c1 (collection-add c0 b1)]) (collection-empty? c1)) #f)", "tags": ["data", "collection-utils", "composition", "collection-empty?", "integration"], "split": "train"}
{"id": "collection_utils_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd then remove same member and compare resulting size to original.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-remove (collection-add c b2) (hash-block b2))]) (= (collection-size c2) (collection-size c))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-remove (collection-add c b2) (hash-block b2))]) (= (collection-size c2) (collection-size c)))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-remove (collection-add c b2) (hash-block b2))]) (= (collection-size c2) (collection-size c))) #t)", "tags": ["data", "collection-utils", "composition", "collection-add", "integration"], "split": "train"}
{"id": "collection_utils_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove all duplicate hashes from a manually-crafted refs vector.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([h 42] [c (make-block 'collection (string->utf8 \"dup\") (vector h h 7))] [c2 (collection-remove c h)]) (collection-hashes c2)) '(7))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([h 42] [c (make-block 'collection (string->utf8 \"dup\") (vector h h 7))] [c2 (collection-remove c h)]) (collection-hashes c2))", "verify_expr": "(equal? (let* ([h 42] [c (make-block 'collection (string->utf8 \"dup\") (vector h h 7))] [c2 (collection-remove c h)]) (collection-hashes c2)) '(7))", "tags": ["data", "collection-utils", "composition", "collection-remove", "integration"], "split": "train"}
{"id": "collection_utils_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge, then prepend one member with collection-add, then report size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a))] [c2 (make-collection-from-blocks 'group \"y\" (list b))] [m (collection-merge c1 c2)] [m2 (collection-add m c)]) (collection-size m2))", "verify_expr": "(equal? (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a))] [c2 (make-collection-from-blocks 'group \"y\" (list b))] [m (collection-merge c1 c2)] [m2 (collection-add m c)]) (collection-size m2)) 3)", "tags": ["data", "collection-utils", "composition", "collection-merge", "integration"], "split": "train"}
