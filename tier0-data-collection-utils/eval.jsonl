{"id": "collection_utils_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-hashes", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-hashes`\nSpec: Extract collection ref hashes as a list in vector order.\n\nWrite exactly one Scheme function definition for `collection-hashes`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [coll (make-block 'collection (string->utf8 \"c\") (vector (hash-block b1) (hash-block b2)))]) (equal? (collection-hashes coll) (list (hash-block b1) (hash-block b2)))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-hashes"], "split": "eval"}
{"id": "collection_utils_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-empty?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-empty?`\nSpec: Return #t iff collection has zero refs.\n\nWrite exactly one Scheme function definition for `collection-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(collection-empty? (make-block 'collection (string->utf8 \"e\") (vector)))\n(not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))", "verify_expr": "(let ()\n  (define (collection-empty? collection)\n  (= (vector-length (block-refs collection)) 0))\n  (and (collection-empty? (make-block 'collection (string->utf8 \"e\") (vector))) (not (collection-empty? (make-block 'collection (string->utf8 \"n\") (vector 1))))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-empty?"], "split": "eval"}
{"id": "collection_utils_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-add", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this collection utility in Fold-native Scheme.\n\nTarget module: lattice/data/collection-utils.ss\nFunction: `collection-add`\nSpec: Return a new collection with new-member hash prepended to existing refs.\n\nWrite exactly one Scheme function definition for `collection-add`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-add collection new-member)\n  (let* ([old-refs (block-refs collection)]\n         [new-hash (hash-block new-member)]\n         [new-refs (list->vector (cons new-hash (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1))] [c2 (collection-add c b2)]) (and (= (collection-size c) 1) (= (collection-size c2) 2) (equal? (car (collection-hashes c2)) (hash-block b2)))))", "tags": ["data", "collection-utils", "spec-to-code", "collection-add"], "split": "eval"}
{"id": "collection_utils_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-size`.\nReturn only the Scheme definition.\n\n```python\ndef collection_size(collection):\n    return len(block_refs(collection))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (collection-size collection)\n  (vector-length (block-refs collection)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (let ([c1 (make-block 'collection (string->utf8 \"empty\") (vector))] [c2 (make-block 'collection (string->utf8 \"full\") (vector 1 2 3))]) (and (= (collection-size c1) 0) (= (collection-size c2) 3))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-size"], "split": "eval"}
{"id": "collection_utils_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-collection-from-blocks`.\nReturn only the Scheme definition.\n\n```python\ndef make_collection_from_blocks(tag, name, blocks):\n    hashes = [hash_block(b) for b in blocks]\n    payload = f\"{name} ({len(blocks)} members)\"\n    return make_block(tag, utf8(payload), list_to_vector(hashes))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "python-to-scheme", "make-collection-from-blocks"], "split": "eval"}
{"id": "collection_utils_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-remove", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `collection-remove`.\nReturn only the Scheme definition.\n\n```python\ndef collection_remove(collection, member_hash):\n    old_refs = block_refs(collection)\n    new_refs = list_to_vector([h for h in vector_to_list(old_refs) if h != member_hash])\n    return make_block(block_tag(collection), block_payload(collection), new_refs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-hashes collection)\n  (let ([refs (block-refs collection)])\n       (let loop ([i 0]\n                  [result '()])\n            (if (>= i (vector-length refs))\n                (reverse result)\n                (loop (+ i 1)\n                      (cons (vector-ref refs i) result))))))\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-remove collection member-hash)\n  (let* ([old-refs (block-refs collection)]\n         [new-refs (list->vector\n                    (filter (lambda (h) (not (equal? h member-hash)))\n                            (vector->list old-refs)))])\n        (make-block (block-tag collection)\n                    (block-payload collection)\n                    new-refs)))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))] [c2 (collection-remove c (hash-block b2))]) (and (= (collection-size c2) 2) (not (member (hash-block b2) (collection-hashes c2))))))", "tags": ["data", "collection-utils", "python-to-scheme", "collection-remove"], "split": "eval"}
{"id": "collection_utils_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `foldr` in `lattice/data/collection-utils.ss`.\nKnown issue: foldr must be right-associative, not left-associative.\n\n```scheme\n(define (foldr f init lst)\n  (fold-left f init lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (foldr cons '() '(1 2 3)) '(1 2 3))\n(= (foldr + 0 '(1 2 3 4)) 10)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))", "verify_expr": "(let ()\n  (define (foldr f init lst)\n  (if (null? lst)\n      init\n      (f (car lst) (foldr f init (cdr lst)))))\n  (and (equal? (foldr cons '() '(1 2 3)) '(1 2 3)) (= (foldr + 0 '(1 2 3 4)) 10)))", "tags": ["data", "collection-utils", "bugfix", "foldr"], "split": "eval"}
{"id": "collection_utils_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-collection-from-blocks` in `lattice/data/collection-utils.ss`.\nKnown issue: Must include hashes of all provided blocks in refs.\n\n```scheme\n(define (make-collection-from-blocks tag name blocks)\n  (make-block tag (string->utf8 name) (vector)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2))]) (and (eq? (block-tag c) 'group) (= (collection-size c) 2))))", "tags": ["data", "collection-utils", "bugfix", "make-collection-from-blocks"], "split": "eval"}
{"id": "collection_utils_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `collection-merge` in `lattice/data/collection-utils.ss`.\nKnown issue: Module ordering is refs1 then refs2, with merged payload including member count.\n\n```scheme\n(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs2) (vector->list refs1))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 \"merged\")\n                    new-refs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))", "verify_expr": "(let ()\n  (define (collection-size collection)\n  (vector-length (block-refs collection)))\n  (define (make-collection-from-blocks tag name blocks)\n  (let ([hashes (map hash-block blocks)])\n       (make-block tag\n                   (string->utf8 (format \"~a (~a members)\" name (length blocks)))\n                   (list->vector hashes))))\n  (define (collection-merge coll1 coll2)\n  (let* ([refs1 (block-refs coll1)]\n         [refs2 (block-refs coll2)]\n         [combined (append (vector->list refs1) (vector->list refs2))]\n         [new-refs (list->vector combined)])\n        (make-block (block-tag coll1)\n                    (string->utf8 (format \"merged (~a members)\" (length combined)))\n                    new-refs)))\n  (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))] [m (collection-merge c1 c2)]) (and (= (collection-size m) 3) (eq? (block-tag m) 'group))))", "tags": ["data", "collection-utils", "bugfix", "collection-merge"], "split": "eval"}
{"id": "collection_utils_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute sum of '(1 2 3 4) using foldr.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(foldr + 0 '(1 2 3 4))", "verify_expr": "(equal? (foldr + 0 '(1 2 3 4)) 10)", "tags": ["data", "collection-utils", "composition", "foldr", "direct"], "split": "eval"}
{"id": "collection_utils_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "make-collection-from-blocks", "prompt": "Task mode: small integration task across module primitives.\n\nCreate a collection from three blocks and return its size.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))]) (collection-size c)) 3)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))]) (collection-size c))", "verify_expr": "(equal? (let* ([b1 (make-block 'entity (string->utf8 \"a\") (vector))] [b2 (make-block 'entity (string->utf8 \"b\") (vector))] [b3 (make-block 'entity (string->utf8 \"c\") (vector))] [c (make-collection-from-blocks 'group \"demo\" (list b1 b2 b3))]) (collection-size c)) 3)", "tags": ["data", "collection-utils", "composition", "make-collection-from-blocks", "direct"], "split": "eval"}
{"id": "collection_utils_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "foldr", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff foldr subtraction is right-associative on '(1 2 3).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (foldr - 0 '(1 2 3)) 2) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (foldr - 0 '(1 2 3)) 2)", "verify_expr": "(equal? (= (foldr - 0 '(1 2 3)) 2) #t)", "tags": ["data", "collection-utils", "composition", "foldr", "property"], "split": "eval"}
{"id": "collection_utils_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merged size equals sum of input sizes.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))]) (= (collection-size (collection-merge c1 c2)) (+ (collection-size c1) (collection-size c2))))", "verify_expr": "(equal? (let* ([a (make-block 'entity (string->utf8 \"a\") (vector))] [b (make-block 'entity (string->utf8 \"b\") (vector))] [c (make-block 'entity (string->utf8 \"c\") (vector))] [c1 (make-collection-from-blocks 'group \"x\" (list a b))] [c2 (make-collection-from-blocks 'group \"y\" (list c))]) (= (collection-size (collection-merge c1 c2)) (+ (collection-size c1) (collection-size c2)))) #t)", "tags": ["data", "collection-utils", "composition", "collection-merge", "property"], "split": "eval"}
{"id": "collection_utils_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-utils.ss", "source_test": "lattice/data/test-collection-utils.ss", "source_function": "collection-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two empty collections and test collection-empty?.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([c1 (make-collection-from-blocks 'group \"x\" '())] [c2 (make-collection-from-blocks 'group \"y\" '())] [m (collection-merge c1 c2)]) (collection-empty? m))", "verify_expr": "(equal? (let* ([c1 (make-collection-from-blocks 'group \"x\" '())] [c2 (make-collection-from-blocks 'group \"y\" '())] [m (collection-merge c1 c2)]) (collection-empty? m)) #t)", "tags": ["data", "collection-utils", "composition", "collection-merge", "edge-case"], "split": "eval"}
