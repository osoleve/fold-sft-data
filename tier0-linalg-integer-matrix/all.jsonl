{"id": "integer_matrix_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `int-mat-ref`\nSpec: Read matrix element at (i,j) from row-major flat vector with `cols` columns.\n\nWrite exactly one Scheme function definition for `int-mat-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3)\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "spec-to-code", "int-mat-ref"], "split": "train"}
{"id": "integer_matrix_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (int-mat-ref data cols i j)\n  ;; TODO: index row-major flat storage\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `int-mat-ref`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3)\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "int-mat-ref"], "split": "train"}
{"id": "integer_matrix_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `int-mat-set!`\nSpec: Mutate row-major flat vector entry at (i,j) to val using `cols` stride.\n\nWrite exactly one Scheme function definition for `int-mat-set!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (int-mat-set! data cols i j val)\n  ;; TODO: mutate row-major flat storage\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `int-mat-set!`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `int-mat-copy`\nSpec: Return a fresh copy of vector v with identical contents.\n\nWrite exactly one Scheme function definition for `int-mat-copy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "int-mat-copy"], "split": "eval"}
{"id": "integer_matrix_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (int-mat-copy v)\n  ;; TODO: allocate and copy vector contents\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `int-mat-copy`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "int-mat-copy"], "split": "train"}
{"id": "integer_matrix_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `swap-rows!`\nSpec: In-place swap of rows i1 and i2 in flat matrix data.\n\nWrite exactly one Scheme function definition for `swap-rows!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "swap-rows!"], "split": "eval"}
{"id": "integer_matrix_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (swap-rows! data rows cols i1 i2)\n  ;; TODO: swap two rows in-place\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `swap-rows!`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "swap-rows!"], "split": "train"}
{"id": "integer_matrix_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `swap-cols!`\nSpec: In-place swap of columns j1 and j2 in flat matrix data.\n\nWrite exactly one Scheme function definition for `swap-cols!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "swap-cols!"], "split": "train"}
{"id": "integer_matrix_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (swap-cols! data rows cols j1 j2)\n  ;; TODO: swap two columns in-place\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `swap-cols!`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "swap-cols!"], "split": "train"}
{"id": "integer_matrix_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `make-identity-vec`\nSpec: Create n x n identity matrix as flat row-major vector.\n\nWrite exactly one Scheme function definition for `make-identity-vec`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "make-identity-vec"], "split": "eval"}
{"id": "integer_matrix_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-identity-vec n)\n  ;; TODO: create flat identity matrix vector\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-identity-vec`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "make-identity-vec"], "split": "train"}
{"id": "integer_matrix_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `matrix-minor`\nSpec: Return matrix with row i and column j removed.\n\nWrite exactly one Scheme function definition for `matrix-minor`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (matrix-minor mat i j)\n  ;; TODO: remove row i and column j\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `matrix-minor`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `matrix-determinant-int`\nSpec: Compute exact integer determinant using Bareiss elimination.\n\nWrite exactly one Scheme function definition for `matrix-determinant-int`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "spec-to-code", "matrix-determinant-int"], "split": "train"}
{"id": "integer_matrix_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (matrix-determinant-int mat)\n  ;; TODO: Bareiss determinant algorithm for integer matrices\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `matrix-determinant-int`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "skeleton-completion", "matrix-determinant-int"], "split": "train"}
{"id": "integer_matrix_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `int-mat-ref`.\nReturn only the Scheme definition.\n\n```python\ndef int_mat_ref(data, cols, i, j):\n    return data[i * cols + j]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3)\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "int-mat-ref"], "split": "eval"}
{"id": "integer_matrix_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `int-mat-ref`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (imat-ref d c i j)\n  (vector-ref d (+ (* i c) j)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "int-mat-ref"], "split": "train"}
{"id": "integer_matrix_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `int-mat-set!`.\nReturn only the Scheme definition.\n\n```python\ndef int_mat_set(data, cols, i, j, val):\n    data[i * cols + j] = val\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `int-mat-set!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (imat-set! d c i j v)\n  (vector-set! d (+ (* i c) j) v))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `int-mat-copy`.\nReturn only the Scheme definition.\n\n```python\ndef int_mat_copy(v):\n    out = [0] * len(v)\n    for i in range(len(v)):\n        out[i] = v[i]\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "int-mat-copy"], "split": "train"}
{"id": "integer_matrix_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `int-mat-copy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (imat-copy v)\n  (let* ((n (vector-length v))\n         (out (make-vector n 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i n) out)\n      (vector-set! out i (vector-ref v i)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "int-mat-copy"], "split": "train"}
{"id": "integer_matrix_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `swap-rows!`.\nReturn only the Scheme definition.\n\n```python\ndef swap_rows(data, rows, cols, i1, i2):\n    if i1 != i2:\n        for j in range(cols):\n            idx1 = i1 * cols + j\n            idx2 = i2 * cols + j\n            data[idx1], data[idx2] = data[idx2], data[idx1]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "swap-rows!"], "split": "train"}
{"id": "integer_matrix_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `swap-rows!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (swap-rows0! d r c a b)\n  (unless (= a b)\n    (do ((j 0 (+ j 1)))\n        ((= j c))\n      (let ((tmp (int-mat-ref d c a j)))\n        (int-mat-set! d c a j (int-mat-ref d c b j))\n        (int-mat-set! d c b j tmp)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "swap-rows!"], "split": "train"}
{"id": "integer_matrix_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `swap-cols!`.\nReturn only the Scheme definition.\n\n```python\ndef swap_cols(data, rows, cols, j1, j2):\n    if j1 != j2:\n        for i in range(rows):\n            idx1 = i * cols + j1\n            idx2 = i * cols + j2\n            data[idx1], data[idx2] = data[idx2], data[idx1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "swap-cols!"], "split": "eval"}
{"id": "integer_matrix_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `swap-cols!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (swap-cols0! d r c a b)\n  (unless (= a b)\n    (do ((i 0 (+ i 1)))\n        ((= i r))\n      (let ((tmp (int-mat-ref d c i a)))\n        (int-mat-set! d c i a (int-mat-ref d c i b))\n        (int-mat-set! d c i b tmp)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "swap-cols!"], "split": "train"}
{"id": "integer_matrix_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-identity-vec`.\nReturn only the Scheme definition.\n\n```python\ndef make_identity_vec(n):\n    data = [0] * (n * n)\n    for i in range(n):\n        data[i * n + i] = 1\n    return data\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "make-identity-vec"], "split": "train"}
{"id": "integer_matrix_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-identity-vec`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (identity-flat n)\n  (let ((data (make-vector (* n n) 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "make-identity-vec"], "split": "train"}
{"id": "integer_matrix_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `matrix-minor`.\nReturn only the Scheme definition.\n\n```python\ndef matrix_minor(mat, i, j):\n    n = mat_rows(mat)\n    data = mat_data(mat)\n    new_n = n - 1\n    out = [0] * (new_n * new_n)\n    new_row = 0\n    for row in range(n):\n        if row == i:\n            continue\n        new_col = 0\n        for col in range(n):\n            if col == j:\n                continue\n            out[new_row * new_n + new_col] = data[row * n + col]\n            new_col += 1\n        new_row += 1\n    return ['matrix', new_n, new_n, list_to_vector(out)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `matrix-minor`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (minor0 m i j)\n  (let* ((n (matrix-rows m))\n         (data (matrix-data m))\n         (new-n (- n 1))\n         (out (make-vector (* new-n new-n) 0)))\n    (do ((row 0 (+ row 1))\n         (new-row 0 (if (= row i) new-row (+ new-row 1))))\n        ((= row n) (list 'matrix new-n new-n out))\n      (unless (= row i)\n        (do ((col 0 (+ col 1))\n             (new-col 0 (if (= col j) new-col (+ new-col 1))))\n            ((= col n))\n          (unless (= col j)\n            (vector-set! out (+ (* new-row new-n) new-col)\n                         (vector-ref data (+ (* row n) col)))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `matrix-determinant-int`.\nReturn only the Scheme definition.\n\n```python\ndef matrix_determinant_int(mat):\n    n = mat_rows(mat)\n    if n == 0:\n        return 1\n    data = int_mat_copy(mat_data(mat))\n    sign = 1\n    k = 0\n    prev_pivot = 1\n    while k < n - 1:\n        pivot_idx = None\n        i = k\n        while i < n:\n            if int_mat_ref(data, n, i, k) != 0:\n                pivot_idx = i\n                break\n            i += 1\n        if pivot_idx is None:\n            return 0\n        if pivot_idx != k:\n            swap_rows(data, n, n, k, pivot_idx)\n            sign = -sign\n        pivot = int_mat_ref(data, n, k, k)\n        for i in range(k + 1, n):\n            for j in range(k + 1, n):\n                new_val = ((pivot * int_mat_ref(data, n, i, j)) - (int_mat_ref(data, n, i, k) * int_mat_ref(data, n, k, j))) // prev_pivot\n                int_mat_set(data, n, i, j, new_val)\n        prev_pivot = pivot\n        k += 1\n    return sign * int_mat_ref(data, n, n - 1, n - 1)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "matrix-determinant-int"], "split": "train"}
{"id": "integer_matrix_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `matrix-determinant-int`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (det-int0 mat)\n  (let* ((n (matrix-rows mat)))\n    (if (= n 0)\n        1\n        (let ((data (int-mat-copy (matrix-data mat)))\n              (sign 1))\n          (let loop ((k 0) (prev 1))\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ((pidx (let search ((i k))\n                             (cond ((>= i n) #f)\n                                   ((not (= 0 (int-mat-ref data n i k))) i)\n                                   (else (search (+ i 1)))))))\n                  (if (not pidx)\n                      0\n                      (begin\n                        (when (not (= pidx k))\n                          (swap-rows! data n n k pidx)\n                          (set! sign (- sign)))\n                        (let ((pivot (int-mat-ref data n k k)))\n                          (do ((i (+ k 1) (+ i 1)))\n                              ((= i n))\n                            (do ((j (+ k 1) (+ j 1)))\n                                ((= j n))\n                              (let ((new-val (quotient (- (* pivot (int-mat-ref data n i j))\n                                                          (* (int-mat-ref data n i k)\n                                                             (int-mat-ref data n k j)))\n                                                      prev)))\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "matrix-determinant-int"], "split": "eval"}
{"id": "integer_matrix_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-ref` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Row/column indexing is transposed; use i*cols + j.\n\n```scheme\n(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* j cols) i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3)\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-ref"], "split": "eval"}
{"id": "integer_matrix_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-ref` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Stride must be exactly cols, not cols+1.\n\n```scheme\n(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i (+ cols 1)) j)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3)\n(= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-ref"], "split": "train"}
{"id": "integer_matrix_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-set!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Target index is wrong; mutation must use row-major indexing.\n\n```scheme\n(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* j cols) i) val))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-set!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Function must mutate data in-place.\n\n```scheme\n(define (int-mat-set! data cols i j val)\n  data)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 99) (and (= (int-mat-ref d 2 1 0) 99) (equal? d (vector 1 2 99 4)))))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-set!"], "split": "train"}
{"id": "integer_matrix_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-copy` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Must return a fresh vector copy, not alias original.\n\n```scheme\n(define (int-mat-copy v)\n  v)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-copy"], "split": "train"}
{"id": "integer_matrix_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-copy` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Loop termination skips copying the last element.\n\n```scheme\n(define (int-mat-copy v)\n  (let* ([n (vector-length v)] [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i (- n 1)) result)\n      (vector-set! result i (vector-ref v i)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-copy"], "split": "train"}
{"id": "integer_matrix_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `swap-rows!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Must swap every column, not just column 0.\n\n```scheme\n(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (let ([tmp (int-mat-ref data cols i1 0)])\n      (int-mat-set! data cols i1 0 (int-mat-ref data cols i2 0))\n      (int-mat-set! data cols i2 0 tmp))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "bugfix", "swap-rows!"], "split": "train"}
{"id": "integer_matrix_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `swap-rows!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Loop bound must be cols, not rows; all columns must be swapped.\n\n```scheme\n(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j rows))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "bugfix", "swap-rows!"], "split": "train"}
{"id": "integer_matrix_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `swap-cols!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Must swap every row, not just row 0.\n\n```scheme\n(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (let ([tmp (int-mat-ref data cols 0 j1)])\n      (int-mat-set! data cols 0 j1 (int-mat-ref data cols 0 j2))\n      (int-mat-set! data cols 0 j2 tmp))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "bugfix", "swap-cols!"], "split": "eval"}
{"id": "integer_matrix_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `swap-cols!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Loop bound must be rows, not cols; all rows must be swapped.\n\n```scheme\n(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i cols))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "bugfix", "swap-cols!"], "split": "train"}
{"id": "integer_matrix_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-vec` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Diagonal index should be i*n+i, not shifted to the superdiagonal.\n\n```scheme\n(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) (+ i 1)) 1))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "bugfix", "make-identity-vec"], "split": "train"}
{"id": "integer_matrix_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-vec` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Identity requires zeros off-diagonal.\n\n```scheme\n(define (make-identity-vec n)\n  (make-vector (* n n) 1))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "bugfix", "make-identity-vec"], "split": "train"}
{"id": "integer_matrix_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-minor` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Minor must remove one row and one column.\n\n```scheme\n(define (matrix-minor mat i j)\n  mat)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "bugfix", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-minor` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Result write index is transposed; preserve row-major minor layout.\n\n```scheme\n(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)] [data (matrix-data mat)] [new-n (- n 1)] [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)] [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)] [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-col new-n) new-row)\n                        (vector-ref data (+ (* row n) col)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))", "verify_expr": "(let ()\n  (define (matrix-minor mat i j)\n  (let* ([n (matrix-rows mat)]\n         [data (matrix-data mat)]\n         [new-n (- n 1)]\n         [result (make-vector (* new-n new-n) 0)])\n    (do ([row 0 (+ row 1)]\n         [new-row 0 (if (= row i) new-row (+ new-row 1))])\n        ((= row n) (list 'matrix new-n new-n result))\n      (when (not (= row i))\n        (do ([col 0 (+ col 1)]\n             [new-col 0 (if (= col j) new-col (+ new-col 1))])\n            ((= col n))\n          (when (not (= col j))\n            (vector-set! result (+ (* new-row new-n) new-col)\n                        (vector-ref data (+ (* row n) col)))))))))\n  (and (equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9))) (equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))))", "tags": ["linalg", "integer-matrix", "bugfix", "matrix-minor"], "split": "train"}
{"id": "integer_matrix_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-determinant-int` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Determinant must be computed, not constant.\n\n```scheme\n(define (matrix-determinant-int mat)\n  0)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "bugfix", "matrix-determinant-int"], "split": "train"}
{"id": "integer_matrix_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-determinant-int` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Empty matrix determinant should be 1, and row swaps must flip sign.\n\n```scheme\n(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        0\n        (let ([data (int-mat-copy (matrix-data mat))] [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (int-mat-ref data n (- n 1) (- n 1))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond [(>= i n) #f] [(not (= 0 (int-mat-ref data n i k))) i] [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k)) (swap-rows! data n n k pivot-idx))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (int-mat-set! data n i j (quotient (- (* pivot (int-mat-ref data n i j)) (* (int-mat-ref data n i k) (int-mat-ref data n k j))) prev-pivot))))\n                          (loop (+ k 1) pivot))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-determinant-int (matrix-from-lists '())) 1)\n(= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "bugfix", "matrix-determinant-int"], "split": "eval"}
{"id": "integer_matrix_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: small integration task across module primitives.\n\nRead entry (1,2) from flat 2x3 data vector.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(int-mat-ref (vector 1 2 3 4 5 6) 3 1 2)", "verify_expr": "(equal? (int-mat-ref (vector 1 2 3 4 5 6) 3 1 2) 6)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-ref", "direct"], "split": "eval"}
{"id": "integer_matrix_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead entry (0,0) from flat 2x2 vector.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (int-mat-ref (vector 9 8 7 6) 2 0 0) 9)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(int-mat-ref (vector 9 8 7 6) 2 0 0)", "verify_expr": "(equal? (int-mat-ref (vector 9 8 7 6) 2 0 0) 9)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-ref", "direct"], "split": "train"}
{"id": "integer_matrix_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: small integration task across module primitives.\n\nSet (1,0)=42 in 2x2 data and return resulting vector.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 42) d) (vector 1 2 42 4))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 42) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4)]) (int-mat-set! d 2 1 0 42) d) (vector 1 2 42 4))", "tags": ["linalg", "integer-matrix", "composition", "int-mat-set!", "direct"], "split": "train"}
{"id": "integer_matrix_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: compose existing APIs into one expression.\n\nSet an entry then read it back with int-mat-ref.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4 5 6)]) (int-mat-set! d 3 0 1 77) (int-mat-ref d 3 0 1)) 77)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (int-mat-set! d 3 0 1 77) (int-mat-ref d 3 0 1))", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (int-mat-set! d 3 0 1 77) (int-mat-ref d 3 0 1)) 77)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-set!", "direct"], "split": "train"}
{"id": "integer_matrix_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nCopy vector '(1 2 3) and return the copy.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(int-mat-copy (vector 1 2 3))", "verify_expr": "(equal? (int-mat-copy (vector 1 2 3)) (vector 1 2 3))", "tags": ["linalg", "integer-matrix", "composition", "int-mat-copy", "direct"], "split": "train"}
{"id": "integer_matrix_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: small integration task across module primitives.\n\nMutate source after int-mat-copy and return copied first entry.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (vector-ref c 0)) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (vector-ref c 0))", "verify_expr": "(equal? (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (vector-ref c 0)) 1)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-copy", "direct"], "split": "train"}
{"id": "integer_matrix_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: compose existing APIs into one expression.\n\nSwap rows 0 and 1 in 2x3 data and return vector.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) d) (vector 4 5 6 1 2 3))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) d) (vector 4 5 6 1 2 3))", "tags": ["linalg", "integer-matrix", "composition", "swap-rows!", "direct"], "split": "train"}
{"id": "integer_matrix_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCall swap-rows! with identical row indices and return data.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4)]) (swap-rows! d 2 2 1 1) d) (vector 1 2 3 4))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 1 2 3 4)]) (swap-rows! d 2 2 1 1) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4)]) (swap-rows! d 2 2 1 1) d) (vector 1 2 3 4))", "tags": ["linalg", "integer-matrix", "composition", "swap-rows!", "edge-case"], "split": "train"}
{"id": "integer_matrix_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSwap columns 0 and 2 in 2x3 data and return vector.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) d) (vector 3 2 1 6 5 4))", "tags": ["linalg", "integer-matrix", "composition", "swap-cols!", "direct"], "split": "eval"}
{"id": "integer_matrix_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: compose existing APIs into one expression.\n\nCall swap-cols! with identical column indices and return data.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4)]) (swap-cols! d 2 2 0 0) d) (vector 1 2 3 4))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d (vector 1 2 3 4)]) (swap-cols! d 2 2 0 0) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4)]) (swap-cols! d 2 2 0 0) d) (vector 1 2 3 4))", "tags": ["linalg", "integer-matrix", "composition", "swap-cols!", "edge-case"], "split": "train"}
{"id": "integer_matrix_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild identity flat vector for n=3.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(make-identity-vec 3)", "verify_expr": "(equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))", "tags": ["linalg", "integer-matrix", "composition", "make-identity-vec", "direct"], "split": "train"}
{"id": "integer_matrix_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: small integration task across module primitives.\n\nBuild identity flat vector for n=1.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (make-identity-vec 1) (vector 1))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(make-identity-vec 1)", "verify_expr": "(equal? (make-identity-vec 1) (vector 1))", "tags": ["linalg", "integer-matrix", "composition", "make-identity-vec", "direct"], "split": "train"}
{"id": "integer_matrix_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: small integration task across module primitives.\n\nTake minor removing row 1 column 1 from 3x3 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1))", "verify_expr": "(equal? (matrix->lists (matrix-minor (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 1)) '((1 3) (7 9)))", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "direct"], "split": "train"}
{"id": "integer_matrix_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: compose existing APIs into one expression.\n\nTake minor removing row 0 column 1 from 2x2 matrix.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1))", "verify_expr": "(equal? (matrix->lists (matrix-minor (matrix-from-lists '((3 4) (1 2))) 0 1)) '((1)))", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "direct"], "split": "train"}
{"id": "integer_matrix_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nCompute determinant of 2x2 integer matrix ((3 4) (1 2)).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-determinant-int (matrix-from-lists '((3 4) (1 2))))", "verify_expr": "(equal? (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "direct"], "split": "train"}
{"id": "integer_matrix_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute determinant of 3x3 matrix ((1 2 3) (4 5 6) (7 8 10)).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10))))", "verify_expr": "(equal? (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "direct"], "split": "train"}
{"id": "integer_matrix_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff setting then reading same index recovers written value.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 0 1 2 3 4 5)]) (int-mat-set! d 3 1 1 88) (= (int-mat-ref d 3 1 1) 88)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 0 1 2 3 4 5)]) (int-mat-set! d 3 1 1 88) (= (int-mat-ref d 3 1 1) 88))", "verify_expr": "(equal? (let ([d (vector 0 1 2 3 4 5)]) (int-mat-set! d 3 1 1 88) (= (int-mat-ref d 3 1 1) 88)) #t)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-set!", "property"], "split": "eval"}
{"id": "integer_matrix_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff copy length equals source length.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (vector-length (int-mat-copy (vector 5 6 7 8))) 4) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (vector-length (int-mat-copy (vector 5 6 7 8))) 4)", "verify_expr": "(equal? (= (vector-length (int-mat-copy (vector 5 6 7 8))) 4) #t)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-copy", "property"], "split": "train"}
{"id": "integer_matrix_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff swap-rows! preserves sum of all elements.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([d (vector 1 2 3 4 5 6)] [before (+ 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (= (+ (vector-ref d 0) (vector-ref d 1) (vector-ref d 2) (vector-ref d 3) (vector-ref d 4) (vector-ref d 5)) before)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([d (vector 1 2 3 4 5 6)] [before (+ 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (= (+ (vector-ref d 0) (vector-ref d 1) (vector-ref d 2) (vector-ref d 3) (vector-ref d 4) (vector-ref d 5)) before))", "verify_expr": "(equal? (let* ([d (vector 1 2 3 4 5 6)] [before (+ 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (= (+ (vector-ref d 0) (vector-ref d 1) (vector-ref d 2) (vector-ref d 3) (vector-ref d 4) (vector-ref d 5)) before)) #t)", "tags": ["linalg", "integer-matrix", "composition", "swap-rows!", "property"], "split": "train"}
{"id": "integer_matrix_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff swap-cols! preserves sum of all elements.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([d (vector 1 2 3 4 5 6)] [before (+ 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (= (+ (vector-ref d 0) (vector-ref d 1) (vector-ref d 2) (vector-ref d 3) (vector-ref d 4) (vector-ref d 5)) before))", "verify_expr": "(equal? (let* ([d (vector 1 2 3 4 5 6)] [before (+ 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (= (+ (vector-ref d 0) (vector-ref d 1) (vector-ref d 2) (vector-ref d 3) (vector-ref d 4) (vector-ref d 5)) before)) #t)", "tags": ["linalg", "integer-matrix", "composition", "swap-cols!", "property"], "split": "train"}
{"id": "integer_matrix_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff identity vector for n=4 has exactly 4 ones.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (make-identity-vec 4)]) (= (let loop ([i 0] [acc 0]) (if (= i (vector-length d)) acc (loop (+ i 1) (+ acc (if (= (vector-ref d i) 1) 1 0))))) 4)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (make-identity-vec 4)]) (= (let loop ([i 0] [acc 0]) (if (= i (vector-length d)) acc (loop (+ i 1) (+ acc (if (= (vector-ref d i) 1) 1 0))))) 4))", "verify_expr": "(equal? (let ([d (make-identity-vec 4)]) (= (let loop ([i 0] [acc 0]) (if (= i (vector-length d)) acc (loop (+ i 1) (+ acc (if (= (vector-ref d i) 1) 1 0))))) 4)) #t)", "tags": ["linalg", "integer-matrix", "composition", "make-identity-vec", "property"], "split": "train"}
{"id": "integer_matrix_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff minor of 4x4 has dimension 3x3.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (matrix-minor (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 16))) 2 1)]) (and (= (matrix-rows m) 3) (= (matrix-cols m) 3))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (matrix-minor (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 16))) 2 1)]) (and (= (matrix-rows m) 3) (= (matrix-cols m) 3)))", "verify_expr": "(equal? (let ([m (matrix-minor (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12) (13 14 15 16))) 2 1)]) (and (= (matrix-rows m) 3) (= (matrix-cols m) 3))) #t)", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "property"], "split": "train"}
{"id": "integer_matrix_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff determinant of identity 4x4 is 1.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (matrix-determinant-int (matrix-identity 4)) 1)", "verify_expr": "(equal? (= (matrix-determinant-int (matrix-identity 4)) 1) #t)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "property"], "split": "train"}
{"id": "integer_matrix_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff determinant of singular matrix is 0.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0)", "verify_expr": "(equal? (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) #t)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "property"], "split": "eval"}
{"id": "integer_matrix_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply two row swaps and return final vector.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (swap-rows! d 2 3 0 1) d) (vector 1 2 3 4 5 6))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (swap-rows! d 2 3 0 1) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (swap-rows! d 2 3 0 1) d) (vector 1 2 3 4 5 6))", "tags": ["linalg", "integer-matrix", "composition", "swap-rows!", "integration"], "split": "train"}
{"id": "integer_matrix_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: small integration task across module primitives.\n\nApply a column swap then read the new value at (1,0).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (int-mat-ref d 3 1 0))", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (int-mat-ref d 3 1 0)) 6)", "tags": ["linalg", "integer-matrix", "composition", "swap-cols!", "integration"], "split": "train"}
{"id": "integer_matrix_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: small integration task across module primitives.\n\nBuild matrix from make-identity-vec 3 and compute determinant.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-determinant-int (matrix-from-vec 3 3 (make-identity-vec 3))) 1)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-determinant-int (matrix-from-vec 3 3 (make-identity-vec 3)))", "verify_expr": "(equal? (matrix-determinant-int (matrix-from-vec 3 3 (make-identity-vec 3))) 1)", "tags": ["linalg", "integer-matrix", "composition", "make-identity-vec", "integration"], "split": "train"}
{"id": "integer_matrix_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: small integration task across module primitives.\n\nCompute determinant of minor(0,0) for 3x3 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-determinant-int (matrix-minor (matrix-from-lists '((2 3 1) (4 5 6) (7 8 9))) 0 0))", "verify_expr": "(equal? (matrix-determinant-int (matrix-minor (matrix-from-lists '((2 3 1) (4 5 6) (7 8 9))) 0 0)) -3)", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "integration"], "split": "train"}
{"id": "integer_matrix_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff determinant is invariant under transpose.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (matrix-from-lists '((2 5 7) (1 3 4) (6 8 9)) )]) (= (matrix-determinant-int m) (matrix-determinant-int (matrix-transpose m))))", "verify_expr": "(equal? (let ([m (matrix-from-lists '((2 5 7) (1 3 4) (6 8 9)) )]) (= (matrix-determinant-int m) (matrix-determinant-int (matrix-transpose m)))) #t)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "integration"], "split": "train"}
{"id": "integer_matrix_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: small integration task across module primitives.\n\nUse named-let to fill the diagonal of 3x3 flat data with 1s, then return data.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([d (make-vector 9 0)]) (let loop ([i 0]) (if (= i 3) d (begin (int-mat-set! d 3 i i 1) (loop (+ i 1))))) ) (vector 1 0 0 0 1 0 0 0 1))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (make-vector 9 0)]) (let loop ([i 0]) (if (= i 3) d (begin (int-mat-set! d 3 i i 1) (loop (+ i 1))))) )", "verify_expr": "(equal? (let ([d (make-vector 9 0)]) (let loop ([i 0]) (if (= i 3) d (begin (int-mat-set! d 3 i i 1) (loop (+ i 1))))) ) (vector 1 0 0 0 1 0 0 0 1))", "tags": ["linalg", "integer-matrix", "composition", "int-mat-set!", "loop"], "split": "train"}
{"id": "integer_matrix_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nCompute determinant after swapping two rows in flat data and rebuilding matrix.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 1 2 3 4)]) (swap-rows! d 2 2 0 1) (matrix-determinant-int (matrix-from-vec 2 2 d)))", "verify_expr": "(equal? (let ([d (vector 1 2 3 4)]) (swap-rows! d 2 2 0 1) (matrix-determinant-int (matrix-from-vec 2 2 d))) 2)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "integration"], "split": "train"}
{"id": "integer_matrix_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: small integration task across module primitives.\n\nTake minor of 2x2 matrix and compute determinant of the resulting 1x1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-determinant-int (matrix-minor (matrix-from-lists '((11 12) (13 14))) 0 1)) 13)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-determinant-int (matrix-minor (matrix-from-lists '((11 12) (13 14))) 0 1))", "verify_expr": "(equal? (matrix-determinant-int (matrix-minor (matrix-from-lists '((11 12) (13 14))) 0 1)) 13)", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "integration"], "split": "eval"}
