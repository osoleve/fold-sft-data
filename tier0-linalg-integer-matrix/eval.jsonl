{"id": "integer_matrix_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-copy", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `int-mat-copy`\nSpec: Return a fresh copy of vector v with identical contents.\n\nWrite exactly one Scheme function definition for `int-mat-copy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (let* ([v (vector 1 2 3)] [c (int-mat-copy v)]) (vector-set! v 0 9) (and (equal? c (vector 1 2 3)) (not (eq? v c)))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "int-mat-copy"], "split": "eval"}
{"id": "integer_matrix_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-rows!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `swap-rows!`\nSpec: In-place swap of rows i1 and i2 in flat matrix data.\n\nWrite exactly one Scheme function definition for `swap-rows!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-rows! d 2 3 0 1) (equal? d (vector 4 5 6 1 2 3))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "swap-rows!"], "split": "eval"}
{"id": "integer_matrix_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "make-identity-vec", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/integer-matrix.ss\nFunction: `make-identity-vec`\nSpec: Create n x n identity matrix as flat row-major vector.\n\nWrite exactly one Scheme function definition for `make-identity-vec`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (make-identity-vec 1) (vector 1)))\n(let () (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (make-identity-vec n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) data)\n      (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (make-identity-vec 1) (vector 1)) (equal? (make-identity-vec 3) (vector 1 0 0 0 1 0 0 0 1))))", "tags": ["linalg", "integer-matrix", "spec-to-code", "make-identity-vec"], "split": "eval"}
{"id": "integer_matrix_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `int-mat-ref`.\nReturn only the Scheme definition.\n\n```python\ndef int_mat_ref(data, cols, i, j):\n    return data[i * cols + j]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3))\n(let () (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "int-mat-ref"], "split": "eval"}
{"id": "integer_matrix_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `swap-cols!`.\nReturn only the Scheme definition.\n\n```python\ndef swap_cols(data, rows, cols, j1, j2):\n    if j1 != j2:\n        for i in range(rows):\n            idx1 = i * cols + j1\n            idx2 = i * cols + j2\n            data[idx1], data[idx2] = data[idx2], data[idx1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "python-to-scheme", "swap-cols!"], "split": "eval"}
{"id": "integer_matrix_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `matrix-determinant-int`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (det-int0 mat)\n  (let* ((n (matrix-rows mat)))\n    (if (= n 0)\n        1\n        (let ((data (int-mat-copy (matrix-data mat)))\n              (sign 1))\n          (let loop ((k 0) (prev 1))\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ((pidx (let search ((i k))\n                             (cond ((>= i n) #f)\n                                   ((not (= 0 (int-mat-ref data n i k))) i)\n                                   (else (search (+ i 1)))))))\n                  (if (not pidx)\n                      0\n                      (begin\n                        (when (not (= pidx k))\n                          (swap-rows! data n n k pidx)\n                          (set! sign (- sign)))\n                        (let ((pivot (int-mat-ref data n k k)))\n                          (do ((i (+ k 1) (+ i 1)))\n                              ((= i n))\n                            (do ((j (+ k 1) (+ j 1)))\n                                ((= j n))\n                              (let ((new-val (quotient (- (* pivot (int-mat-ref data n i j))\n                                                          (* (int-mat-ref data n i k)\n                                                             (int-mat-ref data n k j)))\n                                                      prev)))\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (matrix-determinant-int (matrix-from-lists '())) 1))\n(let () (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "chez-to-fold", "matrix-determinant-int"], "split": "eval"}
{"id": "integer_matrix_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `int-mat-ref` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Row/column indexing is transposed; use i*cols + j.\n\n```scheme\n(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* j cols) i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Row/column indexing is transposed; use i*cols + j.\n\nExpected behavior after patch:\n```scheme\n(let () (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3))\n(let () (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (and (= (int-mat-ref (vector 1 2 3 4 5 6) 3 0 2) 3) (= (int-mat-ref (vector 1 2 3 4 5 6) 3 1 1) 5)))", "tags": ["linalg", "integer-matrix", "bugfix", "int-mat-ref"], "split": "eval"}
{"id": "integer_matrix_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `swap-cols!` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Must swap every row, not just row 0.\n\n```scheme\n(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (let ([tmp (int-mat-ref data cols 0 j1)])\n      (int-mat-set! data cols 0 j1 (int-mat-ref data cols 0 j2))\n      (int-mat-set! data cols 0 j2 tmp))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must swap every row, not just row 0.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))", "verify_expr": "(let ()\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-cols! data rows cols j1 j2)\n  (when (not (= j1 j2))\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (let ([tmp (int-mat-ref data cols i j1)])\n        (int-mat-set! data cols i j1 (int-mat-ref data cols i j2))\n        (int-mat-set! data cols i j2 tmp)))))\n  (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) (equal? d (vector 3 2 1 6 5 4))))", "tags": ["linalg", "integer-matrix", "bugfix", "swap-cols!"], "split": "eval"}
{"id": "integer_matrix_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-determinant-int` in `lattice/linalg/integer-matrix.ss`.\nKnown issue: Empty matrix determinant should be 1, and row swaps must flip sign.\n\n```scheme\n(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        0\n        (let ([data (int-mat-copy (matrix-data mat))] [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (int-mat-ref data n (- n 1) (- n 1))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond [(>= i n) #f] [(not (= 0 (int-mat-ref data n i k))) i] [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k)) (swap-rows! data n n k pivot-idx))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (int-mat-set! data n i j (quotient (- (* pivot (int-mat-ref data n i j)) (* (int-mat-ref data n i k) (int-mat-ref data n k j))) prev-pivot))))\n                          (loop (+ k 1) pivot))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty matrix determinant should be 1, and row swaps must flip sign.\n\nExpected behavior after patch:\n```scheme\n(let () (= (matrix-determinant-int (matrix-from-lists '())) 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (matrix-determinant-int (matrix-from-lists '())) 1))\n(let () (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))", "verify_expr": "(let ()\n  (define (int-mat-copy v)\n  (let* ([n (vector-length v)]\n         [result (make-vector n 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) result)\n      (vector-set! result i (vector-ref v i)))))\n  (define (int-mat-ref data cols i j)\n  (vector-ref data (+ (* i cols) j)))\n  (define (int-mat-set! data cols i j val)\n  (vector-set! data (+ (* i cols) j) val))\n  (define (swap-rows! data rows cols i1 i2)\n  (when (not (= i1 i2))\n    (do ([j 0 (+ j 1)])\n        ((= j cols))\n      (let ([tmp (int-mat-ref data cols i1 j)])\n        (int-mat-set! data cols i1 j (int-mat-ref data cols i2 j))\n        (int-mat-set! data cols i2 j tmp)))))\n  (define (matrix-determinant-int mat)\n  (let* ([n (matrix-rows mat)])\n    (if (= n 0)\n        1\n        (let ([data (int-mat-copy (matrix-data mat))]\n              [sign 1])\n          (let loop ([k 0] [prev-pivot 1])\n            (if (>= k (- n 1))\n                (* sign (int-mat-ref data n (- n 1) (- n 1)))\n                (let ([pivot-idx (let search ([i k])\n                                  (cond\n                                    [(>= i n) #f]\n                                    [(not (= 0 (int-mat-ref data n i k))) i]\n                                    [else (search (+ i 1))]))])\n                  (if (not pivot-idx)\n                      0\n                      (begin\n                        (when (not (= pivot-idx k))\n                          (swap-rows! data n n k pivot-idx)\n                          (set! sign (- sign)))\n                        (let ([pivot (int-mat-ref data n k k)])\n                          (do ([i (+ k 1) (+ i 1)])\n                              ((= i n))\n                            (do ([j (+ k 1) (+ j 1)])\n                                ((= j n))\n                              (let ([new-val (quotient\n                                              (- (* pivot (int-mat-ref data n i j))\n                                                 (* (int-mat-ref data n i k)\n                                                    (int-mat-ref data n k j)))\n                                              prev-pivot)])\n                                (int-mat-set! data n i j new-val))))\n                          (loop (+ k 1) pivot)))))))))))\n  (and (= (matrix-determinant-int (matrix-from-lists '())) 1) (= (matrix-determinant-int (matrix-from-lists '((3 4) (1 2)))) 2) (= (matrix-determinant-int (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))) -3) (= (matrix-determinant-int (matrix-identity 4)) 1) (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) (= (matrix-determinant-int (matrix-from-lists '((0 1) (1 0)))) -1)))", "tags": ["linalg", "integer-matrix", "bugfix", "matrix-determinant-int"], "split": "eval"}
{"id": "integer_matrix_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-ref", "prompt": "Task mode: small integration task across module primitives.\n\nRead entry (1,2) from flat 2x3 data vector.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(int-mat-ref (vector 1 2 3 4 5 6) 3 1 2)", "verify_expr": "(equal? (int-mat-ref (vector 1 2 3 4 5 6) 3 1 2) 6)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-ref", "direct"], "split": "eval"}
{"id": "integer_matrix_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "swap-cols!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSwap columns 0 and 2 in 2x3 data and return vector.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) d)", "verify_expr": "(equal? (let ([d (vector 1 2 3 4 5 6)]) (swap-cols! d 2 3 0 2) d) (vector 3 2 1 6 5 4))", "tags": ["linalg", "integer-matrix", "composition", "swap-cols!", "direct"], "split": "eval"}
{"id": "integer_matrix_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "int-mat-set!", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff setting then reading same index recovers written value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (vector 0 1 2 3 4 5)]) (int-mat-set! d 3 1 1 88) (= (int-mat-ref d 3 1 1) 88))", "verify_expr": "(equal? (let ([d (vector 0 1 2 3 4 5)]) (int-mat-set! d 3 1 1 88) (= (int-mat-ref d 3 1 1) 88)) #t)", "tags": ["linalg", "integer-matrix", "composition", "int-mat-set!", "property"], "split": "eval"}
{"id": "integer_matrix_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-determinant-int", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff determinant of singular matrix is 0.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0)", "verify_expr": "(equal? (= (matrix-determinant-int (matrix-from-lists '((1 2) (2 4)))) 0) #t)", "tags": ["linalg", "integer-matrix", "composition", "matrix-determinant-int", "property"], "split": "eval"}
{"id": "integer_matrix_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/integer-matrix.ss", "source_test": "lattice/linalg/test-integer-matrix.ss", "source_function": "matrix-minor", "prompt": "Task mode: small integration task across module primitives.\n\nTake minor of 2x2 matrix and compute determinant of the resulting 1x1.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-determinant-int (matrix-minor (matrix-from-lists '((11 12) (13 14))) 0 1))", "verify_expr": "(equal? (matrix-determinant-int (matrix-minor (matrix-from-lists '((11 12) (13 14))) 0 1)) 13)", "tags": ["linalg", "integer-matrix", "composition", "matrix-minor", "integration"], "split": "eval"}
