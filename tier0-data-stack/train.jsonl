{"id": "stack_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack-empty?`\nSpec: Return #t iff the stack has no elements.\n\nWrite exactly one Scheme function definition for `stack-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(stack-empty? '())\n(not (stack-empty? '(x)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack-empty?"], "split": "train"}
{"id": "stack_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack-empty? stack)\n  ;; TODO: return whether stack is empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack-empty?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack-empty?"], "split": "train"}
{"id": "stack_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack-push elem stack)\n  ;; TODO: push elem onto stack top\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack-push`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (stack-push 'a '()) '(a))\n(equal? (stack-push 'a '(b c)) '(a b c))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack-push"], "split": "train"}
{"id": "stack_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack-pop`\nSpec: Pop top element; return two values: (new-stack, popped-elem). Raise an error on empty stack.\n\nWrite exactly one Scheme function definition for `stack-pop`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack-pop"], "split": "train"}
{"id": "stack_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack-pop stack)\n  ;; TODO: return (values new-stack popped-elem), error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack-pop`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack-pop"], "split": "train"}
{"id": "stack_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack-peek`\nSpec: Return top element without removing it. Raise an error on empty stack.\n\nWrite exactly one Scheme function definition for `stack-peek`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack-peek"], "split": "train"}
{"id": "stack_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack-peek stack)\n  ;; TODO: return top element, error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack-peek`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack-peek"], "split": "train"}
{"id": "stack_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack-size stack)\n  ;; TODO: return number of elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack-size`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (stack-size '()) 0)\n(= (stack-size '(a b c d)) 4)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack-size"], "split": "train"}
{"id": "stack_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (stack->list stack)\n  ;; TODO: convert stack to list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `stack->list`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (stack->list '(c b a)) '(c b a))\n(equal? (stack->list '()) '())\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "skeleton-completion", "stack->list"], "split": "train"}
{"id": "stack_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `list->stack`\nSpec: Convert list to stack where the first list element becomes the stack top.\n\nWrite exactly one Scheme function definition for `list->stack`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "spec-to-code", "list->stack"], "split": "train"}
{"id": "stack_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (list->stack lst)\n  ;; TODO: convert list to stack\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->stack`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "skeleton-completion", "list->stack"], "split": "train"}
{"id": "stack_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? s)\n  (null? s))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack-empty?"], "split": "train"}
{"id": "stack_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack-push`.\nReturn only the Scheme definition.\n\n```python\ndef stack_push(elem, stack):\n    return [elem] + stack\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (stack-push 'a '()) '(a))\n(equal? (stack-push 'a '(b c)) '(a b c))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack-push"], "split": "train"}
{"id": "stack_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack-push`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (push x s)\n  (cons x s))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (stack-push 'a '()) '(a))\n(equal? (stack-push 'a '(b c)) '(a b c))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack-push"], "split": "train"}
{"id": "stack_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack-pop`.\nReturn only the Scheme definition.\n\n```python\ndef stack_pop(stack):\n    if len(stack) == 0:\n        raise ValueError('empty stack')\n    return stack[1:], stack[0]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a))))\n(guard (ex [else #t]) (begin (stack-pop '()) #f))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack-pop"], "split": "train"}
{"id": "stack_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack-pop`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (pop s)\n  (if (null? s)\n      (error 'pop \"empty\")\n      (values (cdr s) (car s))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a))))\n(guard (ex [else #t]) (begin (stack-pop '()) #f))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack-pop"], "split": "train"}
{"id": "stack_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack-peek`.\nReturn only the Scheme definition.\n\n```python\ndef stack_peek(stack):\n    if len(stack) == 0:\n        raise ValueError('empty stack')\n    return stack[0]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack-peek"], "split": "train"}
{"id": "stack_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack-peek`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (peek s)\n  (if (null? s)\n      (error 'peek \"empty\")\n      (car s)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack-peek"], "split": "train"}
{"id": "stack_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack-size`.\nReturn only the Scheme definition.\n\n```python\ndef stack_size(stack):\n    return len(stack)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (stack-size '()) 0)\n(= (stack-size '(a b c d)) 4)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack-size"], "split": "train"}
{"id": "stack_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size s)\n  (length s))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack-size"], "split": "train"}
{"id": "stack_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack->list`.\nReturn only the Scheme definition.\n\n```python\ndef stack_to_list(stack):\n    return stack\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (stack->list '(c b a)) '(c b a))\n(equal? (stack->list '()) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack->list"], "split": "train"}
{"id": "stack_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `stack->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list s)\n  s)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (stack->list '(c b a)) '(c b a))\n(equal? (stack->list '()) '())\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "chez-to-fold", "stack->list"], "split": "train"}
{"id": "stack_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `list->stack`.\nReturn only the Scheme definition.\n\n```python\ndef list_to_stack(lst):\n    return lst\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (list->stack '(1 2 3)) '(1 2 3))\n(equal? (list->stack '()) '())\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "python-to-scheme", "list->stack"], "split": "train"}
{"id": "stack_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-empty?` in `lattice/data/stack.ss`.\nKnown issue: Empty stacks must return #t.\n\n```scheme\n(define (stack-empty? stack)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(stack-empty? '())\n(not (stack-empty? '(x)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-empty?"], "split": "train"}
{"id": "stack_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-push` in `lattice/data/stack.ss`.\nKnown issue: Push must add at the top, not the bottom.\n\n```scheme\n(define (stack-push elem stack)\n  (append stack (list elem)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (stack-push 'a '()) '(a))\n(equal? (stack-push 'a '(b c)) '(a b c))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-push"], "split": "train"}
{"id": "stack_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-push` in `lattice/data/stack.ss`.\nKnown issue: The pushed element is discarded.\n\n```scheme\n(define (stack-push elem stack)\n  stack)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (stack-push 'a '()) '(a))\n(equal? (stack-push 'a '(b c)) '(a b c))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-push"], "split": "train"}
{"id": "stack_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-pop` in `lattice/data/stack.ss`.\nKnown issue: Empty stack must raise an error, not return sentinel values.\n\n```scheme\n(define (stack-pop stack)\n  (if (null? stack)\n      (values '() #f)\n      (values (cdr stack) (car stack))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a))))\n(guard (ex [else #t]) (begin (stack-pop '()) #f))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-pop"], "split": "train"}
{"id": "stack_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-pop` in `lattice/data/stack.ss`.\nKnown issue: Second returned value must be the popped element.\n\n```scheme\n(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (cdr stack))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a))))\n(guard (ex [else #t]) (begin (stack-pop '()) #f))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))", "verify_expr": "(let ()\n  (define (stack-pop stack)\n  (if (null? stack)\n      (error 'stack-pop \"Cannot pop from empty stack\")\n      (values (cdr stack) (car stack))))\n  (and (call-with-values (lambda () (stack-pop '(a b c))) (lambda (s x) (and (equal? s '(b c)) (equal? x 'a)))) (guard (ex [else #t]) (begin (stack-pop '()) #f))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-pop"], "split": "train"}
{"id": "stack_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-peek` in `lattice/data/stack.ss`.\nKnown issue: Peeking an empty stack must raise an error.\n\n```scheme\n(define (stack-peek stack)\n  (if (null? stack)\n      #f\n      (car stack)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-peek"], "split": "train"}
{"id": "stack_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-peek` in `lattice/data/stack.ss`.\nKnown issue: Peek should return the top (head), not the bottom.\n\n```scheme\n(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (last stack)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (stack-peek '(z y)) 'z)\n(guard (ex [else #t]) (begin (stack-peek '()) #f))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))", "verify_expr": "(let ()\n  (define (stack-peek stack)\n  (if (null? stack)\n      (error 'stack-peek \"Cannot peek empty stack\")\n      (car stack)))\n  (and (equal? (stack-peek '(z y)) 'z) (guard (ex [else #t]) (begin (stack-peek '()) #f))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-peek"], "split": "train"}
{"id": "stack_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-size` in `lattice/data/stack.ss`.\nKnown issue: Empty stack size must be 0.\n\n```scheme\n(define (stack-size stack)\n  (if (null? stack) 1 (length stack)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "bugfix", "stack-size"], "split": "train"}
{"id": "stack_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-size` in `lattice/data/stack.ss`.\nKnown issue: Size should equal list length exactly.\n\n```scheme\n(define (stack-size stack)\n  (- (length stack) 1))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(= (stack-size '()) 0)\n(= (stack-size '(a b c d)) 4)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "bugfix", "stack-size"], "split": "train"}
{"id": "stack_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack->list` in `lattice/data/stack.ss`.\nKnown issue: Order must remain top-to-bottom.\n\n```scheme\n(define (stack->list stack)\n  (reverse stack))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (stack->list '(c b a)) '(c b a))\n(equal? (stack->list '()) '())\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "bugfix", "stack->list"], "split": "train"}
{"id": "stack_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack->list` in `lattice/data/stack.ss`.\nKnown issue: Conversion should preserve contents.\n\n```scheme\n(define (stack->list stack)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "bugfix", "stack->list"], "split": "train"}
{"id": "stack_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->stack` in `lattice/data/stack.ss`.\nKnown issue: First list element must become the stack top.\n\n```scheme\n(define (list->stack lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (list->stack '(1 2 3)) '(1 2 3))\n(equal? (list->stack '()) '())\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "bugfix", "list->stack"], "split": "train"}
{"id": "stack_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: small integration task across module primitives.\n\nPush `42` onto `stack-empty`.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (stack-push 42 stack-empty) '(42))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(stack-push 42 stack-empty)", "verify_expr": "(equal? (stack-push 42 stack-empty) '(42))", "tags": ["tier0", "data", "stack", "composition", "stack-push", "direct"], "split": "train"}
{"id": "stack_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPush `'a`, then `'b`, then `'c` onto `stack-empty` and return the final stack.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (stack-push 'c (stack-push 'b (stack-push 'a stack-empty))) '(c b a))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(stack-push 'c (stack-push 'b (stack-push 'a stack-empty)))", "verify_expr": "(equal? (stack-push 'c (stack-push 'b (stack-push 'a stack-empty))) '(c b a))", "tags": ["tier0", "data", "stack", "composition", "stack-push", "direct"], "split": "train"}
{"id": "stack_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn the top element of stack `'(top mid low)`.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (stack-peek '(top mid low)) 'top)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(stack-peek '(top mid low))", "verify_expr": "(equal? (stack-peek '(top mid low)) 'top)", "tags": ["tier0", "data", "stack", "composition", "stack-peek", "direct"], "split": "train"}
{"id": "stack_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn stack size for `'(x y z w)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(stack-size '(x y z w))", "verify_expr": "(equal? (stack-size '(x y z w)) 4)", "tags": ["tier0", "data", "stack", "composition", "stack-size", "direct"], "split": "train"}
{"id": "stack_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: small integration task across module primitives.\n\nConvert stack `'(s3 s2 s1)` to list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (stack->list '(s3 s2 s1)) '(s3 s2 s1))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(stack->list '(s3 s2 s1))", "verify_expr": "(equal? (stack->list '(s3 s2 s1)) '(s3 s2 s1))", "tags": ["tier0", "data", "stack", "composition", "stack->list", "direct"], "split": "train"}
{"id": "stack_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: small integration task across module primitives.\n\nConvert list `'(1 2 3 4)` to stack.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (list->stack '(1 2 3 4)) '(1 2 3 4))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(list->stack '(1 2 3 4))", "verify_expr": "(equal? (list->stack '(1 2 3 4)) '(1 2 3 4))", "tags": ["tier0", "data", "stack", "composition", "list->stack", "direct"], "split": "train"}
{"id": "stack_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: compose existing APIs into one expression.\n\nRound-trip list->stack->list for `'(m n o)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (stack->list (list->stack '(m n o))) '(m n o))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(stack->list (list->stack '(m n o)))", "verify_expr": "(equal? (stack->list (list->stack '(m n o))) '(m n o))", "tags": ["tier0", "data", "stack", "composition", "stack->list", "direct"], "split": "train"}
{"id": "stack_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether stack `'(a)` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (stack-empty? '(a)) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(stack-empty? '(a))", "verify_expr": "(equal? (stack-empty? '(a)) #f)", "tags": ["tier0", "data", "stack", "composition", "stack-empty?", "direct"], "split": "train"}
{"id": "stack_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff pushing then popping restores the original stack for `'(b a)` with element `'x`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (stack-pop (stack-push 'x '(b a)))) (lambda (rest popped) (and (equal? rest '(b a)) (equal? popped 'x))))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop (stack-push 'x '(b a)))) (lambda (rest popped) (and (equal? rest '(b a)) (equal? popped 'x)))) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "property"], "split": "train"}
{"id": "stack_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff two pushes then two pops return elements in LIFO order.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (stack-pop (stack-push 'y (stack-push 'x stack-empty)))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (and (equal? p1 'y) (equal? p2 'x) (stack-empty? s2)))))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (stack-pop (stack-push 'y (stack-push 'x stack-empty)))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (and (equal? p1 'y) (equal? p2 'x) (stack-empty? s2))))))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop (stack-push 'y (stack-push 'x stack-empty)))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (and (equal? p1 'y) (equal? p2 'x) (stack-empty? s2)))))) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "property"], "split": "train"}
{"id": "stack_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that stack size increases by one after `stack-push`.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (stack-size (stack-push 'n '(c b a))) (+ 1 (stack-size '(c b a)))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (stack-size (stack-push 'n '(c b a))) (+ 1 (stack-size '(c b a))))", "verify_expr": "(equal? (= (stack-size (stack-push 'n '(c b a))) (+ 1 (stack-size '(c b a)))) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-size", "property"], "split": "train"}
{"id": "stack_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that popping a non-empty stack decreases size by one.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(call-with-values (lambda () (stack-pop '(q p o n))) (lambda (rest popped) (= (stack-size rest) 3)))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(q p o n))) (lambda (rest popped) (= (stack-size rest) 3))) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-size", "property"], "split": "train"}
{"id": "stack_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff `list->stack` keeps `'a` at the top for `'(a b c)`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (car (list->stack '(a b c))) 'a)", "verify_expr": "(equal? (equal? (car (list->stack '(a b c))) 'a) #t)", "tags": ["tier0", "data", "stack", "composition", "list->stack", "property"], "split": "train"}
{"id": "stack_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff popping the only element yields empty stack and that element.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (stack-pop '(solo))) (lambda (rest popped) (and (stack-empty? rest) (equal? popped 'solo)))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (stack-pop '(solo))) (lambda (rest popped) (and (stack-empty? rest) (equal? popped 'solo))))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(solo))) (lambda (rest popped) (and (stack-empty? rest) (equal? popped 'solo)))) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "property"], "split": "train"}
{"id": "stack_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff popping empty stack raises an exception.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (guard (ex [else #t]) (begin (stack-pop stack-empty) #f)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(guard (ex [else #t]) (begin (stack-pop stack-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (stack-pop stack-empty) #f)) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "edge-case"], "split": "train"}
{"id": "stack_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff peeking empty stack raises an exception.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (stack-peek stack-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (stack-peek stack-empty) #f)) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-peek", "edge-case"], "split": "train"}
{"id": "stack_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a stack from `'(1 2 3 4)` using `fold-left` and `stack-push`.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (fold-left (lambda (s x) (stack-push x s)) stack-empty '(1 2 3 4)) '(4 3 2 1))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-left (lambda (s x) (stack-push x s)) stack-empty '(1 2 3 4))", "verify_expr": "(equal? (fold-left (lambda (s x) (stack-push x s)) stack-empty '(1 2 3 4)) '(4 3 2 1))", "tags": ["tier0", "data", "stack", "composition", "stack-push", "fold"], "split": "train"}
{"id": "stack_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPush all symbols in `'(a b c d)` with a named-let loop and return the stack.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let loop ([xs '(a b c d)] [s stack-empty]) (if (null? xs) s (loop (cdr xs) (stack-push (car xs) s)))) '(d c b a))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([xs '(a b c d)] [s stack-empty]) (if (null? xs) s (loop (cdr xs) (stack-push (car xs) s))))", "verify_expr": "(equal? (let loop ([xs '(a b c d)] [s stack-empty]) (if (null? xs) s (loop (cdr xs) (stack-push (car xs) s)))) '(d c b a))", "tags": ["tier0", "data", "stack", "composition", "stack-push", "loop"], "split": "train"}
{"id": "stack_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: compose existing APIs into one expression.\n\nPop every element from `'(4 3 2 1)` and accumulate their sum.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([s '(4 3 2 1)] [acc 0]) (if (stack-empty? s) acc (call-with-values (lambda () (stack-pop s)) (lambda (rest popped) (loop rest (+ acc popped))))))", "verify_expr": "(equal? (let loop ([s '(4 3 2 1)] [acc 0]) (if (stack-empty? s) acc (call-with-values (lambda () (stack-pop s)) (lambda (rest popped) (loop rest (+ acc popped)))))) 10)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "loop"], "split": "train"}
{"id": "stack_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn a list of stack sizes for stacks `'((a) (b c) (d e f))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map stack-size '((a) (b c) (d e f))) '(1 2 3))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map stack-size '((a) (b c) (d e f)))", "verify_expr": "(equal? (map stack-size '((a) (b c) (d e f))) '(1 2 3))", "tags": ["tier0", "data", "stack", "composition", "stack-size", "list"], "split": "train"}
{"id": "stack_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: small integration task across module primitives.\n\nGiven stacks `'((x y) () (z))`, map `stack->list` over them.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (map stack->list '((x y) () (z))) '((x y) () (z)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map stack->list '((x y) () (z)))", "verify_expr": "(equal? (map stack->list '((x y) () (z))) '((x y) () (z)))", "tags": ["tier0", "data", "stack", "composition", "stack->list", "list"], "split": "train"}
{"id": "stack_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPop twice from `'(c b a)` and return `(list first second final-stack)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (stack-pop '(c b a))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (list p1 p2 s2))))) '(c b (a)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (stack-pop '(c b a))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (list p1 p2 s2)))))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(c b a))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (list p1 p2 s2))))) '(c b (a)))", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "integration"], "split": "train"}
{"id": "stack_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: small integration task across module primitives.\n\nDuplicate the top of stack `'(k j i)` by peeking then pushing.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([s '(k j i)]) (stack-push (stack-peek s) s))", "verify_expr": "(equal? (let ([s '(k j i)]) (stack-push (stack-peek s) s)) '(k k j i))", "tags": ["tier0", "data", "stack", "composition", "stack-peek", "integration"], "split": "train"}
{"id": "stack_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: small integration task across module primitives.\n\nFrom stack `'(q p o)`, pop once, push `'z`, and return resulting stack.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (stack-pop '(q p o))) (lambda (rest popped) (stack-push 'z rest))) '(z p o))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (stack-pop '(q p o))) (lambda (rest popped) (stack-push 'z rest)))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(q p o))) (lambda (rest popped) (stack-push 'z rest))) '(z p o))", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "integration"], "split": "train"}
{"id": "stack_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck whether converting `'( )` with `list->stack` yields an empty stack.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (stack-empty? (list->stack '())) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(stack-empty? (list->stack '()))", "verify_expr": "(equal? (stack-empty? (list->stack '())) #t)", "tags": ["tier0", "data", "stack", "composition", "list->stack", "integration"], "split": "train"}
