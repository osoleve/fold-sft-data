{"id": "stack_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-push", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack-push`\nSpec: Push elem onto the top of stack and return the new stack.\n\nWrite exactly one Scheme function definition for `stack-push`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (stack-push 'a '()) '(a)))\n(let () (equal? (stack-push 'a '(b c)) '(a b c)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (stack-push elem stack)\n  (cons elem stack))", "verify_expr": "(let ()\n  (define (stack-push elem stack)\n  (cons elem stack))\n  (and (equal? (stack-push 'a '()) '(a)) (equal? (stack-push 'a '(b c)) '(a b c))))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack-push"], "split": "eval"}
{"id": "stack_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack-size`\nSpec: Return the number of elements in stack.\n\nWrite exactly one Scheme function definition for `stack-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (stack-size '()) 0))\n(let () (= (stack-size '(a b c d)) 4))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (stack-size stack)\n  (length stack))", "verify_expr": "(let ()\n  (define (stack-size stack)\n  (length stack))\n  (and (= (stack-size '()) 0) (= (stack-size '(a b c d)) 4)))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack-size"], "split": "eval"}
{"id": "stack_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack->list", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 data-structure code in Fold-native Scheme.\n\nTarget module: lattice/data/stack.ss\nFunction: `stack->list`\nSpec: Convert stack to list in top-to-bottom order.\n\nWrite exactly one Scheme function definition for `stack->list`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (stack->list '(c b a)) '(c b a)))\n(let () (equal? (stack->list '()) '()))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (stack->list stack)\n  stack)", "verify_expr": "(let ()\n  (define (stack->list stack)\n  stack)\n  (and (equal? (stack->list '(c b a)) '(c b a)) (equal? (stack->list '()) '())))", "tags": ["tier0", "data", "stack", "spec-to-code", "stack->list"], "split": "eval"}
{"id": "stack_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `stack-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef stack_empty(stack):\n    return len(stack) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "python-to-scheme", "stack-empty?"], "split": "eval"}
{"id": "stack_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `list->stack`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-list xs)\n  xs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (list->stack '(1 2 3)) '(1 2 3)))\n(let () (equal? (list->stack '()) '()))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "chez-to-fold", "list->stack"], "split": "eval"}
{"id": "stack_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `stack-empty?` in `lattice/data/stack.ss`.\nKnown issue: This crashes on empty stacks and also misclassifies single-element stacks as empty.\n\n```scheme\n(define (stack-empty? stack)\n  (null? (cdr stack)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (stack-empty? stack)\n  (null? stack))", "verify_expr": "(let ()\n  (define (stack-empty? stack)\n  (null? stack))\n  (and (stack-empty? '()) (not (stack-empty? '(x)))))", "tags": ["tier0", "data", "stack", "bugfix", "stack-empty?"], "split": "eval"}
{"id": "stack_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->stack", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->stack` in `lattice/data/stack.ss`.\nKnown issue: Conversion should preserve elements.\n\n```scheme\n(define (list->stack lst)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Conversion should preserve elements.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (list->stack '(1 2 3)) '(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (list->stack '(1 2 3)) '(1 2 3)))\n(let () (equal? (list->stack '()) '()))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (list->stack lst)\n  lst)", "verify_expr": "(let ()\n  (define (list->stack lst)\n  lst)\n  (and (equal? (list->stack '(1 2 3)) '(1 2 3)) (equal? (list->stack '()) '())))", "tags": ["tier0", "data", "stack", "bugfix", "list->stack"], "split": "eval"}
{"id": "stack_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `stack-empty` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(stack-empty? stack-empty)", "verify_expr": "(equal? (stack-empty? stack-empty) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-empty?", "direct"], "split": "eval"}
{"id": "stack_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: small integration task across module primitives.\n\nPop once from stack `'(k j i)` and return `(list popped rest)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (stack-pop '(k j i))) (lambda (rest popped) (list popped rest)))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(k j i))) (lambda (rest popped) (list popped rest))) '(k (j i)))", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "direct"], "split": "eval"}
{"id": "stack_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-peek", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff `stack-peek` after push returns the pushed value `'new`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (stack-peek (stack-push 'new '(old))) 'new)", "verify_expr": "(equal? (equal? (stack-peek (stack-push 'new '(old))) 'new) #t)", "tags": ["tier0", "data", "stack", "composition", "stack-peek", "property"], "split": "eval"}
{"id": "stack_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount how many pops are required to empty stack `'(d c b a)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([s '(d c b a)] [n 0]) (if (stack-empty? s) n (call-with-values (lambda () (stack-pop s)) (lambda (rest popped) (loop rest (+ n 1))))))", "verify_expr": "(equal? (let loop ([s '(d c b a)] [n 0]) (if (stack-empty? s) n (call-with-values (lambda () (stack-pop s)) (lambda (rest popped) (loop rest (+ n 1)))))) 4)", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "loop"], "split": "eval"}
{"id": "stack_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/stack.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "stack-pop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPop three times from `'(3 2 1)` and return popped values as a list.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (stack-pop '(3 2 1))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (call-with-values (lambda () (stack-pop s2)) (lambda (s3 p3) (list p1 p2 p3)))))))", "verify_expr": "(equal? (call-with-values (lambda () (stack-pop '(3 2 1))) (lambda (s1 p1) (call-with-values (lambda () (stack-pop s1)) (lambda (s2 p2) (call-with-values (lambda () (stack-pop s2)) (lambda (s3 p3) (list p1 p2 p3))))))) '(3 2 1))", "tags": ["tier0", "data", "stack", "composition", "stack-pop", "integration"], "split": "eval"}
