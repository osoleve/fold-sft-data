{"id": "random_probability_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `make-prob`\nSpec: Wrap a state computation as a probability monad value tagged with 'prob.\n\nWrite exactly one Scheme function definition for `make-prob`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n(let () (eq? (car (make-prob (state-pure 1))) 'prob))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "spec-to-code", "make-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `make-prob`\nBehavior contract: Wrap a state computation as a probability monad value tagged with 'prob.\n\n```scheme\n(define (make-prob state-comp)\n  ;; TODO: construct probability wrapper tagged with 'prob\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n(let () (eq? (car (make-prob (state-pure 1))) 'prob))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "skeleton", "make-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `prob?`\nBehavior contract: Return #t exactly when a value is a tagged probability computation with leading symbol 'prob.\n\n```scheme\n(define (prob? x)\n  ;; TODO: recognize probability wrappers tagged with 'prob\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (prob? (make-prob (state-pure 3))))\n(let () (prob? '(prob . fake)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "skeleton", "prob?"], "split": "train"}
{"id": "random_probability_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `run-prob`\nSpec: Execute a probability computation from an initial PRNG and zero log-weight, returning ((value . log-weight) . new-prng).\n\nWrite exactly one Scheme function definition for `run-prob`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "spec-to-code", "run-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `run-prob`\nBehavior contract: Execute a probability computation from an initial PRNG and zero log-weight, returning ((value . log-weight) . new-prng).\n\n```scheme\n(define (run-prob p prng)\n  ;; TODO: run state with (prng . 0.0) and return ((value . log-weight) . new-prng)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "skeleton", "run-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `sample-prob`\nBehavior contract: Project the sampled value from run-prob output.\n\n```scheme\n(define (sample-prob p prng)\n  ;; TODO: extract sample value from run-prob result\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p1 (prob-pure 7)] [p2 (make-prob (make-state (lambda (ps) (cons (+ 1 (cdr ps)) (cons (car ps) (+ (cdr ps) 0.5))))))]) (and (= (sample-prob p1 'g0) 7) (approx=? (sample-prob p2 'g0) 1.0 1e-12) (approx=? (weight-prob p2 'g0) 0.5 1e-12))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "skeleton", "sample-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `weight-prob`\nSpec: Project the final log-weight from run-prob output.\n\nWrite exactly one Scheme function definition for `weight-prob`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'v (cons 'next (+ (cdr ps) -0.75))))))]) (and (approx=? (weight-prob p1 'g0) 0.0 1e-12) (approx=? (weight-prob p2 'g0) -0.75 1e-12) (equal? (sample-prob p2 'g0) 'v))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "spec-to-code", "weight-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `weight-prob`\nBehavior contract: Project the final log-weight from run-prob output.\n\n```scheme\n(define (weight-prob p prng)\n  ;; TODO: extract log-weight from run-prob result\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'v (cons 'next (+ (cdr ps) -0.75))))))]) (and (approx=? (weight-prob p1 'g0) 0.0 1e-12) (approx=? (weight-prob p2 'g0) -0.75 1e-12) (equal? (sample-prob p2 'g0) 'v))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "skeleton", "weight-prob"], "split": "train"}
{"id": "random_probability_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `prob-bind`\nSpec: Monad bind: sequence probability computations while threading internal state.\n\nWrite exactly one Scheme function definition for `prob-bind`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "spec-to-code", "prob-bind"], "split": "train"}
{"id": "random_probability_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `prob-bind`\nBehavior contract: Monad bind: sequence probability computations while threading internal state.\n\n```scheme\n(define (prob-bind p f)\n  ;; TODO: sequence p then f, threading probability state\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "skeleton", "prob-bind"], "split": "train"}
{"id": "random_probability_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `log-sum-exp`\nBehavior contract: Compute numerically stable log(sum(exp(xs))) with empty/all -inf edge handling.\n\n```scheme\n(define (log-sum-exp xs)\n  ;; TODO: stable log-sum-exp with empty and all -inf handling\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([a (log-sum-exp '(0.0 0.0))] [b (log-sum-exp (list (log-num 2.0) 0.0))] [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)] [base (log-sum-exp '(0.0 -1.0 -3.0))]) (and (= (log-sum-exp '()) -inf.0) (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0) (approx=? a (log-num 2.0) 1e-9) (approx=? b (log-num 3.0) 1e-9) (approx=? shifted base 1e-9))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "skeleton", "log-sum-exp"], "split": "train"}
{"id": "random_probability_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `normalize-log-weights`\nSpec: Normalize log-weights by subtracting log-sum-exp; return uniform probabilities when all entries are -inf.\n\nWrite exactly one Scheme function definition for `normalize-log-weights`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "spec-to-code", "normalize-log-weights"], "split": "train"}
{"id": "random_probability_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/probability.ss\nFunction target: `normalize-log-weights`\nBehavior contract: Normalize log-weights by subtracting log-sum-exp; return uniform probabilities when all entries are -inf.\n\n```scheme\n(define (normalize-log-weights log-ws)\n  ;; TODO: normalize by total log-mass; fallback uniform when all impossible\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "skeleton", "normalize-log-weights"], "split": "train"}
{"id": "random_probability_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `make-prob`\n\n```scheme\n(define (wrap-prob state-comp)\n  (cons 'prob state-comp))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "translation", "chez", "make-prob"], "split": "train"}
{"id": "random_probability_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `prob?`\n\n```python\ndef is_prob(x):\n    return isinstance(x, tuple) and len(x) > 0 and x[0] == 'prob'\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (prob? (make-prob (state-pure 3))))\n(let () (prob? '(prob . fake)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "translation", "python", "prob?"], "split": "train"}
{"id": "random_probability_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `prob?`\n\n```scheme\n(define (probability? x)\n  (and (pair? x)\n       (eq? (car x) 'prob)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "translation", "chez", "prob?"], "split": "train"}
{"id": "random_probability_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `run-prob`\n\n```python\ndef run_prob(p, prng):\n    value, final_state = run_state(prob_state(p), (prng, 0.0))\n    final_prng, log_w = final_state\n    return (value, log_w), final_prng\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "python", "run-prob"], "split": "train"}
{"id": "random_probability_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `run-prob`\n\n```scheme\n(define (execute-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n    (let ([value (car result)]\n          [final-state (cdr result)])\n      (cons (cons value (cdr final-state))\n            (car final-state)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "chez", "run-prob"], "split": "train"}
{"id": "random_probability_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `sample-prob`\n\n```python\ndef sample_prob(p, prng):\n    return run_prob(p, prng)[0][0]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "python", "sample-prob"], "split": "train"}
{"id": "random_probability_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sample-prob`\n\n```scheme\n(define (prob-sample p prng)\n  (car (car (run-prob p prng))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "chez", "sample-prob"], "split": "train"}
{"id": "random_probability_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `weight-prob`\n\n```scheme\n(define (prob-weight p prng)\n  (cdr (car (run-prob p prng))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'v (cons 'next (+ (cdr ps) -0.75))))))]) (and (approx=? (weight-prob p1 'g0) 0.0 1e-12) (approx=? (weight-prob p2 'g0) -0.75 1e-12) (equal? (sample-prob p2 'g0) 'v))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "translation", "chez", "weight-prob"], "split": "train"}
{"id": "random_probability_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `prob-bind`\n\n```python\ndef prob_bind(p, f):\n    return make_prob(\n        state_bind(prob_state(p), lambda a: prob_state(f(a)))\n    )\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "python", "prob-bind"], "split": "train"}
{"id": "random_probability_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `prob-bind`\n\n```scheme\n(define (bind-prob p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                 (prob-state (f a))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "translation", "chez", "prob-bind"], "split": "train"}
{"id": "random_probability_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `log-sum-exp`\n\n```python\ndef log_sum_exp(xs):\n    if len(xs) == 0:\n        return float('-inf')\n    m = max(xs)\n    if m == float('-inf'):\n        return float('-inf')\n    return m + log(sum(exp(x - m) for x in xs))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (log-sum-exp '(0.0 0.0))] [b (log-sum-exp (list (log-num 2.0) 0.0))] [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)] [base (log-sum-exp '(0.0 -1.0 -3.0))]) (and (= (log-sum-exp '()) -inf.0) (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0) (approx=? a (log-num 2.0) 1e-9) (approx=? b (log-num 3.0) 1e-9) (approx=? shifted base 1e-9))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "translation", "python", "log-sum-exp"], "split": "train"}
{"id": "random_probability_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `log-sum-exp`\n\n```scheme\n(define (lse xs)\n  (if (null? xs)\n      -inf.0\n      (let ([mx (apply max xs)])\n        (if (= mx -inf.0)\n            -inf.0\n            (+ mx (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x mx))) xs))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (log-sum-exp '(0.0 0.0))] [b (log-sum-exp (list (log-num 2.0) 0.0))] [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)] [base (log-sum-exp '(0.0 -1.0 -3.0))]) (and (= (log-sum-exp '()) -inf.0) (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0) (approx=? a (log-num 2.0) 1e-9) (approx=? b (log-num 3.0) 1e-9) (approx=? shifted base 1e-9))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "translation", "chez", "log-sum-exp"], "split": "train"}
{"id": "random_probability_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `normalize-log-weights`\n\n```python\ndef normalize_log_weights(log_ws):\n    total = log_sum_exp(log_ws)\n    if total == float('-inf'):\n        return [1.0 / len(log_ws) for _ in log_ws]\n    return [lw - total for lw in log_ws]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "translation", "python", "normalize-log-weights"], "split": "train"}
{"id": "random_probability_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-prob` in `lattice/random/probability.ss`.\nKnown issue: The tag symbol must be exactly 'prob for predicate compatibility.\n\n```scheme\n(define (make-prob state-comp)\n  (cons 'probability state-comp))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n(let () (eq? (car (make-prob (state-pure 1))) 'prob))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "bugfix", "make-prob"], "split": "train"}
{"id": "random_probability_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prob?` in `lattice/random/probability.ss`.\nKnown issue: The predicate should recognize 'prob values, not state wrappers.\n\n```scheme\n(define (prob? x)\n  (and (pair? x) (eq? (car x) 'state)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (prob? (make-prob (state-pure 3))))\n(let () (prob? '(prob . fake)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "bugfix", "prob?"], "split": "train"}
{"id": "random_probability_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prob?` in `lattice/random/probability.ss`.\nKnown issue: The predicate is too permissive: only the 'prob tag is valid.\n\n```scheme\n(define (prob? x)\n  (and (pair? x)\n       (or (eq? (car x) 'prob)\n           (eq? (car x) 'state))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (prob? (make-prob (state-pure 3))))\n(let () (prob? '(prob . fake)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "bugfix", "prob?"], "split": "train"}
{"id": "random_probability_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `run-prob` in `lattice/random/probability.ss`.\nKnown issue: Probability computations must start with zero log-weight, not 1.0.\n\n```scheme\n(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 1.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Probability computations must start with zero log-weight, not 1.0.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "run-prob"], "split": "train"}
{"id": "random_probability_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `run-prob` in `lattice/random/probability.ss`.\nKnown issue: The output pair structure is swapped; preserve ((value . log-weight) . new-prng).\n\n```scheme\n(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (car final-state))\n                  (cdr final-state)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The output pair structure is swapped; preserve ((value . log-weight) . new-prng).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (prob-pure 42)] [r1 (run-prob p1 'seed-a)] [p2 (make-prob (make-state (lambda (ps) (cons 'done (cons 'seed-b (+ (cdr ps) 1.25))))))] [r2 (run-prob p2 'seed-a)]) (and (equal? r1 (cons (cons 42 0.0) 'seed-a)) (equal? (car (car r2)) 'done) (equal? (cdr r2) 'seed-b) (approx=? (cdr (car r2)) 1.25 1e-12))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 42)]\n       [r1 (run-prob p1 'seed-a)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'done\n                                (cons 'seed-b (+ (cdr ps) 1.25))))))]\n       [r2 (run-prob p2 'seed-a)])\n  (and (equal? r1 (cons (cons 42 0.0) 'seed-a))\n       (equal? (car (car r2)) 'done)\n       (equal? (cdr r2) 'seed-b)\n       (approx=? (cdr (car r2)) 1.25 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "run-prob"], "split": "train"}
{"id": "random_probability_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sample-prob` in `lattice/random/probability.ss`.\nKnown issue: This extracts weight instead of sampled value.\n\n```scheme\n(define (sample-prob p prng)\n  (cdr (car (run-prob p prng))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: This extracts weight instead of sampled value.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (prob-pure 7)] [p2 (make-prob (make-state (lambda (ps) (cons (+ 1 (cdr ps)) (cons (car ps) (+ (cdr ps) 0.5))))))]) (and (= (sample-prob p1 'g0) 7) (approx=? (sample-prob p2 'g0) 1.0 1e-12) (approx=? (weight-prob p2 'g0) 0.5 1e-12))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (prob-pure 7)] [p2 (make-prob (make-state (lambda (ps) (cons (+ 1 (cdr ps)) (cons (car ps) (+ (cdr ps) 0.5))))))]) (and (= (sample-prob p1 'g0) 7) (approx=? (sample-prob p2 'g0) 1.0 1e-12) (approx=? (weight-prob p2 'g0) 0.5 1e-12))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "sample-prob"], "split": "train"}
{"id": "random_probability_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sample-prob` in `lattice/random/probability.ss`.\nKnown issue: This returns the (value . weight) pair, not the sample value itself.\n\n```scheme\n(define (sample-prob p prng)\n  (car (run-prob p prng)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: This returns the (value . weight) pair, not the sample value itself.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p1 (prob-pure 7)] [p2 (make-prob (make-state (lambda (ps) (cons (+ 1 (cdr ps)) (cons (car ps) (+ (cdr ps) 0.5))))))]) (and (= (sample-prob p1 'g0) 7) (approx=? (sample-prob p2 'g0) 1.0 1e-12) (approx=? (weight-prob p2 'g0) 0.5 1e-12))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "sample-prob"], "split": "train"}
{"id": "random_probability_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `weight-prob` in `lattice/random/probability.ss`.\nKnown issue: This returns the new PRNG state instead of log-weight.\n\n```scheme\n(define (weight-prob p prng)\n  (cdr (run-prob p prng)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'v (cons 'next (+ (cdr ps) -0.75))))))]) (and (approx=? (weight-prob p1 'g0) 0.0 1e-12) (approx=? (weight-prob p2 'g0) -0.75 1e-12) (equal? (sample-prob p2 'g0) 'v))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "bugfix", "weight-prob"], "split": "train"}
{"id": "random_probability_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prob-bind` in `lattice/random/probability.ss`.\nKnown issue: state-bind expects the continuation to return state computations; extract prob-state from f(a).\n\n```scheme\n(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (f a)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "prob-bind"], "split": "train"}
{"id": "random_probability_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prob-bind` in `lattice/random/probability.ss`.\nKnown issue: The continuation must apply f to the bound value a, not to the original computation p.\n\n```scheme\n(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f p))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([left (run-prob (prob-bind (prob-pure 9)\n                                  (lambda (x) (prob-pure (+ x 2))))\n                       'seed-x)]\n       [right (run-prob (prob-pure 11) 'seed-x)]\n       [p (make-prob\n           (make-state\n            (lambda (ps)\n              (cons 3 (cons 'inner (+ (cdr ps) 0.5))))))]\n       [f (lambda (x)\n            (make-prob\n             (make-state\n              (lambda (ps)\n                (cons (+ x 4) (cons (car ps) (+ (cdr ps) 1.0)))))))]\n       [r (run-prob (prob-bind p f) 'seed0)])\n  (and (equal? left right)\n       (= (car (car r)) 7)\n       (equal? (cdr r) 'inner)\n       (approx=? (cdr (car r)) 1.5 1e-12))))", "tags": ["tier1", "random", "probability", "bugfix", "prob-bind"], "split": "train"}
{"id": "random_probability_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-sum-exp` in `lattice/random/probability.ss`.\nKnown issue: The implementation must use max-subtraction for numerical stability.\n\n```scheme\n(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (log-num (fold-left + 0 (map exp-num xs)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "bugfix", "log-sum-exp"], "split": "train"}
{"id": "random_probability_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `log-sum-exp` in `lattice/random/probability.ss`.\nKnown issue: All -inf inputs should return -inf.0, not 0.0.\n\n```scheme\n(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               0.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "bugfix", "log-sum-exp"], "split": "train"}
{"id": "random_probability_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `normalize-log-weights` in `lattice/random/probability.ss`.\nKnown issue: Normalization should subtract total log mass, not add it.\n\n```scheme\n(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (+ lw total)) log-ws))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "bugfix", "normalize-log-weights"], "split": "train"}
{"id": "random_probability_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `make-prob (state-pure 5)` and `prob-pure 5` produce identical `run-prob` outputs.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (run-prob (make-prob (state-pure 5)) 'seed-a) (run-prob (prob-pure 5) 'seed-a))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (equal? (run-prob (make-prob (state-pure 5)) 'seed-a) (run-prob (prob-pure 5) 'seed-a)) #t))", "tags": ["tier1", "random", "probability", "composition", "make-prob", "equivalence"], "split": "train"}
{"id": "random_probability_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a custom weighted computation with `make-prob` and return its resulting weight.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(cdr (car (run-prob (make-prob (make-state (lambda (ps) (cons 'ok (cons (car ps) (+ (cdr ps) 2.0)))))) 'seed-b)))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (cdr (car (run-prob (make-prob (make-state (lambda (ps) (cons 'ok (cons (car ps) (+ (cdr ps) 2.0)))))) 'seed-b))) 2.0 1e-12))", "tags": ["tier1", "random", "probability", "composition", "make-prob", "weighted-state"], "split": "train"}
{"id": "random_probability_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse `make-prob` plus `state-bind` to square 3 and sample the resulting value.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sample-prob (make-prob (state-bind (state-pure 3) (lambda (x) (state-pure (* x x))))) 'seed-c)", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (equal? (sample-prob (make-prob (state-bind (state-pure 3) (lambda (x) (state-pure (* x x))))) 'seed-c) 9))", "tags": ["tier1", "random", "probability", "composition", "make-prob", "state-bind"], "split": "train"}
{"id": "random_probability_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount how many values in a mixed list are recognized by `prob?`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(length (filter prob? (list (make-prob (state-pure 1)) '(prob . bogus) '(state . 2) 99)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (equal? (length (filter prob? (list (make-prob (state-pure 1)) '(prob . bogus) '(state . 2) 99))) 2))", "tags": ["tier1", "random", "probability", "composition", "prob?", "filter"], "split": "train"}
{"id": "random_probability_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `prob-bind` preserves the probability wrapper tag.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(prob? (prob-bind (prob-pure 1) (lambda (x) (prob-pure (+ x 1)))))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (prob? (prob-bind (prob-pure 1) (lambda (x) (prob-pure (+ x 1))))) #t))", "tags": ["tier1", "random", "probability", "composition", "prob?", "bind-tag"], "split": "train"}
{"id": "random_probability_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap `prob?` across mixed values and return the boolean result vector.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map prob? (list (make-prob (state-pure 'a)) '(prob . 1) 'prob (cons 'x 1)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (equal? (map prob? (list (make-prob (state-pure 'a)) '(prob . 1) 'prob (cons 'x 1))) '(#t #t #f #f)))", "tags": ["tier1", "random", "probability", "composition", "prob?", "map"], "split": "train"}
{"id": "random_probability_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that `run-prob` output is not itself a tagged probability value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(not (prob? (run-prob (prob-pure 7) 'seed-d)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (not (prob? (run-prob (prob-pure 7) 'seed-d))) #t))", "tags": ["tier1", "random", "probability", "composition", "prob?", "projection"], "split": "train"}
{"id": "random_probability_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun a custom transition and return the final PRNG marker from `run-prob`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(cdr (run-prob (make-prob (make-state (lambda (ps) (cons 'v (cons 'next-r (+ (cdr ps) 0.25)))))) 'seed-r2))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (equal? (cdr (run-prob (make-prob (make-state (lambda (ps) (cons 'v (cons 'next-r (+ (cdr ps) 0.25)))))) 'seed-r2)) 'next-r))", "tags": ["tier1", "random", "probability", "composition", "run-prob", "state-thread"], "split": "train"}
{"id": "random_probability_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `run-prob` is deterministic for identical computation and seed.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (run-prob (prob-bind (prob-pure 2) (lambda (x) (prob-pure (+ x 8)))) 'seed-r3) (run-prob (prob-bind (prob-pure 2) (lambda (x) (prob-pure (+ x 8)))) 'seed-r3))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (equal? (run-prob (prob-bind (prob-pure 2) (lambda (x) (prob-pure (+ x 8)))) 'seed-r3) (run-prob (prob-bind (prob-pure 2) (lambda (x) (prob-pure (+ x 8)))) 'seed-r3)) #t))", "tags": ["tier1", "random", "probability", "composition", "run-prob", "determinism"], "split": "train"}
{"id": "random_probability_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse `run-prob` and return `(value . weight)` for a custom weighted computation.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (run-prob (make-prob (make-state (lambda (ps) (cons 11 (cons 'seed-r4 (+ (cdr ps) -0.5)))))) 'seed-r4)]) (cons (car (car r)) (cdr (car r))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (equal? (let ([r (run-prob (make-prob (make-state (lambda (ps) (cons 11 (cons 'seed-r4 (+ (cdr ps) -0.5)))))) 'seed-r4)]) (cons (car (car r)) (cdr (car r)))) (cons 11 -0.5)))", "tags": ["tier1", "random", "probability", "composition", "run-prob", "value-weight"], "split": "train"}
{"id": "random_probability_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nSample from a bound deterministic computation that doubles and increments.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sample-prob (prob-bind (prob-pure 10) (lambda (x) (prob-pure (+ (* 2 x) 1)))) 'seed-s1)", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (sample-prob (prob-bind (prob-pure 10) (lambda (x) (prob-pure (+ (* 2 x) 1)))) 'seed-s1) 21))", "tags": ["tier1", "random", "probability", "composition", "sample-prob", "bind"], "split": "train"}
{"id": "random_probability_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse `sample-prob` to return two sampled values from two independent pure computations.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (sample-prob (prob-pure 'a) 'seed-s2) (sample-prob (prob-pure 'b) 'seed-s2))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (list (sample-prob (prob-pure 'a) 'seed-s2) (sample-prob (prob-pure 'b) 'seed-s2)) '(a b)))", "tags": ["tier1", "random", "probability", "composition", "sample-prob", "multi"], "split": "train"}
{"id": "random_probability_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that `sample-prob` matches projecting the value field out of `run-prob`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p (make-prob (make-state (lambda (ps) (cons 3.5 (cons (car ps) (+ (cdr ps) 1.0))))))]) (= (sample-prob p 'seed-s3) (car (car (run-prob p 'seed-s3)))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (equal? (let ([p (make-prob (make-state (lambda (ps) (cons 3.5 (cons (car ps) (+ (cdr ps) 1.0))))))]) (= (sample-prob p 'seed-s3) (car (car (run-prob p 'seed-s3))))) #t))", "tags": ["tier1", "random", "probability", "composition", "sample-prob", "projection"], "split": "train"}
{"id": "random_probability_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: small integration task across module primitives.\n\nMap `sample-prob` over a list of deterministic probability computations.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map (lambda (p) (sample-prob p 'seed-s4)) (list (prob-pure 1) (prob-pure 2) (prob-pure 3)))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (map (lambda (p) (sample-prob p 'seed-s4)) (list (prob-pure 1) (prob-pure 2) (prob-pure 3))) '(1 2 3)))", "tags": ["tier1", "random", "probability", "composition", "sample-prob", "map"], "split": "train"}
{"id": "random_probability_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify `weight-prob` matches the weight projection from `run-prob` for a custom computation.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p (make-prob (make-state (lambda (ps) (cons 99 (cons 'seed-w2 (+ (cdr ps) 0.75))))))]) (approx=? (weight-prob p 'seed-w2) (cdr (car (run-prob p 'seed-w2))) 1e-12))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (let ([p (make-prob (make-state (lambda (ps) (cons 99 (cons 'seed-w2 (+ (cdr ps) 0.75))))))]) (approx=? (weight-prob p 'seed-w2) (cdr (car (run-prob p 'seed-w2))) 1e-12)) #t))", "tags": ["tier1", "random", "probability", "composition", "weight-prob", "projection"], "split": "train"}
{"id": "random_probability_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: small integration task across module primitives.\n\nBind into a weighted inner computation and return the resulting log-weight.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(weight-prob (prob-bind (prob-pure 5) (lambda (x) (make-prob (make-state (lambda (ps) (cons (+ x 1) (cons (car ps) (+ (cdr ps) -0.25)))))))) 'seed-w3)", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (weight-prob (prob-bind (prob-pure 5) (lambda (x) (make-prob (make-state (lambda (ps) (cons (+ x 1) (cons (car ps) (+ (cdr ps) -0.25)))))))) 'seed-w3) -0.25 1e-12))", "tags": ["tier1", "random", "probability", "composition", "weight-prob", "bind-weight"], "split": "train"}
{"id": "random_probability_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether chaining two weighted steps accumulates to total log-weight 1.0.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p (prob-bind (make-prob (make-state (lambda (ps) (cons 4 (cons (car ps) (+ (cdr ps) 1.5)))))) (lambda (x) (make-prob (make-state (lambda (ps) (cons x (cons (car ps) (+ (cdr ps) -0.5))))))))]) (approx=? (weight-prob p 'seed-w4) 1.0 1e-12))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (let ([p (prob-bind (make-prob (make-state (lambda (ps) (cons 4 (cons (car ps) (+ (cdr ps) 1.5)))))) (lambda (x) (make-prob (make-state (lambda (ps) (cons x (cons (car ps) (+ (cdr ps) -0.5))))))))]) (approx=? (weight-prob p 'seed-w4) 1.0 1e-12)) #t))", "tags": ["tier1", "random", "probability", "composition", "weight-prob", "accumulation"], "split": "train"}
{"id": "random_probability_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nChain two pure transforms with `prob-bind` and sample the final value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sample-prob (prob-bind (prob-pure 3) (lambda (x) (prob-bind (prob-pure (+ x 2)) (lambda (y) (prob-pure (* y 4)))))) 'seed-b1)", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (sample-prob (prob-bind (prob-pure 3) (lambda (x) (prob-bind (prob-pure (+ x 2)) (lambda (y) (prob-pure (* y 4)))))) 'seed-b1) 20))", "tags": ["tier1", "random", "probability", "composition", "prob-bind", "nested-bind"], "split": "train"}
{"id": "random_probability_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck the left-identity law for `prob-bind` with `x -> x+1` at x=7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (run-prob (prob-bind (prob-pure 7) (lambda (x) (prob-pure (+ x 1)))) 'seed-b2) (run-prob ((lambda (x) (prob-pure (+ x 1))) 7) 'seed-b2))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (equal? (run-prob (prob-bind (prob-pure 7) (lambda (x) (prob-pure (+ x 1)))) 'seed-b2) (run-prob ((lambda (x) (prob-pure (+ x 1))) 7) 'seed-b2)) #t))", "tags": ["tier1", "random", "probability", "composition", "prob-bind", "law-left-identity"], "split": "train"}
{"id": "random_probability_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck associativity of `prob-bind` with stateful first and second stages.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-prob (make-state (lambda (ps) (cons 2 (cons (car ps) (+ (cdr ps) 0.1))))))] [f (lambda (x) (make-prob (make-state (lambda (ps) (cons (+ x 3) (cons (car ps) (+ (cdr ps) 0.2)))))))] [g (lambda (y) (prob-pure (* y 5)))]) (equal? (run-prob (prob-bind (prob-bind m f) g) 'seed-b3) (run-prob (prob-bind m (lambda (x) (prob-bind (f x) g))) 'seed-b3)))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (let* ([m (make-prob (make-state (lambda (ps) (cons 2 (cons (car ps) (+ (cdr ps) 0.1))))))] [f (lambda (x) (make-prob (make-state (lambda (ps) (cons (+ x 3) (cons (car ps) (+ (cdr ps) 0.2)))))))] [g (lambda (y) (prob-pure (* y 5)))]) (equal? (run-prob (prob-bind (prob-bind m f) g) 'seed-b3) (run-prob (prob-bind m (lambda (x) (prob-bind (f x) g))) 'seed-b3))) #t))", "tags": ["tier1", "random", "probability", "composition", "prob-bind", "law-associativity"], "split": "train"}
{"id": "random_probability_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute a softmax denominator in log-space from logits `(2, 1, 0)` after subtracting 2 from each logit.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(log-sum-exp (map (lambda (x) (- x 2.0)) '(2.0 1.0 0.0)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (log-sum-exp (map (lambda (x) (- x 2.0)) '(2.0 1.0 0.0))) (log-num (+ 1.0 (exp-num -1.0) (exp-num -2.0))) 1e-9))", "tags": ["tier1", "random", "probability", "composition", "log-sum-exp", "softmax"], "split": "train"}
{"id": "random_probability_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `log-sum-exp` is shift-invariant for vectors `(0,-1,-2)` and `(5,4,3)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (- (log-sum-exp '(5.0 4.0 3.0)) 5.0) (log-sum-exp '(0.0 -1.0 -2.0)) 1e-9)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (- (log-sum-exp '(5.0 4.0 3.0)) 5.0) (log-sum-exp '(0.0 -1.0 -2.0)) 1e-9) #t))", "tags": ["tier1", "random", "probability", "composition", "log-sum-exp", "invariance"], "split": "train"}
{"id": "random_probability_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: compose existing APIs into one expression.\n\nExponentiate `log-sum-exp` of normalized log-probabilities and return the recovered mass.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(exp-num (log-sum-exp (list (log-num 0.2) (log-num 0.3) (log-num 0.5))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (exp-num (log-sum-exp (list (log-num 0.2) (log-num 0.3) (log-num 0.5)))) 1.0 1e-9))", "tags": ["tier1", "random", "probability", "composition", "log-sum-exp", "recovery"], "split": "train"}
{"id": "random_probability_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nNormalize log-weights, exponentiate, and return the resulting probability sum.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([logs '(0.0 -2.0 -4.0)] [norm (normalize-log-weights logs)]) (log-sum-exp norm))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (let* ([logs '(0.0 -2.0 -4.0)] [norm (normalize-log-weights logs)]) (log-sum-exp norm)) 0.0 1e-9))", "tags": ["tier1", "random", "probability", "composition", "log-sum-exp", "integration"], "split": "train"}
{"id": "random_probability_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse `normalize-log-weights` on ratios 1:2:3 and return linear-space probabilities.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map exp-num (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p (map exp-num (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0))))]) (and (approx=? (car p) (/ 1.0 6.0) 1e-9) (approx=? (cadr p) (/ 2.0 6.0) 1e-9) (approx=? (caddr p) (/ 3.0 6.0) 1e-9))))", "tags": ["tier1", "random", "probability", "composition", "normalize-log-weights", "ratios"], "split": "train"}
{"id": "random_probability_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `normalize-log-weights` is invariant to adding a constant shift to every log-weight.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a (normalize-log-weights '(0.0 -1.0 -2.0))] [b (normalize-log-weights '(3.0 2.0 1.0))]) (and (approx=? (car a) (car b) 1e-9) (approx=? (cadr a) (cadr b) 1e-9) (approx=? (caddr a) (caddr b) 1e-9)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (let ([a (normalize-log-weights '(0.0 -1.0 -2.0))] [b (normalize-log-weights '(3.0 2.0 1.0))]) (and (approx=? (car a) (car b) 1e-9) (approx=? (cadr a) (cadr b) 1e-9) (approx=? (caddr a) (caddr b) 1e-9))) #t))", "tags": ["tier1", "random", "probability", "composition", "normalize-log-weights", "shift-invariance"], "split": "train"}
{"id": "random_probability_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse `normalize-log-weights` on all `-inf` log-weights and return the sum of fallback values.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-left + 0.0 (normalize-log-weights (list -inf.0 -inf.0 -inf.0 -inf.0)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (fold-left + 0.0 (normalize-log-weights (list -inf.0 -inf.0 -inf.0 -inf.0))) 1.0 1e-9))", "tags": ["tier1", "random", "probability", "composition", "normalize-log-weights", "fallback"], "split": "train"}
