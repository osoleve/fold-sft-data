{"id": "random_probability_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `prob?`\nSpec: Return #t exactly when a value is a tagged probability computation with leading symbol 'prob.\n\nWrite exactly one Scheme function definition for `prob?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (prob? (make-prob (state-pure 3))))\n(let () (prob? '(prob . fake)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))", "verify_expr": "(let ()\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (and\n  (prob? (make-prob (state-pure 3)))\n  (prob? '(prob . fake))\n  (not (prob? '(state . 2)))\n  (not (prob? 17))))", "tags": ["tier1", "random", "probability", "spec-to-code", "prob?"], "split": "eval"}
{"id": "random_probability_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "sample-prob", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `sample-prob`\nSpec: Project the sampled value from run-prob output.\n\nWrite exactly one Scheme function definition for `sample-prob`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p1 (prob-pure 7)] [p2 (make-prob (make-state (lambda (ps) (cons (+ 1 (cdr ps)) (cons (car ps) (+ (cdr ps) 0.5))))))]) (and (= (sample-prob p1 'g0) 7) (approx=? (sample-prob p2 'g0) 1.0 1e-12) (approx=? (weight-prob p2 'g0) 0.5 1e-12))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sample-prob p prng)\n  (car (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 7)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons (+ 1 (cdr ps))\n                                (cons (car ps) (+ (cdr ps) 0.5))))))])\n  (and (= (sample-prob p1 'g0) 7)\n       (approx=? (sample-prob p2 'g0) 1.0 1e-12)\n       (approx=? (weight-prob p2 'g0) 0.5 1e-12))))", "tags": ["tier1", "random", "probability", "spec-to-code", "sample-prob"], "split": "eval"}
{"id": "random_probability_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "log-sum-exp", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/probability.ss\nFunction: `log-sum-exp`\nSpec: Compute numerically stable log(sum(exp(xs))) with empty/all -inf edge handling.\n\nWrite exactly one Scheme function definition for `log-sum-exp`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([a (log-sum-exp '(0.0 0.0))]\n       [b (log-sum-exp (list (log-num 2.0) 0.0))]\n       [shifted (- (log-sum-exp '(2.0 1.0 -1.0)) 2.0)]\n       [base (log-sum-exp '(0.0 -1.0 -3.0))])\n  (and (= (log-sum-exp '()) -inf.0)\n       (= (log-sum-exp (list -inf.0 -inf.0)) -inf.0)\n       (approx=? a (log-num 2.0) 1e-9)\n       (approx=? b (log-num 3.0) 1e-9)\n       (approx=? shifted base 1e-9))))", "tags": ["tier1", "random", "probability", "spec-to-code", "log-sum-exp"], "split": "eval"}
{"id": "random_probability_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-prob`\n\n```python\ndef make_prob(state_comp):\n    return ('prob', state_comp)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n(let () (eq? (car (make-prob (state-pure 1))) 'prob))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "translation", "python", "make-prob"], "split": "eval"}
{"id": "random_probability_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `weight-prob`\n\n```python\ndef weight_prob(p, prng):\n    return run_prob(p, prng)[0][1]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'v (cons 'next (+ (cdr ps) -0.75))))))]) (and (approx=? (weight-prob p1 'g0) 0.0 1e-12) (approx=? (weight-prob p2 'g0) -0.75 1e-12) (equal? (sample-prob p2 'g0) 'v))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "translation", "python", "weight-prob"], "split": "eval"}
{"id": "random_probability_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `normalize-log-weights`\n\n```scheme\n(define (normalize-lw log-ws)\n  (let ([total (log-sum-exp log-ws)])\n    (if (= total -inf.0)\n        (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n        (map (lambda (lw) (- lw total)) log-ws))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "translation", "chez", "normalize-log-weights"], "split": "eval"}
{"id": "random_probability_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-prob` in `lattice/random/probability.ss`.\nKnown issue: The representation must be a pair/tagged cons, not a list with an extra nesting layer.\n\n```scheme\n(define (make-prob state-comp)\n  (list 'prob state-comp))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The representation must be a pair/tagged cons, not a list with an extra nesting layer.\n\nExpected behavior after patch:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (prob? (make-prob (state-pure 1))))\n(let () (eq? (car (make-prob (state-pure 1))) 'prob))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-prob state-comp)\n  (cons 'prob state-comp))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (prob? x)\n  (and (pair? x) (eq? (car x) 'prob)))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-state p)\n  (cdr p))\n  (and\n  (prob? (make-prob (state-pure 1)))\n  (eq? (car (make-prob (state-pure 1))) 'prob)\n  (equal? (run-state (prob-state (make-prob (state-pure 'ok))) (cons 'g0 0.0))\n          (cons 'ok (cons 'g0 0.0)))\n  (not (prob? '(not-prob . 1)))))", "tags": ["tier1", "random", "probability", "bugfix", "make-prob"], "split": "eval"}
{"id": "random_probability_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `weight-prob` in `lattice/random/probability.ss`.\nKnown issue: This returns value; weight-prob must project the log-weight field.\n\n```scheme\n(define (weight-prob p prng)\n  (car (car (run-prob p prng))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (sample-prob p prng)\n  (car (car (run-prob p prng))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([p1 (prob-pure 'x)]\n       [p2 (make-prob\n            (make-state (lambda (ps)\n                          (cons 'v (cons 'next (+ (cdr ps) -0.75))))))])\n  (and (approx=? (weight-prob p1 'g0) 0.0 1e-12)\n       (approx=? (weight-prob p2 'g0) -0.75 1e-12)\n       (equal? (sample-prob p2 'g0) 'v))))", "tags": ["tier1", "random", "probability", "bugfix", "weight-prob"], "split": "eval"}
{"id": "random_probability_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `normalize-log-weights` in `lattice/random/probability.ss`.\nKnown issue: When all entries are impossible (-inf), return uniform fallback probabilities.\n\n```scheme\n(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           log-ws\n           (map (lambda (lw) (- lw total)) log-ws))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([norm (normalize-log-weights (list 0.0 (log-num 2.0) (log-num 3.0)))]\n       [probs (map exp-num norm)]\n       [sum-p (fold-left + 0.0 probs)]\n       [all-neg? (= (length (filter (lambda (x) (<= x 0.0)) norm)) (length norm))]\n       [fallback (normalize-log-weights (list -inf.0 -inf.0 -inf.0))]\n       [fallback-sum (fold-left + 0.0 fallback)]\n       [uniform? (= (length (filter (lambda (x) (approx=? x (/ 1.0 3.0) 1e-9)) fallback)) 3)])\n  (and (approx=? sum-p 1.0 1e-9)\n       all-neg?\n       (approx=? fallback-sum 1.0 1e-9)\n       uniform?)))", "tags": ["tier1", "random", "probability", "bugfix", "normalize-log-weights"], "split": "eval"}
{"id": "random_probability_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "make-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrap `(state-pure 12)` with `make-prob`, run it, and return the sampled value.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(car (car (run-prob (make-prob (state-pure 12)) 's0)))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (equal? (car (car (run-prob (make-prob (state-pure 12)) 's0))) 12))", "tags": ["tier1", "random", "probability", "composition", "make-prob", "state-wrap"], "split": "eval"}
{"id": "random_probability_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "run-prob", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun `(prob-pure 42)` with seed marker `'seed-r1` and return the full result pair.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(run-prob (prob-pure 42) 'seed-r1)", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (run-prob (prob-pure 42) 'seed-r1) (cons (cons 42 0.0) 'seed-r1)))", "tags": ["tier1", "random", "probability", "composition", "run-prob", "shape"], "split": "eval"}
{"id": "random_probability_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "weight-prob", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn weights for a pure computation and a weighted custom computation as a two-element list.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'x (cons (car ps) (+ (cdr ps) -2.0))))))]) (list (weight-prob p1 'seed-w1) (weight-prob p2 'seed-w1)))", "verify_expr": "(let ()\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (prob-state p)\n  (cdr p))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (weight-prob p prng)\n  (cdr (car (run-prob p prng))))\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (let ([p1 (prob-pure 'x)] [p2 (make-prob (make-state (lambda (ps) (cons 'x (cons (car ps) (+ (cdr ps) -2.0))))))]) (list (weight-prob p1 'seed-w1) (weight-prob p2 'seed-w1))) '(0.0 -2.0)))", "tags": ["tier1", "random", "probability", "composition", "weight-prob", "comparison"], "split": "eval"}
{"id": "random_probability_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "prob-bind", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse `prob-bind` to transform a value while preserving PRNG threading from the first stage; return `(value . new-prng)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-prob (make-state (lambda (ps) (cons 4 (cons 'seed-b4-next (+ (cdr ps) 1.0))))))] [r (run-prob (prob-bind m (lambda (x) (prob-pure (+ x 6)))) 'seed-b4)]) (cons (car (car r)) (cdr r)))", "verify_expr": "(let ()\n  (define (make-prob state-comp)\n  (cons 'prob state-comp))\n  (define (make-state run-fn)\n  (cons 'state run-fn))\n  (define (state-fn st)\n  (cdr st))\n  (define (run-state st initial-state)\n  ((state-fn st) initial-state))\n  (define (state-bind st f)\n  (make-state\n   (lambda (s)\n           (let* ([result (run-state st s)]\n                  [a (car result)]\n                  [s2 (cdr result)])\n                 (run-state (f a) s2)))))\n  (define (prob-state p)\n  (cdr p))\n  (define (prob-bind p f)\n  (make-prob\n   (state-bind (prob-state p)\n               (lambda (a)\n                       (prob-state (f a))))))\n  (define (run-prob p prng)\n  (let ([result (run-state (prob-state p) (cons prng 0.0))])\n       (let ([value (car result)]\n             [final-state (cdr result)])\n            (cons (cons value (cdr final-state))\n                  (car final-state)))))\n  (define (state-pure x)\n  (make-state (lambda (s) (cons x s))))\n  (define (prob-pure x)\n  (make-prob (state-pure x)))\n  (equal? (let* ([m (make-prob (make-state (lambda (ps) (cons 4 (cons 'seed-b4-next (+ (cdr ps) 1.0))))))] [r (run-prob (prob-bind m (lambda (x) (prob-pure (+ x 6)))) 'seed-b4)]) (cons (car (car r)) (cdr r))) (cons 10 'seed-b4-next)))", "tags": ["tier1", "random", "probability", "composition", "prob-bind", "threading"], "split": "eval"}
{"id": "random_probability_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/probability.ss", "source_test": "lattice/random/test-probability.ss", "source_function": "normalize-log-weights", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply `normalize-log-weights` to finite log-weights and return whether their log-sum-exp equals zero.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? (log-sum-exp (normalize-log-weights '(2.0 0.0 -1.0))) 0.0 1e-9)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exp-num x)\n  (exp x))\n  (define (log-sum-exp xs)\n  (if (null? xs)\n      -inf.0\n      (let ([max-x (apply max xs)])\n           (if (= max-x -inf.0)\n               -inf.0\n               (+ max-x (log-num (fold-left + 0 (map (lambda (x) (exp-num (- x max-x))) xs))))))))\n  (define (normalize-log-weights log-ws)\n  (let ([total (log-sum-exp log-ws)])\n       (if (= total -inf.0)\n           (map (lambda (_) (/ 1.0 (length log-ws))) log-ws)\n           (map (lambda (lw) (- lw total)) log-ws))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (log-sum-exp (normalize-log-weights '(2.0 0.0 -1.0))) 0.0 1e-9) #t))", "tags": ["tier1", "random", "probability", "composition", "normalize-log-weights", "consistency"], "split": "eval"}
