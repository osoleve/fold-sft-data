{"id": "meta_kg_usage_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `result->skill-name`\nSpec: Resolve the parent skill for a search result tuple based on result type and attached metadata.\n\nWrite exactly one Scheme function definition for `result->skill-name`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta))\n(let () (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "result->skill-name"], "split": "eval"}
{"id": "meta_kg_usage_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-export-source`\nSpec: Find which skill exports a symbol, handling both flat and grouped manifest export layouts.\n\nWrite exactly one Scheme function definition for `lattice-export-source`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (eq? (lattice-export-source 'lattice-find) 'meta))\n(let () (eq? (lattice-export-source 'sha256) 'crypto))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-export-source"], "split": "eval"}
{"id": "meta_kg_usage_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-find-by-tier`\nSpec: Filter skill search results to a specific numeric tier.\n\nWrite exactly one Scheme function definition for `lattice-find-by-tier`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query)))\n(let () (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-find-by-tier"], "split": "eval"}
{"id": "meta_kg_usage_translation_001", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `concept-boost-for-query`\n\n```python\ndef concept_boost_for_query(query_terms):\n    boost_set = {}\n    for term in query_terms:\n        for skill_name in kg_concept_skills(term):\n            current = boost_set.get(skill_name, 0)\n            boost_set[skill_name] = current + 1\n    return boost_set\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (concept-boost-for-query '(search optimization search))]) (and (= (hamt-lookup 'meta m) 2) (= (hamt-lookup 'query m) 3) (= (hamt-lookup 'linalg m) 1) (not (hamt-lookup 'crypto m)))))\n(let () (= (hamt-size (concept-boost-for-query '())) 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "concept-boost-for-query"], "split": "eval"}
{"id": "meta_kg_usage_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-find-prefix`\n\n```python\ndef lattice_find_prefix(prefix_sym, k=20):\n    prefix = str(prefix_sym).lower()\n    export_matches = []\n    for export_name, _ in kg_exports():\n        name = str(export_name).lower()\n        if len(name) >= len(prefix) and name[: len(prefix)] == prefix:\n            row = [export_name, 0.9, \"export\", {\"name\": export_name}]\n            mod = export_module_map.get(export_name)\n            if mod:\n                row[3][\"module\"] = mod\n            export_matches.append(row)\n    skill_matches = []\n    for skill_name in kg_skills():\n        name = str(skill_name).lower()\n        if len(name) >= len(prefix) and name[: len(prefix)] == prefix:\n            skill_matches.append([skill_name, 0.95, \"skill\", kg_skill_data(skill_name)])\n    merged = sorted(skill_matches + export_matches, key=lambda r: -r[1])\n    return merged[:k]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot)))\n(let () (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-find-prefix"], "split": "eval"}
{"id": "meta_kg_usage_translation_016", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-find-by-purity`\n\n```scheme\n(define (find-by-purity query purity . options)\n  (let* ((k (if (pair? options) (car options) 10))\n         (results (lattice-find query k 'skill)))\n    (filter\n     (lambda (result)\n       (let ((data (cadddr result)))\n         (and data\n              (let ((p (assq 'purity data)))\n                (and p (eq? (cdr p) purity))))))\n     results)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-find-by-purity"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `concept-boost-for-query` in `lattice/meta/search.ss`.\nKnown issue: Repeated concept hits must accumulate counts; overwriting to 1 loses frequency information.\n\n```scheme\n(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (hamt-assoc skill-name 1 bs))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "concept-boost-for-query"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-prefix` in `lattice/meta/search.ss`.\nKnown issue: Exact-length prefix matches should be included; use >= length guard, not >.\n\n```scheme\n(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (> (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (> (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot)))\n(let () (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-prefix"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-by-purity` in `lattice/meta/search.ss`.\nKnown issue: Compare against the provided purity argument, not the literal symbol 'purity.\n\n```scheme\n(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) 'purity))))))\n     results)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta)))\n(let () (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-by-purity"], "split": "eval"}
{"id": "meta_kg_usage_composition_001", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild concept boost counts for terms '(search optimization search)' and return counts for meta/query/linalg.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (concept-boost-for-query '(search optimization search))]) (list (hamt-lookup 'meta m) (hamt-lookup 'query m) (hamt-lookup 'linalg m)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (let ([m (concept-boost-for-query '(search optimization search))]) (list (hamt-lookup 'meta m) (hamt-lookup 'query m) (hamt-lookup 'linalg m))) '(2 3 1)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "concept-boost-for-query", "direct"], "split": "eval"}
{"id": "meta_kg_usage_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply boosts with empty map and return the unchanged result list length.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(length (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.8 skill ((tier . 1)))) hamt-empty))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (length (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.8 skill ((tier . 1)))) hamt-empty)) 2))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "apply-concept-boosts", "edge-case"], "split": "eval"}
{"id": "meta_kg_usage_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun prefix search for 'vec and return the first three ids.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map car (lattice-find-prefix 'vec 3))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-prefix", "direct"], "split": "eval"}
{"id": "meta_kg_usage_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify substring search for 'xyz returns empty list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(null? (lattice-find-substring 'xyz 5))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (null? (lattice-find-substring 'xyz 5)) #t))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-substring", "edge-case"], "split": "eval"}
{"id": "meta_kg_usage_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter query 'vector for purity 'partial and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map car (lattice-find-by-purity \"vector\" 'partial 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-purity", "integration"], "split": "eval"}
