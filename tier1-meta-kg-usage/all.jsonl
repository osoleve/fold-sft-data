{"id": "meta_kg_usage_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `concept-boost-for-query`\nSpec: Build a skill->count map from query concept terms; increment count for each matched concept-skill relation.\n\nWrite exactly one Scheme function definition for `concept-boost-for-query`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (concept-boost-for-query '(search optimization search))]) (and (= (hamt-lookup 'meta m) 2) (= (hamt-lookup 'query m) 3) (= (hamt-lookup 'linalg m) 1) (not (hamt-lookup 'crypto m))))\n(= (hamt-size (concept-boost-for-query '())) 0)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "concept-boost-for-query"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `concept-boost-for-query`\nBehavior contract: Build a skill->count map from query concept terms; increment count for each matched concept-skill relation.\n\n```scheme\n(define (concept-boost-for-query query-terms)\n  ;; TODO: accumulate concept matches into skill score boosts\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "concept-boost-for-query"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `result->skill-name`\nBehavior contract: Resolve the parent skill for a search result tuple based on result type and attached metadata.\n\n```scheme\n(define (result->skill-name result)\n  ;; TODO: decode skill identity from skill/module/export result tuple\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n(eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "result->skill-name"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `apply-concept-boosts`\nSpec: Apply multiplicative score boosts to search results based on concept-match counts with a cap.\n\nWrite exactly one Scheme function definition for `apply-concept-boosts`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))) hamt-empty) (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))))\n(let* ([out (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(lattice-find 0.8 export ((module . search))) '(sha256 0.7 export ((module . sha256)))) '((meta . 2)))]) (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001) (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001) (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `apply-concept-boosts`\nBehavior contract: Apply multiplicative score boosts to search results based on concept-match counts with a cap.\n\n```scheme\n(define (apply-concept-boosts results boost-map)\n  ;; TODO: scale scores by concept counts with cap and preserve structure\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))) hamt-empty) (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))))\n(let* ([out (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(lattice-find 0.8 export ((module . search))) '(sha256 0.7 export ((module . sha256)))) '((meta . 2)))]) (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001) (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001) (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `lattice-export-source`\nBehavior contract: Find which skill exports a symbol, handling both flat and grouped manifest export layouts.\n\n```scheme\n(define (lattice-export-source sym)\n  ;; TODO: walk skill manifests and locate which skill exports sym\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(eq? (lattice-export-source 'lattice-find) 'meta)\n(eq? (lattice-export-source 'sha256) 'crypto)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "lattice-export-source"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-find-prefix`\nSpec: Return skill/export matches whose names start with a prefix, ranked by score and truncated by k.\n\nWrite exactly one Scheme function definition for `lattice-find-prefix`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-find-prefix"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `lattice-find-prefix`\nBehavior contract: Return skill/export matches whose names start with a prefix, ranked by score and truncated by k.\n\n```scheme\n(define (lattice-find-prefix prefix-sym . options)\n  ;; TODO: prefix match across skills and exports, then sort by score\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "lattice-find-prefix"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-find-substring`\nSpec: Return skill/export matches whose names contain a substring, ranked by score and truncated by k.\n\nWrite exactly one Scheme function definition for `lattice-find-substring`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `lattice-find-substring`\nBehavior contract: Return skill/export matches whose names contain a substring, ranked by score and truncated by k.\n\n```scheme\n(define (lattice-find-substring substr-sym . options)\n  ;; TODO: substring match across skills and exports, then sort by score\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `lattice-find-by-tier`\nBehavior contract: Filter skill search results to a specific numeric tier.\n\n```scheme\n(define (lattice-find-by-tier query tier . options)\n  ;; TODO: filter skill search results by tier\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "lattice-find-by-tier"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-find-by-purity`\nSpec: Filter skill search results to a specific purity tag (e.g., total/partial).\n\nWrite exactly one Scheme function definition for `lattice-find-by-purity`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-find-by-purity"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/search.ss\nFunction target: `lattice-find-by-purity`\nBehavior contract: Filter skill search results to a specific purity tag (e.g., total/partial).\n\n```scheme\n(define (lattice-find-by-purity query purity . options)\n  ;; TODO: filter skill search results by purity symbol\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n(equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "skeleton", "lattice-find-by-purity"], "split": "train"}
{"id": "meta_kg_usage_translation_002", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `concept-boost-for-query`\n\n```scheme\n(define (concept-boost query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ((skills (kg-concept-skills term)))\n       (fold-left\n        (lambda (bs skill-name)\n          (let ((current (or (hamt-lookup skill-name bs) 0)))\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "concept-boost-for-query"], "split": "train"}
{"id": "meta_kg_usage_translation_003", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `result->skill-name`\n\n```python\ndef result_to_skill_name(result):\n    _id, _score, kind, data = result\n    if kind == \"skill\":\n        return _id\n    if kind == \"module\":\n        return data.get(\"skill\") if data else None\n    if kind == \"export\":\n        module = data.get(\"module\") if data else None\n        return module_skill_map.get(module) if module else None\n    return None\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n(eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "result->skill-name"], "split": "train"}
{"id": "meta_kg_usage_translation_004", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `result->skill-name`\n\n```scheme\n(define (result->skill result)\n  (let ((id (car result))\n        (kind (caddr result))\n        (data (cadddr result)))\n    (case kind\n      ((skill) id)\n      ((module)\n       (and data\n            (let ((s (assq 'skill data)))\n              (and s (cdr s)))))\n      ((export)\n       (and data\n            (let ((m (assq 'module data)))\n              (and m (hamt-lookup (cdr m) *module-skill-map*)))))\n      (else #f))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "result->skill-name"], "split": "train"}
{"id": "meta_kg_usage_translation_005", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `apply-concept-boosts`\n\n```python\ndef apply_concept_boosts(results, boost_map):\n    if len(boost_map) == 0:\n        return results\n    out = []\n    for _id, score, kind, data in results:\n        skill = result_to_skill_name((_id, score, kind, data))\n        count = boost_map.get(skill) if skill else None\n        if count:\n            mult = min(CONCEPT_BOOST_CAP, 1.0 + CONCEPT_BOOST * count)\n            out.append((_id, score * mult, kind, data))\n        else:\n            out.append((_id, score, kind, data))\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_translation_006", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `apply-concept-boosts`\n\n```scheme\n(define (boost-results results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ((skill (result->skill-name result))\n                    (count (and skill (hamt-lookup skill boost-map))))\n               (if count\n                   (let* ((mult (min CONCEPT-BOOST-CAP (+ 1.0 (* CONCEPT-BOOST count))))\n                          (old (cadr result)))\n                     (list (car result) (* old mult) (caddr result) (cadddr result)))\n                   result)))\n           results)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))) hamt-empty) (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))))\n(let* ([out (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(lattice-find 0.8 export ((module . search))) '(sha256 0.7 export ((module . sha256)))) '((meta . 2)))]) (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001) (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001) (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-export-source`\n\n```python\ndef lattice_export_source(sym):\n    for skill_name in kg_skills():\n        data = kg_skill_data(skill_name)\n        exports_raw = data.get(\"exports\", []) if data else []\n        if not isinstance(exports_raw, list) or len(exports_raw) == 0:\n            continue\n        if isinstance(exports_raw[0], str):\n            if sym in exports_raw:\n                return skill_name\n        else:\n            for group in exports_raw:\n                if isinstance(group, list) and sym in group:\n                    return skill_name\n    return None\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-export-source"], "split": "train"}
{"id": "meta_kg_usage_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-export-source`\n\n```scheme\n(define (export-source sym)\n  (let loop ((skills (kg-skills)))\n    (if (null? skills)\n        #f\n        (let* ((skill-name (car skills))\n               (data (kg-skill-data skill-name))\n               (exports-raw (if data\n                                (let ((e (assq 'exports data)))\n                                  (if e (cdr e) '()))\n                                '())))\n          (cond\n            ((not (list? exports-raw)) (loop (cdr skills)))\n            ((null? exports-raw) (loop (cdr skills)))\n            ((symbol? (car exports-raw))\n             (if (memq sym exports-raw) skill-name (loop (cdr skills))))\n            (else\n             (let group-loop ((groups exports-raw))\n               (if (null? groups)\n                   (loop (cdr skills))\n                   (let ((group (car groups)))\n                     (if (and (pair? group) (memq sym group))\n                         skill-name\n                         (group-loop (cdr groups))))))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (lattice-export-source 'lattice-find) 'meta)\n(eq? (lattice-export-source 'sha256) 'crypto)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-export-source"], "split": "train"}
{"id": "meta_kg_usage_translation_010", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-find-prefix`\n\n```scheme\n(define (find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ((k (if (pair? options) (car options) 20))\n         (prefix-str (string-downcase (symbol->string prefix-sym)))\n         (prefix-len (string-length prefix-str)))\n    (let* ((export-matches\n            (filter-map\n             (lambda (entry)\n               (let* ((name (car entry))\n                      (name-str (string-downcase (symbol->string name))))\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ((mod (hamt-lookup name *export-module-map*)))\n                       (list name 0.9 'export `((name . ,name) ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports)))\n           (skill-matches\n            (filter-map\n             (lambda (skill)\n               (let ((name-str (string-downcase (symbol->string skill))))\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill 0.95 'skill (kg-skill-data skill))\n                     #f)))\n             (kg-skills)))\n           (sorted (sort-by (lambda (a b) (> (cadr a) (cadr b)))\n                            (append skill-matches export-matches))))\n      (take-at-most k sorted))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-find-prefix"], "split": "train"}
{"id": "meta_kg_usage_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-find-substring`\n\n```python\ndef lattice_find_substring(substr_sym, k=20):\n    needle = str(substr_sym).lower()\n    export_matches = []\n    for export_name, _ in kg_exports():\n        name = str(export_name).lower()\n        if needle in name:\n            row = [export_name, 0.8, \"export\", {\"name\": export_name}]\n            mod = export_module_map.get(export_name)\n            if mod:\n                row[3][\"module\"] = mod\n            export_matches.append(row)\n    skill_matches = []\n    for skill_name in kg_skills():\n        name = str(skill_name).lower()\n        if needle in name:\n            skill_matches.append([skill_name, 0.85, \"skill\", kg_skill_data(skill_name)])\n    merged = sorted(skill_matches + export_matches, key=lambda r: -r[1])\n    return merged[:k]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([ids (map car (lattice-find-substring 'find 10))]) (and (memq 'lattice-find ids) (memq 'lattice-find-prefix ids) (memq 'lattice-find-substring ids)))\n(eq? (car (car (lattice-find-substring 'query 3))) 'query)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-find-substring`\n\n```scheme\n(define (find-substr substr-sym . options)\n  (ensure-indexed!)\n  (let* ((k (if (pair? options) (car options) 20))\n         (needle (string-downcase (symbol->string substr-sym))))\n    (let* ((export-matches\n            (filter-map\n             (lambda (entry)\n               (let* ((name (car entry))\n                      (name-str (string-downcase (symbol->string name))))\n                 (if (string-contains? name-str needle)\n                     (let ((mod (hamt-lookup name *export-module-map*)))\n                       (list name 0.8 'export `((name . ,name) ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports)))\n           (skill-matches\n            (filter-map\n             (lambda (skill)\n               (let ((name-str (string-downcase (symbol->string skill))))\n                 (if (string-contains? name-str needle)\n                     (list skill 0.85 'skill (kg-skill-data skill))\n                     #f)))\n             (kg-skills)))\n           (sorted (sort-by (lambda (a b) (> (cadr a) (cadr b)))\n                            (append skill-matches export-matches))))\n      (take-at-most k sorted))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_translation_013", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-find-by-tier`\n\n```python\ndef lattice_find_by_tier(query, tier, k=10):\n    rows = lattice_find(query, k, \"skill\")\n    out = []\n    for row in rows:\n        data = row[3]\n        if data is not None and data.get(\"tier\") == tier:\n            out.append(row)\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-find-by-tier"], "split": "train"}
{"id": "meta_kg_usage_translation_014", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-find-by-tier`\n\n```scheme\n(define (find-by-tier query tier . options)\n  (let* ((k (if (pair? options) (car options) 10))\n         (results (lattice-find query k 'skill)))\n    (filter\n     (lambda (result)\n       (let ((data (cadddr result)))\n         (and data\n              (let ((t (assq 'tier data)))\n                (and t (= (cdr t) tier))))))\n     results)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-find-by-tier"], "split": "train"}
{"id": "meta_kg_usage_translation_015", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-find-by-purity`\n\n```python\ndef lattice_find_by_purity(query, purity, k=10):\n    rows = lattice_find(query, k, \"skill\")\n    out = []\n    for row in rows:\n        data = row[3]\n        if data is not None and data.get(\"purity\") == purity:\n            out.append(row)\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n(equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-find-by-purity"], "split": "train"}
{"id": "meta_kg_usage_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `concept-boost-for-query` in `lattice/meta/search.ss`.\nKnown issue: Use the inner accumulator when reading current counts; reading the outer snapshot drops increments in the same fold.\n\n```scheme\n(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name boost-set) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (concept-boost-for-query '(search optimization search))]) (and (= (hamt-lookup 'meta m) 2) (= (hamt-lookup 'query m) 3) (= (hamt-lookup 'linalg m) 1) (not (hamt-lookup 'crypto m))))\n(= (hamt-size (concept-boost-for-query '())) 0)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "concept-boost-for-query"], "split": "train"}
{"id": "meta_kg_usage_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result->skill-name` in `lattice/meta/search.ss`.\nKnown issue: Module results carry parent skill under the 'skill field, not under 'name.\n\n```scheme\n(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([name (assq 'name data)])\n              (and name (cdr name))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "result->skill-name"], "split": "train"}
{"id": "meta_kg_usage_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result->skill-name` in `lattice/meta/search.ss`.\nKnown issue: Export results must map module -> skill via *module-skill-map*; returning module name is incorrect.\n\n```scheme\n(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (cdr mod))))]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n(eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "result->skill-name"], "split": "train"}
{"id": "meta_kg_usage_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-concept-boosts` in `lattice/meta/search.ss`.\nKnown issue: With an empty boost map, results should be returned unchanged, not dropped.\n\n```scheme\n(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      '()\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))) hamt-empty) (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))))\n(let* ([out (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(lattice-find 0.8 export ((module . search))) '(sha256 0.7 export ((module . sha256)))) '((meta . 2)))]) (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001) (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001) (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-concept-boosts` in `lattice/meta/search.ss`.\nKnown issue: Multiplier must be 1 + boost*count before capping; omitting the base factor under-scores all matches.\n\n```scheme\n(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (* CONCEPT-BOOST count))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))) hamt-empty) (list '(meta 1.0 skill ((tier . 1))) '(query 0.9 skill ((tier . 1)))))\n(let* ([out (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(lattice-find 0.8 export ((module . search))) '(sha256 0.7 export ((module . sha256)))) '((meta . 2)))]) (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001) (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001) (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (and\n  (equal?\n   (apply-concept-boosts\n    (list '(meta 1.0 skill ((tier . 1)))\n          '(query 0.9 skill ((tier . 1))))\n    hamt-empty)\n   (list '(meta 1.0 skill ((tier . 1)))\n         '(query 0.9 skill ((tier . 1)))))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1)))\n                     '(lattice-find 0.8 export ((module . search)))\n                     '(sha256 0.7 export ((module . sha256))))\n               '((meta . 2)))])\n    (and (< (abs (- (cadr (list-ref out 0)) 1.5)) 0.00001)\n         (< (abs (- (cadr (list-ref out 1)) 1.2)) 0.00001)\n         (< (abs (- (cadr (list-ref out 2)) 0.7)) 0.00001)))\n  (let* ([out (apply-concept-boosts\n               (list '(meta 1.0 skill ((tier . 1))))\n               '((meta . 99)))])\n    (< (abs (- (cadr (car out)) 2.0)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "apply-concept-boosts"], "split": "train"}
{"id": "meta_kg_usage_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-export-source` in `lattice/meta/search.ss`.\nKnown issue: Flat export lists must check membership across the whole list, not only the first symbol.\n\n```scheme\n(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (and (pair? exports-raw) (eq? sym (car exports-raw)))\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (lattice-export-source 'lattice-find) 'meta)\n(eq? (lattice-export-source 'sha256) 'crypto)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-export-source"], "split": "train"}
{"id": "meta_kg_usage_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-export-source` in `lattice/meta/search.ss`.\nKnown issue: Return the owning skill name, not the export symbol itself.\n\n```scheme\n(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                sym\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        sym\n                        (group-loop (cdr groups))))))])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (lattice-export-source 'lattice-find) 'meta)\n(eq? (lattice-export-source 'sha256) 'crypto)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-export-source"], "split": "train"}
{"id": "meta_kg_usage_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-prefix` in `lattice/meta/search.ss`.\nKnown issue: Results should be ranked from highest score to lowest, not ascending.\n\n```scheme\n(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (< (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-prefix"], "split": "train"}
{"id": "meta_kg_usage_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-substring` in `lattice/meta/search.ss`.\nKnown issue: Substring search must match anywhere in the name, not only at the start.\n\n```scheme\n(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) (string-length substr-str))\n                          (string=? (substring name-str 0 (string-length substr-str)) substr-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) (string-length substr-str))\n                          (string=? (substring name-str 0 (string-length substr-str)) substr-str))\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([ids (map car (lattice-find-substring 'find 10))]) (and (memq 'lattice-find ids) (memq 'lattice-find-prefix ids) (memq 'lattice-find-substring ids)))\n(eq? (car (car (lattice-find-substring 'query 3))) 'query)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-substring` in `lattice/meta/search.ss`.\nKnown issue: Skills should retain higher base score than exports in substring search.\n\n```scheme\n(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.75 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (let ([ids (map car (lattice-find-substring 'find 10))])\n    (and (memq 'lattice-find ids)\n         (memq 'lattice-find-prefix ids)\n         (memq 'lattice-find-substring ids)))\n  (eq? (car (car (lattice-find-substring 'query 3))) 'query)\n  (= (length (lattice-find-substring 'run 1)) 1)\n  (= (length (lattice-find-substring 'xyz 5)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-substring"], "split": "train"}
{"id": "meta_kg_usage_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-by-tier` in `lattice/meta/search.ss`.\nKnown issue: Tier metadata is stored under 'tier, not 'level.\n\n```scheme\n(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'level data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-by-tier"], "split": "train"}
{"id": "meta_kg_usage_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-by-tier` in `lattice/meta/search.ss`.\nKnown issue: Filter predicate must keep matching tiers, not reject them.\n\n```scheme\n(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (not (= (cdr t) tier)))))))\n     results)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-by-tier"], "split": "train"}
{"id": "meta_kg_usage_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-by-purity` in `lattice/meta/search.ss`.\nKnown issue: Purity filter must read the 'purity field, not 'tier.\n\n```scheme\n(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'tier data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-by-purity"], "split": "train"}
{"id": "meta_kg_usage_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn the size of the boost map for an empty query term list.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-size (concept-boost-for-query '())) 0)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (concept-boost-for-query '()))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (hamt-size (concept-boost-for-query '())) 0))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "concept-boost-for-query", "edge-case"], "split": "train"}
{"id": "meta_kg_usage_composition_003", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: small integration task across module primitives.\n\nUse concept boosts from '(crypto search)' to boost two results and return their boosted scores.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(let* ([boost (concept-boost-for-query '(crypto search))] [rs (apply-concept-boosts (list '(sha256 1.0 export ((module . sha256))) '(meta 1.0 skill ((tier . 1)))) boost)] [scores (map cadr rs)]) (and (< (abs (- (list-ref scores 0) 1.25)) 0.00001) (< (abs (- (list-ref scores 1) 1.25)) 0.00001)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([boost (concept-boost-for-query '(crypto search))] [rs (apply-concept-boosts (list '(sha256 1.0 export ((module . sha256))) '(meta 1.0 skill ((tier . 1)))) boost)]) (map cadr rs))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (let* ([boost (concept-boost-for-query '(crypto search))] [rs (apply-concept-boosts (list '(sha256 1.0 export ((module . sha256))) '(meta 1.0 skill ((tier . 1)))) boost)] [scores (map cadr rs)]) (and (< (abs (- (list-ref scores 0) 1.25)) 0.00001) (< (abs (- (list-ref scores 1) 1.25)) 0.00001))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "concept-boost-for-query", "integration"], "split": "train"}
{"id": "meta_kg_usage_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that repeating concept 'graph three times gives graphics a boost count of 3.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (concept-boost-for-query '(graph graph graph))]) (= (hamt-lookup 'graphics m) 3)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (concept-boost-for-query '(graph graph graph))]) (= (hamt-lookup 'graphics m) 3))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (let ([m (concept-boost-for-query '(graph graph graph))]) (= (hamt-lookup 'graphics m) 3)) #t))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "concept-boost-for-query", "property"], "split": "train"}
{"id": "meta_kg_usage_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: small integration task across module primitives.\n\nExtract parent skill from a direct skill result row.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (result->skill-name '(query 0.9 skill ((tier . 1)))) 'query)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result->skill-name '(query 0.9 skill ((tier . 1))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (result->skill-name '(query 0.9 skill ((tier . 1)))) 'query))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "result->skill-name", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract parent skill from a module result row.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(result->skill-name '(meta/search 0.8 module ((skill . meta))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (result->skill-name '(meta/search 0.8 module ((skill . meta)))) 'meta))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "result->skill-name", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: small integration task across module primitives.\n\nExtract parent skill from an export row using module->skill mapping.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result->skill-name '(sql-run 0.7 export ((module . sql))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (result->skill-name '(sql-run 0.7 export ((module . sql)))) 'query))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "result->skill-name", "integration"], "split": "train"}
{"id": "meta_kg_usage_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #f for an export row whose module has no skill mapping.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (result->skill-name '(mystery 0.2 export ((module . unknown)))) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(result->skill-name '(mystery 0.2 export ((module . unknown))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (result->skill-name '(mystery 0.2 export ((module . unknown)))) #f))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "result->skill-name", "edge-case"], "split": "train"}
{"id": "meta_kg_usage_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: small integration task across module primitives.\n\nBoost one meta skill row with count=2 and return the resulting score.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(let ([s (cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 2)))) )]) (< (abs (- s 1.5)) 0.00001))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 2)))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (let ([s (cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 2)))) )]) (< (abs (- s 1.5)) 0.00001)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "apply-concept-boosts", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBoost rows with large count and ensure capping at CONCEPT-BOOST-CAP.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let ([s (cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 100)))) )]) (< (abs (- s 2.0)) 0.00001))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 100)))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (let ([s (cadr (car (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) '((meta . 100)))) )]) (< (abs (- s 2.0)) 0.00001)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "apply-concept-boosts", "property"], "split": "train"}
{"id": "meta_kg_usage_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose concept-boost-for-query with apply-concept-boosts for query '(search)' and return boosted meta score.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([boost (concept-boost-for-query '(search))] [rows (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) boost)]) (cadr (car rows)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (let ([s (let* ([boost (concept-boost-for-query '(search))] [rows (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1)))) boost)]) (cadr (car rows)))]) (< (abs (- s 1.25)) 0.00001)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "apply-concept-boosts", "integration"], "split": "train"}
{"id": "meta_kg_usage_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFind the owning skill for export symbol lattice-find.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (lattice-export-source 'lattice-find) 'meta)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(lattice-export-source 'lattice-find)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (lattice-export-source 'lattice-find) 'meta))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-export-source", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: compose existing APIs into one expression.\n\nFind the owning skill for flat-export symbol sha256.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (lattice-export-source 'sha256) 'crypto)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(lattice-export-source 'sha256)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (lattice-export-source 'sha256) 'crypto))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-export-source", "flat-format"], "split": "train"}
{"id": "meta_kg_usage_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: small integration task across module primitives.\n\nFind the owning skill for grouped-export symbol sql-run.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (lattice-export-source 'sql-run) 'query)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(lattice-export-source 'sql-run)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (lattice-export-source 'sql-run) 'query))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-export-source", "grouped-format"], "split": "train"}
{"id": "meta_kg_usage_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #f for a symbol that is not exported by any skill.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (lattice-export-source 'not-there) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(lattice-export-source 'not-there)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (lattice-export-source 'not-there) #f))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-export-source", "edge-case"], "split": "train"}
{"id": "meta_kg_usage_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: small integration task across module primitives.\n\nRun prefix search for 'q with k=2 and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map car (lattice-find-prefix 'q 2))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-prefix", "ranking"], "split": "train"}
{"id": "meta_kg_usage_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun prefix search for 'm and return matching ids.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map car (lattice-find-prefix 'm 5))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-prefix", "skill-match"], "split": "train"}
{"id": "meta_kg_usage_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify that prefix search for 'z returns no matches.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (null? (lattice-find-prefix 'z 5)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(null? (lattice-find-prefix 'z 5))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (null? (lattice-find-prefix 'z 5)) #t))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-prefix", "edge-case"], "split": "train"}
{"id": "meta_kg_usage_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: small integration task across module primitives.\n\nRun substring search for 'find and check presence of all find exports.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let ([ids (map car (lattice-find-substring 'find 10))]) (and (if (memq 'lattice-find ids) #t #f) (if (memq 'lattice-find-prefix ids) #t #f) (if (memq 'lattice-find-substring ids) #t #f)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([ids (map car (lattice-find-substring 'find 10))]) (and (if (memq 'lattice-find ids) #t #f) (if (memq 'lattice-find-prefix ids) #t #f) (if (memq 'lattice-find-substring ids) #t #f)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (let ([ids (map car (lattice-find-substring 'find 10))]) (and (if (memq 'lattice-find ids) #t #f) (if (memq 'lattice-find-prefix ids) #t #f) (if (memq 'lattice-find-substring ids) #t #f))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-substring", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: small integration task across module primitives.\n\nRun substring search for 'query and return top id.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (car (car (lattice-find-substring 'query 3))) 'query)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(car (car (lattice-find-substring 'query 3)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (car (car (lattice-find-substring 'query 3))) 'query))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-substring", "ranking"], "split": "train"}
{"id": "meta_kg_usage_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun substring search for 'run with k=1 and return list length.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (lattice-find-substring 'run 1))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (length (lattice-find-substring 'run 1)) 1))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-substring", "k-limit"], "split": "train"}
{"id": "meta_kg_usage_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: compose existing APIs into one expression.\n\nFilter query 'search to tier=1 skills and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map car (lattice-find-by-tier \"search\" 1 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-tier", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: compose existing APIs into one expression.\n\nFilter query 'vector to tier=0 skills and return ids.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map car (lattice-find-by-tier \"vector\" 0 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-tier", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: compose existing APIs into one expression.\n\nFilter query 'vector to tier=2 skills and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (lattice-find-by-tier \"vector\" 2 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-tier", "edge-case"], "split": "train"}
{"id": "meta_kg_usage_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter query 'crypto to tier=1 skills with k=1.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (lattice-find-by-tier \"crypto\" 1 1))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-tier", "k-limit"], "split": "train"}
{"id": "meta_kg_usage_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter query 'search for purity 'partial and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map car (lattice-find-by-purity \"search\" 'partial 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-purity", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: small integration task across module primitives.\n\nFilter query 'search for purity 'total and return ids.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map car (lattice-find-by-purity \"search\" 'total 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-purity", "direct"], "split": "train"}
{"id": "meta_kg_usage_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter query 'vector for purity 'total and return ids.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (lattice-find-by-purity \"vector\" 'total 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-purity", "integration"], "split": "train"}
{"id": "meta_kg_usage_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "result->skill-name", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `result->skill-name`\nSpec: Resolve the parent skill for a search result tuple based on result type and attached metadata.\n\nWrite exactly one Scheme function definition for `result->skill-name`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n(eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (and\n  (eq? (result->skill-name '(meta 1.0 skill ((tier . 1)))) 'meta)\n  (eq? (result->skill-name '(meta/search 1.0 module ((skill . meta)))) 'meta)\n  (eq? (result->skill-name '(lattice-find 0.8 export ((module . search)))) 'meta)\n  (eq? (result->skill-name '(sha256 0.9 export ((module . sha256)))) 'crypto)\n  (eq? (result->skill-name '(unknown 0.1 export ((module . unknown)))) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "result->skill-name"], "split": "eval"}
{"id": "meta_kg_usage_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-export-source", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-export-source`\nSpec: Find which skill exports a symbol, handling both flat and grouped manifest export layouts.\n\nWrite exactly one Scheme function definition for `lattice-export-source`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(eq? (lattice-export-source 'lattice-find) 'meta)\n(eq? (lattice-export-source 'sha256) 'crypto)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (and\n  (eq? (lattice-export-source 'lattice-find) 'meta)\n  (eq? (lattice-export-source 'sha256) 'crypto)\n  (eq? (lattice-export-source 'sql-run) 'query)\n  (eq? (lattice-export-source 'missing-export) #f)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-export-source"], "split": "eval"}
{"id": "meta_kg_usage_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-tier", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/search.ss\nFunction: `lattice-find-by-tier`\nSpec: Filter skill search results to a specific numeric tier.\n\nWrite exactly one Scheme function definition for `lattice-find-by-tier`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n(equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-tier \"search\" 1 10)) '(meta query))\n  (equal? (map car (lattice-find-by-tier \"vector\" 0 10)) '(linalg))\n  (equal? (map car (lattice-find-by-tier \"vector\" 2 10)) '(graphics))\n  (equal? (map car (lattice-find-by-tier \"crypto\" 1 1)) '(crypto))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "spec-to-code", "lattice-find-by-tier"], "split": "eval"}
{"id": "meta_kg_usage_translation_001", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `concept-boost-for-query`\n\n```python\ndef concept_boost_for_query(query_terms):\n    boost_set = {}\n    for term in query_terms:\n        for skill_name in kg_concept_skills(term):\n            current = boost_set.get(skill_name, 0)\n            boost_set[skill_name] = current + 1\n    return boost_set\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([m (concept-boost-for-query '(search optimization search))]) (and (= (hamt-lookup 'meta m) 2) (= (hamt-lookup 'query m) 3) (= (hamt-lookup 'linalg m) 1) (not (hamt-lookup 'crypto m))))\n(= (hamt-size (concept-boost-for-query '())) 0)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "concept-boost-for-query"], "split": "eval"}
{"id": "meta_kg_usage_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lattice-find-prefix`\n\n```python\ndef lattice_find_prefix(prefix_sym, k=20):\n    prefix = str(prefix_sym).lower()\n    export_matches = []\n    for export_name, _ in kg_exports():\n        name = str(export_name).lower()\n        if len(name) >= len(prefix) and name[: len(prefix)] == prefix:\n            row = [export_name, 0.9, \"export\", {\"name\": export_name}]\n            mod = export_module_map.get(export_name)\n            if mod:\n                row[3][\"module\"] = mod\n            export_matches.append(row)\n    skill_matches = []\n    for skill_name in kg_skills():\n        name = str(skill_name).lower()\n        if len(name) >= len(prefix) and name[: len(prefix)] == prefix:\n            skill_matches.append([skill_name, 0.95, \"skill\", kg_skill_data(skill_name)])\n    merged = sorted(skill_matches + export_matches, key=lambda r: -r[1])\n    return merged[:k]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "python", "lattice-find-prefix"], "split": "eval"}
{"id": "meta_kg_usage_translation_016", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lattice-find-by-purity`\n\n```scheme\n(define (find-by-purity query purity . options)\n  (let* ((k (if (pair? options) (car options) 10))\n         (results (lattice-find query k 'skill)))\n    (filter\n     (lambda (result)\n       (let ((data (cadddr result)))\n         (and data\n              (let ((p (assq 'purity data)))\n                (and p (eq? (cdr p) purity))))))\n     results)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "translation", "chez", "lattice-find-by-purity"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `concept-boost-for-query` in `lattice/meta/search.ss`.\nKnown issue: Repeated concept hits must accumulate counts; overwriting to 1 loses frequency information.\n\n```scheme\n(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (hamt-assoc skill-name 1 bs))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (and\n  (let ([m (concept-boost-for-query '(search optimization search))])\n    (and (= (hamt-lookup 'meta m) 2)\n         (= (hamt-lookup 'query m) 3)\n         (= (hamt-lookup 'linalg m) 1)\n         (not (hamt-lookup 'crypto m))))\n  (= (hamt-size (concept-boost-for-query '())) 0)\n  (let ([m (concept-boost-for-query '(graph graph graph))])\n    (= (hamt-lookup 'graphics m) 3))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "concept-boost-for-query"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-prefix` in `lattice/meta/search.ss`.\nKnown issue: Exact-length prefix matches should be included; use >= length guard, not >.\n\n```scheme\n(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (> (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (> (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n(equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (and\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot))\n  (equal? (map car (lattice-find-prefix 'q 2)) '(query query-run))\n  (equal? (map car (lattice-find-prefix 'm 5)) '(meta))\n  (= (length (lattice-find-prefix 'z 10)) 0)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-prefix"], "split": "eval"}
{"id": "meta_kg_usage_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lattice-find-by-purity` in `lattice/meta/search.ss`.\nKnown issue: Compare against the provided purity argument, not the literal symbol 'purity.\n\n```scheme\n(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) 'purity))))))\n     results)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n(equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (and\n  (equal? (map car (lattice-find-by-purity \"search\" 'partial 10)) '(meta))\n  (equal? (map car (lattice-find-by-purity \"search\" 'total 10)) '(query))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'total 10)) '(linalg))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "bugfix", "lattice-find-by-purity"], "split": "eval"}
{"id": "meta_kg_usage_composition_001", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "concept-boost-for-query", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild concept boost counts for terms '(search optimization search)' and return counts for meta/query/linalg.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (concept-boost-for-query '(search optimization search))]) (list (hamt-lookup 'meta m) (hamt-lookup 'query m) (hamt-lookup 'linalg m))) '(2 3 1))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (concept-boost-for-query '(search optimization search))]) (list (hamt-lookup 'meta m) (hamt-lookup 'query m) (hamt-lookup 'linalg m)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (let ([m (concept-boost-for-query '(search optimization search))]) (list (hamt-lookup 'meta m) (hamt-lookup 'query m) (hamt-lookup 'linalg m))) '(2 3 1)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "concept-boost-for-query", "direct"], "split": "eval"}
{"id": "meta_kg_usage_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "apply-concept-boosts", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply boosts with empty map and return the unchanged result list length.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (length (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.8 skill ((tier . 1)))) hamt-empty)) 2)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(length (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.8 skill ((tier . 1)))) hamt-empty))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (length (apply-concept-boosts (list '(meta 1.0 skill ((tier . 1))) '(query 0.8 skill ((tier . 1)))) hamt-empty)) 2))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "apply-concept-boosts", "edge-case"], "split": "eval"}
{"id": "meta_kg_usage_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-prefix", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun prefix search for 'vec and return the first three ids.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map car (lattice-find-prefix 'vec 3))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-prefix 'vec 3)) '(vec-add vec-sub vec-dot)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-prefix", "direct"], "split": "eval"}
{"id": "meta_kg_usage_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-substring", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify substring search for 'xyz returns empty list.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (null? (lattice-find-substring 'xyz 5)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(null? (lattice-find-substring 'xyz 5))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (null? (lattice-find-substring 'xyz 5)) #t))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-substring", "edge-case"], "split": "eval"}
{"id": "meta_kg_usage_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/search.ss", "source_test": "lattice/meta/test-meta.ss", "source_function": "lattice-find-by-purity", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter query 'vector for purity 'partial and return ids.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map car (lattice-find-by-purity \"vector\" 'partial 10))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (cond\n      [(null? xs) (reverse acc)]\n      [(pred (car xs)) (loop (cdr xs) (cons (car xs) acc))]\n      [else (loop (cdr xs) acc)])))\n  (define (filter-map f lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (let ([v (f (car xs))])\n          (loop (cdr xs) (if v (cons v acc) acc))))))\n  (define (take-at-most n lst)\n  (if (or (<= n 0) (null? lst))\n      '()\n      (cons (car lst) (take-at-most (- n 1) (cdr lst)))))\n  (define (insert-sorted cmp x lst)\n  (cond\n    [(null? lst) (list x)]\n    [(cmp x (car lst)) (cons x lst)]\n    [else (cons (car lst) (insert-sorted cmp x (cdr lst)))]))\n  (define (sort-by cmp lst)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc)) '() lst))\n  (define hamt-empty '())\n  (define (hamt-lookup key m)\n  (let ([p (assq key m)])\n    (if p (cdr p) #f)))\n  (define (hamt-assoc key value m)\n  (let loop ([xs m] [acc '()])\n    (cond\n      [(null? xs) (reverse (cons (cons key value) acc))]\n      [(eq? (caar xs) key)\n       (append (reverse acc) (cons (cons key value) (cdr xs)))]\n      [else (loop (cdr xs) (cons (car xs) acc))])))\n  (define (hamt-size m)\n  (length m))\n  (define (ensure-indexed!) 'ok)\n  (define CONCEPT-BOOST 0.25)\n  (define CONCEPT-BOOST-CAP 2.0)\n  (define *kg-skills-list* '(linalg meta query crypto graphics))\n  (define *kg-skill-data*\n  '((linalg . ((name . linalg)\n               (tier . 0)\n               (purity . total)\n               (exports . ((vec vec-add vec-sub vec-dot)\n                           (matrix matrix-mul matrix-det)))))\n    (meta . ((name . meta)\n             (tier . 1)\n             (purity . partial)\n             (exports . ((search lattice-find lattice-find-prefix lattice-find-substring)\n                         (kg kg-build! kg-skills)))))\n    (query . ((name . query)\n              (tier . 1)\n              (purity . total)\n              (exports . ((query-dsl query-run query-plan)\n                          (sql sql-parse sql-run)))))\n    (crypto . ((name . crypto)\n               (tier . 1)\n               (purity . total)\n               (exports . (sha256 hmac hash-verify))))\n    (graphics . ((name . graphics)\n                 (tier . 2)\n                 (purity . partial)\n                 (exports . ((render draw-line draw-circle)))))))\n  (define *kg-exports-list*\n  '((vec-add . #t)\n    (vec-sub . #t)\n    (vec-dot . #t)\n    (lattice-find . #t)\n    (lattice-find-prefix . #t)\n    (lattice-find-substring . #t)\n    (kg-build! . #t)\n    (kg-skills . #t)\n    (query-run . #t)\n    (query-plan . #t)\n    (sql-run . #t)\n    (sha256 . #t)\n    (hmac . #t)\n    (draw-line . #t)))\n  (define *export-module-map*\n  '((vec-add . vec)\n    (vec-sub . vec)\n    (vec-dot . vec)\n    (lattice-find . search)\n    (lattice-find-prefix . search)\n    (lattice-find-substring . search)\n    (kg-build! . kg)\n    (kg-skills . kg)\n    (query-run . query-dsl)\n    (query-plan . query-dsl)\n    (sql-run . sql)\n    (sha256 . sha256)\n    (hmac . sha256)\n    (draw-line . render)))\n  (define *module-skill-map*\n  '((vec . linalg)\n    (matrix . linalg)\n    (search . meta)\n    (kg . meta)\n    (query-dsl . query)\n    (sql . query)\n    (sha256 . crypto)\n    (render . graphics)))\n  (define *kg-concept-skill-map*\n  '((optimization . (linalg query))\n    (search . (meta query))\n    (crypto . (crypto))\n    (rendering . (graphics))\n    (graph . (meta query graphics))))\n  (define *mock-search-results*\n  '((vector . ((linalg 1.20 skill ((tier . 0) (purity . total)))\n                (vec-add 0.92 export ((module . vec)))\n                (vec-sub 0.89 export ((module . vec)))\n                (graphics 0.31 skill ((tier . 2) (purity . partial)))))\n    (search . ((meta 1.05 skill ((tier . 1) (purity . partial)))\n               (query 0.96 skill ((tier . 1) (purity . total)))\n               (lattice-find 0.88 export ((module . search)))\n               (query-run 0.77 export ((module . query-dsl)))))\n    (crypto . ((crypto 1.07 skill ((tier . 1) (purity . total)))\n               (sha256 0.95 export ((module . sha256)))\n               (hmac 0.82 export ((module . sha256)))))))\n  (define (kg-skills)\n  *kg-skills-list*)\n  (define (kg-skill-data skill-name)\n  (let ([entry (assq skill-name *kg-skill-data*)])\n    (if entry (cdr entry) #f)))\n  (define (kg-exports)\n  *kg-exports-list*)\n  (define (kg-concept-skills concept-name)\n  (let ([entry (assq concept-name *kg-concept-skill-map*)])\n    (if entry (cdr entry) '())))\n  (define (lattice-find query . options)\n  (let* ([k (if (and (pair? options) (number? (car options)))\n                (car options)\n                10)]\n         [type (if (and (pair? options) (pair? (cdr options)))\n                   (cadr options)\n                   'all)]\n         [key (string->symbol (string-downcase query))]\n         [entry (assq key *mock-search-results*)]\n         [base (if entry (cdr entry) '())]\n         [typed (case type\n                  [(skill skills) (filter (lambda (r) (eq? (caddr r) 'skill)) base)]\n                  [(module modules) (filter (lambda (r) (eq? (caddr r) 'module)) base)]\n                  [(export exports) (filter (lambda (r) (eq? (caddr r) 'export)) base)]\n                  [else base])])\n    (take-at-most k typed)))\n  (define (string-contains? haystack needle)\n  (let ([h-len (string-length haystack)]\n        [n-len (string-length needle)])\n    (if (> n-len h-len)\n        #f\n        (let loop ([i 0])\n          (cond\n            [(> (+ i n-len) h-len) #f]\n            [(string=? (substring haystack i (+ i n-len)) needle) #t]\n            [else (loop (+ i 1))])))))\n  (define (concept-boost-for-query query-terms)\n  (fold-left\n   (lambda (boost-set term)\n     (let ([skills (kg-concept-skills term)])\n       (fold-left\n        (lambda (bs skill-name)\n          (let ([current (or (hamt-lookup skill-name bs) 0)])\n            (hamt-assoc skill-name (+ current 1) bs)))\n        boost-set\n        skills)))\n   hamt-empty\n   query-terms))\n  (define (result->skill-name result)\n  (let ([id (car result)]\n        [type (caddr result)]\n        [data (cadddr result)])\n    (case type\n      [(skill) id]\n      [(module)\n       (and data\n            (let ([skill (assq 'skill data)])\n              (and skill (cdr skill))))]\n      [(export)\n       (and data\n            (let ([mod (assq 'module data)])\n              (and mod (hamt-lookup (cdr mod) *module-skill-map*))))]\n      [else #f])))\n  (define (apply-concept-boosts results boost-map)\n  (if (zero? (hamt-size boost-map))\n      results\n      (map (lambda (result)\n             (let* ([skill (result->skill-name result)]\n                    [count (and skill (hamt-lookup skill boost-map))])\n               (if count\n                   (let* ([multiplier (min CONCEPT-BOOST-CAP\n                                           (+ 1.0 (* CONCEPT-BOOST count)))]\n                          [old-score (cadr result)]\n                          [new-score (* old-score multiplier)])\n                     (list (car result) new-score (caddr result) (cadddr result)))\n                   result)))\n           results)))\n  (define (lattice-export-source sym)\n  (let loop ([skills (kg-skills)])\n    (if (null? skills) #f\n        (let* ([skill-name (car skills)]\n               [data (kg-skill-data skill-name)]\n               [exports-raw (if data\n                                (let ([e (assq 'exports data)])\n                                  (if e (cdr e) '()))\n                                '())])\n          (cond\n           [(not (list? exports-raw)) (loop (cdr skills))]\n           [(null? exports-raw) (loop (cdr skills))]\n           [(symbol? (car exports-raw))\n            (if (memq sym exports-raw)\n                skill-name\n                (loop (cdr skills)))]\n           [else\n            (let group-loop ([groups exports-raw])\n              (if (null? groups)\n                  (loop (cdr skills))\n                  (let ([group (car groups)])\n                    (if (and (pair? group) (memq sym group))\n                        skill-name\n                        (group-loop (cdr groups))))))])))))\n  (define (lattice-find-prefix prefix-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [prefix-str (string-downcase (symbol->string prefix-sym))]\n         [prefix-len (string-length prefix-str)])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.9 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (and (>= (string-length name-str) prefix-len)\n                          (string=? (substring name-str 0 prefix-len) prefix-str))\n                     (list skill-name 0.95 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-substring substr-sym . options)\n  (ensure-indexed!)\n  (let* ([k (if (pair? options) (car options) 20)]\n         [substr-str (string-downcase (symbol->string substr-sym))])\n    (let* ([export-matches\n            (filter-map\n             (lambda (export-entry)\n               (let* ([export-name (car export-entry)]\n                      [name-str (string-downcase (symbol->string export-name))])\n                 (if (string-contains? name-str substr-str)\n                     (let ([mod (hamt-lookup export-name *export-module-map*)])\n                       (list export-name 0.8 'export\n                             `((name . ,export-name)\n                               ,@(if mod `((module . ,mod)) '()))))\n                     #f)))\n             (kg-exports))]\n           [skill-matches\n            (filter-map\n             (lambda (skill-name)\n               (let ([name-str (string-downcase (symbol->string skill-name))])\n                 (if (string-contains? name-str substr-str)\n                     (list skill-name 0.85 'skill (kg-skill-data skill-name))\n                     #f)))\n             (kg-skills))]\n           [all-matches (append skill-matches export-matches)]\n           [sorted (sort-by (lambda (a b) (> (cadr a) (cadr b))) all-matches)])\n      (take-at-most k sorted))))\n  (define (lattice-find-by-tier query tier . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([t (assq 'tier data)])\n                (and t (= (cdr t) tier))))))\n     results)))\n  (define (lattice-find-by-purity query purity . options)\n  (let* ([k (if (pair? options) (car options) 10)]\n         [results (lattice-find query k 'skill)])\n    (filter\n     (lambda (result)\n       (let ([data (cadddr result)])\n         (and data\n              (let ([p (assq 'purity data)])\n                (and p (eq? (cdr p) purity))))))\n     results)))\n  (equal? (map car (lattice-find-by-purity \"vector\" 'partial 10)) '(graphics)))", "tags": ["tier1", "meta", "knowledge-graph", "usage", "composition", "lattice-find-by-purity", "integration"], "split": "eval"}
