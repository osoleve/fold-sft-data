{"id": "core_prelude_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `andmap`\nSpec: Apply predicate to all elements; return #t for empty list.\n\nWrite exactly one Scheme function definition for `andmap`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `andmap`\nSpec: Apply predicate to all elements; return #t for empty list.\n\nWrite exactly one Scheme function definition for `andmap`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "spec-to-code", "andmap"], "split": "train"}
{"id": "core_prelude_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (andmap pred lst)\n  ;; TODO: #t iff every element satisfies pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `andmap`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (andmap pred lst)\n  ;; TODO: #t iff every element satisfies pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `andmap`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (andmap number? '()))\n(let () (andmap number? '(1 2 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "andmap"], "split": "train"}
{"id": "core_prelude_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ormap`\nSpec: Apply predicate to list; return first truthy result, or #f if none match.\n\nWrite exactly one Scheme function definition for `ormap`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ormap`\nSpec: Apply predicate to list; return first truthy result, or #f if none match.\n\nWrite exactly one Scheme function definition for `ormap`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (not (ormap number? '())))\n(let () (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "spec-to-code", "ormap"], "split": "train"}
{"id": "core_prelude_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ormap pred lst)\n  ;; TODO: first truthy predicate result, or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ormap`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ormap pred lst)\n  ;; TODO: first truthy predicate result, or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ormap`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "skeleton-completion", "ormap"], "split": "train"}
{"id": "core_prelude_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (filter pred lst)\n  ;; TODO: keep only matching elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (filter pred lst)\n  ;; TODO: keep only matching elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "filter"], "split": "train"}
{"id": "core_prelude_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (filter-map f lst)\n  ;; TODO: map f and keep non-#f results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter-map`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (filter-map f lst)\n  ;; TODO: map f and keep non-#f results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `filter-map`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "filter-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-left`\nSpec: Left-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-left`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-left`\nSpec: Left-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-left`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "spec-to-code", "fold-left"], "split": "train"}
{"id": "core_prelude_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-left f acc lst)\n  ;; TODO: left-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-left`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-left f acc lst)\n  ;; TODO: left-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-left`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "skeleton-completion", "fold-left"], "split": "train"}
{"id": "core_prelude_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-right`\nSpec: Right-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-right`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `fold-right`\nSpec: Right-associative fold over list.\n\nWrite exactly one Scheme function definition for `fold-right`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "spec-to-code", "fold-right"], "split": "train"}
{"id": "core_prelude_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-right f acc lst)\n  ;; TODO: right-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-right`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-right f acc lst)\n  ;; TODO: right-associative fold\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-right`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (fold-right + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "fold-right"], "split": "train"}
{"id": "core_prelude_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `zip`\nSpec: Pair elements from two lists, stopping at shorter list.\n\nWrite exactly one Scheme function definition for `zip`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `zip`\nSpec: Pair elements from two lists, stopping at shorter list.\n\nWrite exactly one Scheme function definition for `zip`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "spec-to-code", "zip"], "split": "train"}
{"id": "core_prelude_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (zip xs ys)\n  ;; TODO: zip into pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `zip`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (zip xs ys)\n  ;; TODO: zip into pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `zip`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "skeleton-completion", "zip"], "split": "train"}
{"id": "core_prelude_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (iota n)\n  ;; TODO: generate 0..n-1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iota`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (iota n)\n  ;; TODO: generate 0..n-1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iota`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "skeleton-completion", "iota"], "split": "train"}
{"id": "core_prelude_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `range`\nSpec: Return list from start (inclusive) to end (exclusive).\n\nWrite exactly one Scheme function definition for `range`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `range`\nSpec: Return list from start (inclusive) to end (exclusive).\n\nWrite exactly one Scheme function definition for `range`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "spec-to-code", "range"], "split": "train"}
{"id": "core_prelude_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (range start end)\n  ;; TODO: generate [start, end)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `range`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (range start end)\n  ;; TODO: generate [start, end)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `range`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "skeleton-completion", "range"], "split": "train"}
{"id": "core_prelude_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `take`\nSpec: Return first n elements from list.\n\nWrite exactly one Scheme function definition for `take`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `take`\nSpec: Return first n elements from list.\n\nWrite exactly one Scheme function definition for `take`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "spec-to-code", "take"], "split": "train"}
{"id": "core_prelude_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (take n lst)\n  ;; TODO: take first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `take`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (take n lst)\n  ;; TODO: take first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `take`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "skeleton-completion", "take"], "split": "train"}
{"id": "core_prelude_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `drop`\nSpec: Drop first n elements from list.\n\nWrite exactly one Scheme function definition for `drop`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `drop`\nSpec: Drop first n elements from list.\n\nWrite exactly one Scheme function definition for `drop`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (drop 3 '(a b c d e)) '(d e)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "spec-to-code", "drop"], "split": "train"}
{"id": "core_prelude_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (drop n lst)\n  ;; TODO: drop first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `drop`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (drop n lst)\n  ;; TODO: drop first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `drop`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (drop 3 '(a b c d e)) '(d e)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "skeleton-completion", "drop"], "split": "train"}
{"id": "core_prelude_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `find`\nSpec: Return first matching element, else #f.\n\nWrite exactly one Scheme function definition for `find`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `find`\nSpec: Return first matching element, else #f.\n\nWrite exactly one Scheme function definition for `find`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (find even? '(1 3 4 6)) 4))\n(let () (not (find even? '(1 3 5))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "spec-to-code", "find"], "split": "train"}
{"id": "core_prelude_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `last`\nSpec: Return final element of non-empty list.\n\nWrite exactly one Scheme function definition for `last`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `last`\nSpec: Return final element of non-empty list.\n\nWrite exactly one Scheme function definition for `last`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "spec-to-code", "last"], "split": "train"}
{"id": "core_prelude_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (last lst)\n  ;; TODO: return last element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `last`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (last lst)\n  ;; TODO: return last element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `last`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "skeleton-completion", "last"], "split": "train"}
{"id": "core_prelude_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (init lst)\n  ;; TODO: all except final element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `init`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (init lst)\n  ;; TODO: all except final element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `init`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "skeleton-completion", "init"], "split": "train"}
{"id": "core_prelude_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (replicate n x)\n  ;; TODO: list of n copies of x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `replicate`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (replicate n x)\n  ;; TODO: list of n copies of x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `replicate`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "skeleton-completion", "replicate"], "split": "train"}
{"id": "core_prelude_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `span`\nSpec: Split list at first element that fails predicate.\n\nWrite exactly one Scheme function definition for `span`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `span`\nSpec: Split list at first element that fails predicate.\n\nWrite exactly one Scheme function definition for `span`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "spec-to-code", "span"], "split": "train"}
{"id": "core_prelude_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span pred lst)\n  ;; TODO: return (values prefix suffix)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span pred lst)\n  ;; TODO: return (values prefix suffix)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "span"], "split": "train"}
{"id": "core_prelude_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (break pred lst)\n  ;; TODO: split at first satisfying element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `break`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (break pred lst)\n  ;; TODO: split at first satisfying element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `break`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "break"], "split": "train"}
{"id": "core_prelude_spec_to_code_035", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `sum`\nSpec: Sum numeric list; return 0 for empty list.\n\nWrite exactly one Scheme function definition for `sum`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `sum`\nSpec: Sum numeric list; return 0 for empty list.\n\nWrite exactly one Scheme function definition for `sum`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "spec-to-code", "sum"], "split": "train"}
{"id": "core_prelude_spec_to_code_036", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sum lst)\n  ;; TODO: sum numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sum`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sum lst)\n  ;; TODO: sum numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sum`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "skeleton-completion", "sum"], "split": "train"}
{"id": "core_prelude_spec_to_code_037", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `product`\nSpec: Multiply numeric list; return 1 for empty list.\n\nWrite exactly one Scheme function definition for `product`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `product`\nSpec: Multiply numeric list; return 1 for empty list.\n\nWrite exactly one Scheme function definition for `product`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "spec-to-code", "product"], "split": "train"}
{"id": "core_prelude_spec_to_code_038", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (product lst)\n  ;; TODO: multiply numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `product`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (product lst)\n  ;; TODO: multiply numeric list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `product`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "skeleton-completion", "product"], "split": "train"}
{"id": "core_prelude_spec_to_code_040", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (mean lst)\n  ;; TODO: arithmetic mean (error on empty)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mean`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (mean lst)\n  ;; TODO: arithmetic mean (error on empty)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mean`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "skeleton-completion", "mean"], "split": "train"}
{"id": "core_prelude_spec_to_code_041", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `identity`\nSpec: Return argument unchanged.\n\nWrite exactly one Scheme function definition for `identity`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `identity`\nSpec: Return argument unchanged.\n\nWrite exactly one Scheme function definition for `identity`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "spec-to-code", "identity"], "split": "train"}
{"id": "core_prelude_spec_to_code_042", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (identity x)\n  ;; TODO: return x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `identity`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (identity x)\n  ;; TODO: return x\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `identity`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (identity 42) 42))\n(let () (equal? (identity '(a b)) '(a b)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "skeleton-completion", "identity"], "split": "train"}
{"id": "core_prelude_spec_to_code_043", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `flatten`\nSpec: Concatenate list of lists.\n\nWrite exactly one Scheme function definition for `flatten`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `flatten`\nSpec: Concatenate list of lists.\n\nWrite exactly one Scheme function definition for `flatten`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "flatten"], "split": "train"}
{"id": "core_prelude_spec_to_code_044", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (flatten lst-of-lists)\n  ;; TODO: flatten list-of-lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `flatten`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (flatten lst-of-lists)\n  ;; TODO: flatten list-of-lists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `flatten`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "skeleton-completion", "flatten"], "split": "train"}
{"id": "core_prelude_spec_to_code_045", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `append-map`\nSpec: Map to lists and concatenate results.\n\nWrite exactly one Scheme function definition for `append-map`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `append-map`\nSpec: Map to lists and concatenate results.\n\nWrite exactly one Scheme function definition for `append-map`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "spec-to-code", "append-map"], "split": "train"}
{"id": "core_prelude_spec_to_code_047", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `partition`\nSpec: Return `(list yes no)` by predicate.\n\nWrite exactly one Scheme function definition for `partition`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `partition`\nSpec: Return `(list yes no)` by predicate.\n\nWrite exactly one Scheme function definition for `partition`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "spec-to-code", "partition"], "split": "train"}
{"id": "core_prelude_spec_to_code_048", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (partition pred lst)\n  ;; TODO: return (list yes no)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition pred lst)\n  ;; TODO: return (list yes no)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "skeleton-completion", "partition"], "split": "train"}
{"id": "core_prelude_spec_to_code_050", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (group-by key-fn lst)\n  ;; TODO: group consecutive elements by key\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `group-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (group-by key-fn lst)\n  ;; TODO: group consecutive elements by key\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `group-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "skeleton-completion", "group-by"], "split": "train"}
{"id": "core_prelude_spec_to_code_051", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "You are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `distinct-by`\nSpec: Remove duplicates by key function, preserving first occurrence.\n\nWrite exactly one Scheme function definition for `distinct-by`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `distinct-by`\nSpec: Remove duplicates by key function, preserving first occurrence.\n\nWrite exactly one Scheme function definition for `distinct-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "spec-to-code", "distinct-by"], "split": "train"}
{"id": "core_prelude_spec_to_code_052", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distinct-by key-fn lst)\n  ;; TODO: remove duplicate keys, keep first\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distinct-by`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distinct-by key-fn lst)\n  ;; TODO: remove duplicate keys, keep first\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distinct-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "skeleton-completion", "distinct-by"], "split": "train"}
{"id": "core_prelude_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `andmap`.\nReturn only the Scheme definition.\n\n```python\ndef andmap(pred, xs):\n    return all(pred(x) for x in xs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `andmap`.\nReturn only the Scheme definition.\n\n```python\ndef andmap(pred, xs):\n    return all(pred(x) for x in xs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "andmap"], "split": "train"}
{"id": "core_prelude_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter`.\nReturn only the Scheme definition.\n\n```python\ndef filter_(pred, xs):\n    return [x for x in xs if pred(x)]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter`.\nReturn only the Scheme definition.\n\n```python\ndef filter_(pred, xs):\n    return [x for x in xs if pred(x)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "filter"], "split": "train"}
{"id": "core_prelude_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter-map`.\nReturn only the Scheme definition.\n\n```python\ndef filter_map(f, xs):\n    out=[]\n    for x in xs:\n        v=f(x)\n        if v is not None:\n            out.append(v)\n    return out\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `filter-map`.\nReturn only the Scheme definition.\n\n```python\ndef filter_map(f, xs):\n    out=[]\n    for x in xs:\n        v=f(x)\n        if v is not None:\n            out.append(v)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "filter-map"], "split": "train"}
{"id": "core_prelude_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-left`.\nReturn only the Scheme definition.\n\n```python\ndef fold_left(f, acc, xs):\n    for x in xs:\n        acc=f(acc,x)\n    return acc\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-left`.\nReturn only the Scheme definition.\n\n```python\ndef fold_left(f, acc, xs):\n    for x in xs:\n        acc=f(acc,x)\n    return acc\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "python-to-scheme", "fold-left"], "split": "train"}
{"id": "core_prelude_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `iota`.\nReturn only the Scheme definition.\n\n```python\ndef iota(n):\n    return list(range(0, n))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `iota`.\nReturn only the Scheme definition.\n\n```python\ndef iota(n):\n    return list(range(0, n))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "python-to-scheme", "iota"], "split": "train"}
{"id": "core_prelude_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `range`.\nReturn only the Scheme definition.\n\n```python\ndef range_(start, end):\n    return list(range(start, end))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `range`.\nReturn only the Scheme definition.\n\n```python\ndef range_(start, end):\n    return list(range(start, end))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "python-to-scheme", "range"], "split": "train"}
{"id": "core_prelude_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `find`.\nReturn only the Scheme definition.\n\n```python\ndef find(pred, xs):\n    for x in xs:\n        if pred(x):\n            return x\n    return None\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `find`.\nReturn only the Scheme definition.\n\n```python\ndef find(pred, xs):\n    for x in xs:\n        if pred(x):\n            return x\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "find"], "split": "train"}
{"id": "core_prelude_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `last`.\nReturn only the Scheme definition.\n\n```python\ndef last(xs):\n    return xs[-1]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `last`.\nReturn only the Scheme definition.\n\n```python\ndef last(xs):\n    return xs[-1]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "python-to-scheme", "last"], "split": "train"}
{"id": "core_prelude_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `init`.\nReturn only the Scheme definition.\n\n```python\ndef init(xs):\n    return xs[:-1]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `init`.\nReturn only the Scheme definition.\n\n```python\ndef init(xs):\n    return xs[:-1]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "python-to-scheme", "init"], "split": "train"}
{"id": "core_prelude_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `replicate`.\nReturn only the Scheme definition.\n\n```python\ndef replicate(n, x):\n    return [x]*max(n,0)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `replicate`.\nReturn only the Scheme definition.\n\n```python\ndef replicate(n, x):\n    return [x]*max(n,0)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n(let () (equal? (replicate 0 'q) '()))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "python-to-scheme", "replicate"], "split": "train"}
{"id": "core_prelude_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span`.\nReturn only the Scheme definition.\n\n```python\ndef span(pred, xs):\n    i=0\n    while i < len(xs) and pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span`.\nReturn only the Scheme definition.\n\n```python\ndef span(pred, xs):\n    i=0\n    while i < len(xs) and pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "span"], "split": "train"}
{"id": "core_prelude_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `break`.\nReturn only the Scheme definition.\n\n```python\ndef break_(pred, xs):\n    i=0\n    while i < len(xs) and not pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `break`.\nReturn only the Scheme definition.\n\n```python\ndef break_(pred, xs):\n    i=0\n    while i < len(xs) and not pred(xs[i]):\n        i+=1\n    return xs[:i], xs[i:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "break"], "split": "train"}
{"id": "core_prelude_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `sum`.\nReturn only the Scheme definition.\n\n```python\ndef sum_(xs):\n    return sum(xs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `sum`.\nReturn only the Scheme definition.\n\n```python\ndef sum_(xs):\n    return sum(xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (sum '()) 0))\n(let () (= (sum '(1 2 3 4)) 10))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "python-to-scheme", "sum"], "split": "train"}
{"id": "core_prelude_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mean`.\nReturn only the Scheme definition.\n\n```python\ndef mean(xs):\n    if len(xs)==0:\n        raise ValueError('empty list')\n    return sum(xs)/len(xs)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mean`.\nReturn only the Scheme definition.\n\n```python\ndef mean(xs):\n    if len(xs)==0:\n        raise ValueError('empty list')\n    return sum(xs)/len(xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "python-to-scheme", "mean"], "split": "train"}
{"id": "core_prelude_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `identity`.\nReturn only the Scheme definition.\n\n```python\ndef identity(x):\n    return x\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `identity`.\nReturn only the Scheme definition.\n\n```python\ndef identity(x):\n    return x\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (identity 42) 42))\n(let () (equal? (identity '(a b)) '(a b)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "python-to-scheme", "identity"], "split": "train"}
{"id": "core_prelude_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `flatten`.\nReturn only the Scheme definition.\n\n```python\ndef flatten(xss):\n    return [x for xs in xss for x in xs]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `flatten`.\nReturn only the Scheme definition.\n\n```python\ndef flatten(xss):\n    return [x for xs in xss for x in xs]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "python-to-scheme", "flatten"], "split": "train"}
{"id": "core_prelude_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `append-map`.\nReturn only the Scheme definition.\n\n```python\ndef append_map(f, xs):\n    out=[]\n    for x in xs:\n        out.extend(f(x))\n    return out\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `append-map`.\nReturn only the Scheme definition.\n\n```python\ndef append_map(f, xs):\n    out=[]\n    for x in xs:\n        out.extend(f(x))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "python-to-scheme", "append-map"], "split": "train"}
{"id": "core_prelude_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(pred, xs):\n    yes=[]; no=[]\n    for x in xs:\n        (yes if pred(x) else no).append(x)\n    return [yes,no]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(pred, xs):\n    yes=[]; no=[]\n    for x in xs:\n        (yes if pred(x) else no).append(x)\n    return [yes,no]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "python-to-scheme", "partition"], "split": "train"}
{"id": "core_prelude_translation_025", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `group-by`.\nReturn only the Scheme definition.\n\n```python\ndef group_by(key_fn, xs):\n    if not xs:\n        return []\n    out=[]\n    cur_k=key_fn(xs[0]); cur=[]\n    for x in xs:\n        k=key_fn(x)\n        if k==cur_k:\n            cur.append(x)\n        else:\n            out.append((cur_k,cur)); cur_k=k; cur=[x]\n    out.append((cur_k,cur))\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `group-by`.\nReturn only the Scheme definition.\n\n```python\ndef group_by(key_fn, xs):\n    if not xs:\n        return []\n    out=[]\n    cur_k=key_fn(xs[0]); cur=[]\n    for x in xs:\n        k=key_fn(x)\n        if k==cur_k:\n            cur.append(x)\n        else:\n            out.append((cur_k,cur)); cur_k=k; cur=[x]\n    out.append((cur_k,cur))\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "python-to-scheme", "group-by"], "split": "train"}
{"id": "core_prelude_translation_026", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `distinct-by`.\nReturn only the Scheme definition.\n\n```python\ndef distinct_by(key_fn, xs):\n    seen=[]; out=[]\n    for x in xs:\n        k=key_fn(x)\n        if k not in seen:\n            seen.append(k); out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `distinct-by`.\nReturn only the Scheme definition.\n\n```python\ndef distinct_by(key_fn, xs):\n    seen=[]; out=[]\n    for x in xs:\n        k=key_fn(x)\n        if k not in seen:\n            seen.append(k); out.append(x)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "python-to-scheme", "distinct-by"], "split": "train"}
{"id": "core_prelude_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ormap` in `core/base/prelude.ss`.\nKnown issue: Should return first truthy predicate result; empty list should return #f.\n\n```scheme\n(define (ormap pred lst)\n  (or (null? lst)\n      (and (pred (car lst)) (ormap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ormap` in `core/base/prelude.ss`.\nKnown issue: Should return first truthy predicate result; empty list should return #f.\n\n```scheme\n(define (ormap pred lst)\n  (or (null? lst)\n      (and (pred (car lst)) (ormap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Should return first truthy predicate result; empty list should return #f.\n\nExpected behavior after patch:\n```scheme\n(let () (not (ormap number? '())))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (not (ormap number? '())))\n(let () (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "bugfix", "ormap"], "split": "train"}
{"id": "core_prelude_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter` in `core/base/prelude.ss`.\nKnown issue: Predicate logic is inverted.\n\n```scheme\n(define (filter pred lst)\n  (cond [(null? lst) '()]\n        [(pred (car lst)) (filter pred (cdr lst))]\n        [else (cons (car lst) (filter pred (cdr lst)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter` in `core/base/prelude.ss`.\nKnown issue: Predicate logic is inverted.\n\n```scheme\n(define (filter pred lst)\n  (cond [(null? lst) '()]\n        [(pred (car lst)) (filter pred (cdr lst))]\n        [else (cons (car lst) (filter pred (cdr lst)))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Predicate logic is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (filter even? '(1 2 3 4 5)) '(2 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "bugfix", "filter"], "split": "train"}
{"id": "core_prelude_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter-map` in `core/base/prelude.ss`.\nKnown issue: Must remove #f results.\n\n```scheme\n(define (filter-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `filter-map` in `core/base/prelude.ss`.\nKnown issue: Must remove #f results.\n\n```scheme\n(define (filter-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "bugfix", "filter-map"], "split": "train"}
{"id": "core_prelude_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-left` in `core/base/prelude.ss`.\nKnown issue: This is right-associative, not left-associative.\n\n```scheme\n(define (fold-left f acc lst)\n  (if (null? lst) acc (f (car lst) (fold-left f acc (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-left` in `core/base/prelude.ss`.\nKnown issue: This is right-associative, not left-associative.\n\n```scheme\n(define (fold-left f acc lst)\n  (if (null? lst) acc (f (car lst) (fold-left f acc (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: This is right-associative, not left-associative.\n\nExpected behavior after patch:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (fold-left + 0 '(1 2 3 4)) 10))\n(let () (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (and (= (fold-left + 0 '(1 2 3 4)) 10) (equal? (fold-left (lambda (acc x) (list acc x)) 0 '(1 2)) '((0 1) 2))))", "tags": ["core", "base", "prelude", "bugfix", "fold-left"], "split": "train"}
{"id": "core_prelude_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `zip` in `core/base/prelude.ss`.\nKnown issue: Expected pairs `(a . b)`, not two-element lists.\n\n```scheme\n(define (zip xs ys)\n  (map list xs ys))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `zip` in `core/base/prelude.ss`.\nKnown issue: Expected pairs `(a . b)`, not two-element lists.\n\n```scheme\n(define (zip xs ys)\n  (map list xs ys))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "bugfix", "zip"], "split": "train"}
{"id": "core_prelude_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/prelude.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()]) (if (> i n) (reverse acc) (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/prelude.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()]) (if (> i n) (reverse acc) (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "bugfix", "iota"], "split": "train"}
{"id": "core_prelude_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `range` in `core/base/prelude.ss`.\nKnown issue: End should be exclusive.\n\n```scheme\n(define (range start end)\n  (if (> start end) '() (cons start (range (+ start 1) end))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `range` in `core/base/prelude.ss`.\nKnown issue: End should be exclusive.\n\n```scheme\n(define (range start end)\n  (if (> start end) '() (cons start (range (+ start 1) end))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (range 2 2) '()))\n(let () (equal? (range 2 6) '(2 3 4 5)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (range start end)\n  (let loop ([i start] [acc '()])\n    (if (>= i end)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (range 2 2) '()) (equal? (range 2 6) '(2 3 4 5))))", "tags": ["core", "base", "prelude", "bugfix", "range"], "split": "train"}
{"id": "core_prelude_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `take` in `core/base/prelude.ss`.\nKnown issue: When n is 0, result must be empty.\n\n```scheme\n(define (take n lst)\n  (if (or (< n 0) (null? lst)) '() (cons (car lst) (take (- n 1) (cdr lst)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `take` in `core/base/prelude.ss`.\nKnown issue: When n is 0, result must be empty.\n\n```scheme\n(define (take n lst)\n  (if (or (< n 0) (null? lst)) '() (cons (car lst) (take (- n 1) (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: When n is 0, result must be empty.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (take 3 '(a b c d e)) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "bugfix", "take"], "split": "train"}
{"id": "core_prelude_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find` in `core/base/prelude.ss`.\nKnown issue: Find returns matching element, not boolean.\n\n```scheme\n(define (find pred lst)\n  (ormap pred lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find` in `core/base/prelude.ss`.\nKnown issue: Find returns matching element, not boolean.\n\n```scheme\n(define (find pred lst)\n  (ormap pred lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (find even? '(1 3 4 6)) 4))\n(let () (not (find even? '(1 3 5))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "bugfix", "find"], "split": "train"}
{"id": "core_prelude_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `last` in `core/base/prelude.ss`.\nKnown issue: Must return final element.\n\n```scheme\n(define (last lst)\n  (car lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `last` in `core/base/prelude.ss`.\nKnown issue: Must return final element.\n\n```scheme\n(define (last lst)\n  (car lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must return final element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (last '(x y z)) 'z))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))", "verify_expr": "(let ()\n  (define (last lst)\n  (if (null? (cdr lst))\n      (car lst)\n      (last (cdr lst))))\n  (equal? (last '(x y z)) 'z))", "tags": ["core", "base", "prelude", "bugfix", "last"], "split": "train"}
{"id": "core_prelude_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `init` in `core/base/prelude.ss`.\nKnown issue: Must remove final element.\n\n```scheme\n(define (init lst)\n  lst)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `init` in `core/base/prelude.ss`.\nKnown issue: Must remove final element.\n\n```scheme\n(define (init lst)\n  lst)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must remove final element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (init '(x y z)) '(x y)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "bugfix", "init"], "split": "train"}
{"id": "core_prelude_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `replicate` in `core/base/prelude.ss`.\nKnown issue: For n=0 result should be empty, not one element.\n\n```scheme\n(define (replicate n x)\n  (if (< n 0) '() (cons x (replicate (- n 1) x))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `replicate` in `core/base/prelude.ss`.\nKnown issue: For n=0 result should be empty, not one element.\n\n```scheme\n(define (replicate n x)\n  (if (< n 0) '() (cons x (replicate (- n 1) x))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: For n=0 result should be empty, not one element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (replicate 3 'q) '(q q q)))\n(let () (equal? (replicate 0 'q) '()))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "bugfix", "replicate"], "split": "train"}
{"id": "core_prelude_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `break` in `core/base/prelude.ss`.\nKnown issue: Break should negate predicate before delegating to span.\n\n```scheme\n(define (break pred lst)\n  (span pred lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `break` in `core/base/prelude.ss`.\nKnown issue: Break should negate predicate before delegating to span.\n\n```scheme\n(define (break pred lst)\n  (span pred lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Break should negate predicate before delegating to span.\n\nExpected behavior after patch:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "bugfix", "break"], "split": "train"}
{"id": "core_prelude_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sum` in `core/base/prelude.ss`.\nKnown issue: Sum should add, not multiply.\n\n```scheme\n(define (sum lst)\n  (fold-left * 1 lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sum` in `core/base/prelude.ss`.\nKnown issue: Sum should add, not multiply.\n\n```scheme\n(define (sum lst)\n  (fold-left * 1 lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Sum should add, not multiply.\n\nExpected behavior after patch:\n```scheme\n(let () (= (sum '()) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sum lst)\n  (fold-left + 0 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (and (= (sum '()) 0) (= (sum '(1 2 3 4)) 10)))", "tags": ["core", "base", "prelude", "bugfix", "sum"], "split": "train"}
{"id": "core_prelude_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `product` in `core/base/prelude.ss`.\nKnown issue: Product should multiply, not add.\n\n```scheme\n(define (product lst)\n  (fold-left + 0 lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `product` in `core/base/prelude.ss`.\nKnown issue: Product should multiply, not add.\n\n```scheme\n(define (product lst)\n  (fold-left + 0 lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (product '()) 1))\n(let () (= (product '(2 3 4)) 24))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "bugfix", "product"], "split": "train"}
{"id": "core_prelude_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mean` in `core/base/prelude.ss`.\nKnown issue: Must error on empty list.\n\n```scheme\n(define (mean lst)\n  (/ (sum lst) (length lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mean` in `core/base/prelude.ss`.\nKnown issue: Must error on empty list.\n\n```scheme\n(define (mean lst)\n  (/ (sum lst) (length lst)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must error on empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (mean '(2 4 6 8)) 5))\n(let () (guard (ex [else #t]) (begin (mean '()) #f)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "bugfix", "mean"], "split": "train"}
{"id": "core_prelude_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `flatten` in `core/base/prelude.ss`.\nKnown issue: Must concatenate all inner lists.\n\n```scheme\n(define (flatten lst-of-lists)\n  (if (null? lst-of-lists) '() (car lst-of-lists)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `flatten` in `core/base/prelude.ss`.\nKnown issue: Must concatenate all inner lists.\n\n```scheme\n(define (flatten lst-of-lists)\n  (if (null? lst-of-lists) '() (car lst-of-lists)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must concatenate all inner lists.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (flatten lst-of-lists)\n  (fold-right append '() lst-of-lists))\n  (equal? (flatten '((1 2) () (3 4))) '(1 2 3 4)))", "tags": ["core", "base", "prelude", "bugfix", "flatten"], "split": "train"}
{"id": "core_prelude_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `append-map` in `core/base/prelude.ss`.\nKnown issue: Must append mapped lists into one list.\n\n```scheme\n(define (append-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `append-map` in `core/base/prelude.ss`.\nKnown issue: Must append mapped lists into one list.\n\n```scheme\n(define (append-map f lst)\n  (map f lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must append mapped lists into one list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "bugfix", "append-map"], "split": "train"}
{"id": "core_prelude_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `core/base/prelude.ss`.\nKnown issue: Output order is `(yes no)`.\n\n```scheme\n(define (partition pred lst)\n  (list (filter (lambda (x) (not (pred x))) lst) (filter pred lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `core/base/prelude.ss`.\nKnown issue: Output order is `(yes no)`.\n\n```scheme\n(define (partition pred lst)\n  (list (filter (lambda (x) (not (pred x))) lst) (filter pred lst)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Output order is `(yes no)`.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))", "verify_expr": "(let ()\n  (define (partition pred lst)\n  (let loop ([lst lst] [yes '()] [no '()])\n    (cond\n      [(null? lst) (list (reverse yes) (reverse no))]\n      [(pred (car lst)) (loop (cdr lst) (cons (car lst) yes) no)]\n      [else (loop (cdr lst) yes (cons (car lst) no))])))\n  (equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5))))", "tags": ["core", "base", "prelude", "bugfix", "partition"], "split": "train"}
{"id": "core_prelude_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `core/base/prelude.ss`.\nKnown issue: Must produce grouped key/list pairs.\n\n```scheme\n(define (group-by key-fn lst)\n  '())\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `core/base/prelude.ss`.\nKnown issue: Must produce grouped key/list pairs.\n\n```scheme\n(define (group-by key-fn lst)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "bugfix", "group-by"], "split": "train"}
{"id": "core_prelude_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt_body": "Return whether any element in `(\"a\" 2 \"c\")` is a number.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether any element in `(\"a\" 2 \"c\")` is a number.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(ormap number? '(\"a\" 2 \"c\"))", "verify_expr": "(equal? (ormap number? '(\"a\" 2 \"c\")) #t)", "tags": ["core", "base", "prelude", "composition", "ormap", "direct"], "split": "train"}
{"id": "core_prelude_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt_body": "Keep evens from `(1 2 3 4 5 6)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nKeep evens from `(1 2 3 4 5 6)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(filter even? '(1 2 3 4 5 6))", "verify_expr": "(equal? (filter even? '(1 2 3 4 5 6)) '(2 4 6))", "tags": ["core", "base", "prelude", "composition", "filter", "direct"], "split": "train"}
{"id": "core_prelude_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt_body": "Double positive numbers and drop others from `(-1 0 2 3)`.", "prompt": "Task mode: small integration task across module primitives.\n\nDouble positive numbers and drop others from `(-1 0 2 3)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-1 0 2 3))", "verify_expr": "(equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-1 0 2 3)) '(4 6))", "tags": ["core", "base", "prelude", "composition", "filter-map", "direct"], "split": "train"}
{"id": "core_prelude_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt_body": "Build nested pair form with fold-right over `(1 2)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild nested pair form with fold-right over `(1 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-right (lambda (x acc) (list x acc)) 0 '(1 2))", "verify_expr": "(equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))", "tags": ["core", "base", "prelude", "composition", "fold-right", "direct"], "split": "train"}
{"id": "core_prelude_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt_body": "Zip `(1 2 3)` and `(a b)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nZip `(1 2 3)` and `(a b)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(zip '(1 2 3) '(a b))", "verify_expr": "(equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b)))", "tags": ["core", "base", "prelude", "composition", "zip", "direct"], "split": "train"}
{"id": "core_prelude_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt_body": "Generate `iota` for 5.", "prompt": "Task mode: compose existing APIs into one expression.\n\nGenerate `iota` for 5.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(iota 5)", "verify_expr": "(equal? (iota 5) '(0 1 2 3 4))", "tags": ["core", "base", "prelude", "composition", "iota", "direct"], "split": "train"}
{"id": "core_prelude_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt_body": "Take 3 elements from `(a b c d e)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTake 3 elements from `(a b c d e)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(take 3 '(a b c d e))", "verify_expr": "(equal? (take 3 '(a b c d e)) '(a b c))", "tags": ["core", "base", "prelude", "composition", "take", "direct"], "split": "train"}
{"id": "core_prelude_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt_body": "Drop 3 elements from `(a b c d e)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDrop 3 elements from `(a b c d e)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(drop 3 '(a b c d e))", "verify_expr": "(equal? (drop 3 '(a b c d e)) '(d e))", "tags": ["core", "base", "prelude", "composition", "drop", "direct"], "split": "train"}
{"id": "core_prelude_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt_body": "Find first even value in `(1 3 4 6)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFind first even value in `(1 3 4 6)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(find even? '(1 3 4 6))", "verify_expr": "(equal? (find even? '(1 3 4 6)) 4)", "tags": ["core", "base", "prelude", "composition", "find", "direct"], "split": "train"}
{"id": "core_prelude_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt_body": "Return init of `(x y z)`.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn init of `(x y z)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(init '(x y z))", "verify_expr": "(equal? (init '(x y z)) '(x y))", "tags": ["core", "base", "prelude", "composition", "init", "direct"], "split": "train"}
{"id": "core_prelude_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt_body": "Replicate symbol `q` three times.", "prompt": "Task mode: small integration task across module primitives.\n\nReplicate symbol `q` three times.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(replicate 3 'q)", "verify_expr": "(equal? (replicate 3 'q) '(q q q))", "tags": ["core", "base", "prelude", "composition", "replicate", "direct"], "split": "train"}
{"id": "core_prelude_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt_body": "Split `(1 2 3 4)` with predicate `<3` using span.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSplit `(1 2 3 4)` with predicate `<3` using span.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (list pre suf))", "verify_expr": "(equal? (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (list pre suf)) '((1 2) (3 4)))", "tags": ["core", "base", "prelude", "composition", "span", "direct"], "split": "train"}
{"id": "core_prelude_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Split `(1 3 5 2 4)` at first even using break.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSplit `(1 3 5 2 4)` at first even using break.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (list pre suf))", "verify_expr": "(equal? (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (list pre suf)) '((1 3 5) (2 4)))", "tags": ["core", "base", "prelude", "composition", "break", "direct"], "split": "train"}
{"id": "core_prelude_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt_body": "Product of `(2 3 4)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nProduct of `(2 3 4)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(product '(2 3 4))", "verify_expr": "(equal? (product '(2 3 4)) 24)", "tags": ["core", "base", "prelude", "composition", "product", "direct"], "split": "train"}
{"id": "core_prelude_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt_body": "Mean of `(2 4 6 8)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMean of `(2 4 6 8)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mean '(2 4 6 8))", "verify_expr": "(equal? (mean '(2 4 6 8)) 5)", "tags": ["core", "base", "prelude", "composition", "mean", "direct"], "split": "train"}
{"id": "core_prelude_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt_body": "Apply identity to list `(a b)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply identity to list `(a b)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(identity '(a b))", "verify_expr": "(equal? (identity '(a b)) '(a b))", "tags": ["core", "base", "prelude", "composition", "identity", "direct"], "split": "train"}
{"id": "core_prelude_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt_body": "Duplicate each element with append-map over `(1 2 3)`.", "prompt": "Task mode: small integration task across module primitives.\n\nDuplicate each element with append-map over `(1 2 3)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(append-map (lambda (x) (list x x)) '(1 2 3))", "verify_expr": "(equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3))", "tags": ["core", "base", "prelude", "composition", "append-map", "direct"], "split": "train"}
{"id": "core_prelude_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt_body": "Partition `(1 2 3 4 5)` by even?.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition `(1 2 3 4 5)` by even?.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition even? '(1 2 3 4 5))", "verify_expr": "(equal? (partition even? '(1 2 3 4 5)) '((2 4) (1 3 5)))", "tags": ["core", "base", "prelude", "composition", "partition", "direct"], "split": "train"}
{"id": "core_prelude_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt_body": "Group strings by length in `(\"a\" \"b\" \"cc\" \"dd\")`.", "prompt": "Task mode: small integration task across module primitives.\n\nGroup strings by length in `(\"a\" \"b\" \"cc\" \"dd\")`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(group-by string-length '(\"a\" \"b\" \"cc\" \"dd\"))", "verify_expr": "(equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\")))", "tags": ["core", "base", "prelude", "composition", "group-by", "direct"], "split": "train"}
{"id": "core_prelude_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt_body": "Return #t iff `sum (iota 6)` equals 15.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff `sum (iota 6)` equals 15.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (sum (iota 6)) 15)", "verify_expr": "(equal? (= (sum (iota 6)) 15) #t)", "tags": ["core", "base", "prelude", "composition", "sum", "integration"], "split": "train"}
{"id": "core_prelude_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt_body": "Build reversed list via fold-left and cons.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild reversed list via fold-left and cons.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(fold-left (lambda (acc x) (cons x acc)) '() '(1 2 3 4))", "verify_expr": "(equal? (fold-left (lambda (acc x) (cons x acc)) '() '(1 2 3 4)) '(4 3 2 1))", "tags": ["core", "base", "prelude", "composition", "fold-left", "integration"], "split": "train"}
{"id": "core_prelude_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt_body": "Return #t iff `break` is the opposite split of `span` for predicate even? on `(1 3 5 2 4)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff `break` is the opposite split of `span` for predicate even? on `(1 3 5 2 4)`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let-values ([(a b) (break even? '(1 3 5 2 4))]) (and (equal? a '(1 3 5)) (equal? b '(2 4))))", "verify_expr": "(equal? (let-values ([(a b) (break even? '(1 3 5 2 4))]) (and (equal? a '(1 3 5)) (equal? b '(2 4)))) #t)", "tags": ["core", "base", "prelude", "composition", "break", "property"], "split": "train"}
