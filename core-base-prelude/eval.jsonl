{"id": "core_prelude_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter`\nSpec: Return only elements satisfying predicate.\n\nWrite exactly one Scheme function definition for `filter`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (filter even? '(1 2 3 4 5)) '(2 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (equal? (filter even? '(1 2 3 4 5)) '(2 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "filter"], "split": "eval"}
{"id": "core_prelude_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "filter-map", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `filter-map`\nSpec: Map function and keep only non-#f results.\n\nWrite exactly one Scheme function definition for `filter-map`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))", "verify_expr": "(let ()\n  (define (filter-map f lst)\n  (let loop ([lst lst] [acc '()])\n    (if (null? lst)\n        (reverse acc)\n        (let ([result (f (car lst))])\n          (if result\n              (loop (cdr lst) (cons result acc))\n              (loop (cdr lst) acc))))))\n  (equal? (filter-map (lambda (x) (if (> x 0) (* 2 x) #f)) '(-2 -1 0 1 2)) '(2 4)))", "tags": ["core", "base", "prelude", "spec-to-code", "filter-map"], "split": "eval"}
{"id": "core_prelude_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "iota", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `iota`\nSpec: Return list `(0 ... n-1)`.\n\nWrite exactly one Scheme function definition for `iota`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n    (if (= i n)\n        (reverse acc)\n        (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "prelude", "spec-to-code", "iota"], "split": "eval"}
{"id": "core_prelude_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "find", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (find pred lst)\n  ;; TODO: return first match or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `find`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (find even? '(1 3 4 6)) 4)\n(not (find even? '(1 3 5)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))", "verify_expr": "(let ()\n  (define (find pred lst)\n  (cond\n    [(null? lst) #f]\n    [(pred (car lst)) (car lst)]\n    [else (find pred (cdr lst))]))\n  (and (equal? (find even? '(1 3 4 6)) 4) (not (find even? '(1 3 5)))))", "tags": ["core", "base", "prelude", "skeleton-completion", "find"], "split": "eval"}
{"id": "core_prelude_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "init", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `init`\nSpec: Return all elements except last.\n\nWrite exactly one Scheme function definition for `init`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (init '(x y z)) '(x y))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))", "verify_expr": "(let ()\n  (define (init lst)\n  (if (null? (cdr lst))\n      '()\n      (cons (car lst) (init (cdr lst)))))\n  (equal? (init '(x y z)) '(x y)))", "tags": ["core", "base", "prelude", "spec-to-code", "init"], "split": "eval"}
{"id": "core_prelude_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "replicate", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `replicate`\nSpec: Return list containing n copies of value.\n\nWrite exactly one Scheme function definition for `replicate`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (replicate 3 'q) '(q q q))\n(equal? (replicate 0 'q) '())\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))", "verify_expr": "(let ()\n  (define (replicate n x)\n  (if (<= n 0)\n      '()\n      (cons x (replicate (- n 1) x))))\n  (and (equal? (replicate 3 'q) '(q q q)) (equal? (replicate 0 'q) '())))", "tags": ["core", "base", "prelude", "spec-to-code", "replicate"], "split": "eval"}
{"id": "core_prelude_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "break", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `break`\nSpec: Split list at first element that satisfies predicate.\n\nWrite exactly one Scheme function definition for `break`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (define (break pred lst)\n  (span (lambda (x) (not (pred x))) lst))\n  (let-values ([(pre suf) (break even? '(1 3 5 2 4))]) (and (equal? pre '(1 3 5)) (equal? suf '(2 4)))))", "tags": ["core", "base", "prelude", "spec-to-code", "break"], "split": "eval"}
{"id": "core_prelude_spec_to_code_039", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "mean", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `mean`\nSpec: Arithmetic mean; raise error on empty list.\n\nWrite exactly one Scheme function definition for `mean`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (mean '(2 4 6 8)) 5)\n(guard (ex [else #t]) (begin (mean '()) #f))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (sum lst)\n  (fold-left + 0 lst))\n  (define (mean lst)\n  (if (null? lst)\n      (error 'mean \"empty list\")\n      (/ (sum lst) (length lst))))\n  (and (equal? (mean '(2 4 6 8)) 5) (guard (ex [else #t]) (begin (mean '()) #f))))", "tags": ["core", "base", "prelude", "spec-to-code", "mean"], "split": "eval"}
{"id": "core_prelude_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "append-map", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (append-map f lst)\n  ;; TODO: map to lists then append\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `append-map`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (define (append-map f lst)\n  (fold-right (lambda (x acc) (append (f x) acc)) '() lst))\n  (equal? (append-map (lambda (x) (list x x)) '(1 2 3)) '(1 1 2 2 3 3)))", "tags": ["core", "base", "prelude", "skeleton-completion", "append-map"], "split": "eval"}
{"id": "core_prelude_spec_to_code_049", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "group-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `group-by`\nSpec: Group consecutive elements by key function result.\n\nWrite exactly one Scheme function definition for `group-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))", "verify_expr": "(let ()\n  (define (group-by key-fn lst)\n  (if (null? lst)\n      '()\n      (let ([first-key (key-fn (car lst))])\n        (let loop ([remaining lst] [current-key first-key] [current-group '()] [result '()])\n          (cond\n            [(null? remaining)\n             (reverse (cons (cons current-key (reverse current-group)) result))]\n            [(equal? (key-fn (car remaining)) current-key)\n             (loop (cdr remaining) current-key (cons (car remaining) current-group) result)]\n            [else\n             (let ([new-key (key-fn (car remaining))])\n               (loop (cdr remaining) new-key (list (car remaining))\n                     (cons (cons current-key (reverse current-group)) result)))])))))\n  (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\")) '((1 \"a\" \"b\") (2 \"cc\" \"dd\"))))", "tags": ["core", "base", "prelude", "spec-to-code", "group-by"], "split": "eval"}
{"id": "core_prelude_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ormap", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ormap`.\nReturn only the Scheme definition.\n\n```python\ndef ormap(pred, xs):\n    for x in xs:\n        v = pred(x)\n        if v:\n            return v\n    return False\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (ormap pred lst)\n  (and (pair? lst)\n       (or (pred (car lst))\n           (ormap pred (cdr lst)))))\n  (and (not (ormap number? '())) (equal? (ormap (lambda (x) (and (number? x) x)) '(\"a\" 2 \"c\")) 2) (not (ormap number? '(\"a\" \"b\")))))", "tags": ["core", "base", "prelude", "python-to-scheme", "ormap"], "split": "eval"}
{"id": "core_prelude_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `fold-right`.\nReturn only the Scheme definition.\n\n```python\ndef fold_right(f, acc, xs):\n    for x in reversed(xs):\n        acc=f(x,acc)\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (fold-right + 0 '(1 2 3 4)) 10)\n(equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "python-to-scheme", "fold-right"], "split": "eval"}
{"id": "core_prelude_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "zip", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `zip`.\nReturn only the Scheme definition.\n\n```python\ndef zip_(xs, ys):\n    return list(zip(xs, ys))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))", "verify_expr": "(let ()\n  (define (zip xs ys)\n  (if (or (null? xs) (null? ys))\n      '()\n      (cons (cons (car xs) (car ys))\n            (zip (cdr xs) (cdr ys)))))\n  (equal? (zip '(1 2 3) '(a b)) '((1 . a) (2 . b))))", "tags": ["core", "base", "prelude", "python-to-scheme", "zip"], "split": "eval"}
{"id": "core_prelude_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "take", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `take`.\nReturn only the Scheme definition.\n\n```python\ndef take(n, xs):\n    return xs[:n]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (take 3 '(a b c d e)) '(a b c))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))", "verify_expr": "(let ()\n  (define (take n lst)\n  (if (or (= n 0) (null? lst))\n      '()\n      (cons (car lst) (take (- n 1) (cdr lst)))))\n  (equal? (take 3 '(a b c d e)) '(a b c)))", "tags": ["core", "base", "prelude", "python-to-scheme", "take"], "split": "eval"}
{"id": "core_prelude_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `drop`.\nReturn only the Scheme definition.\n\n```python\ndef drop(n, xs):\n    return xs[n:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "python-to-scheme", "drop"], "split": "eval"}
{"id": "core_prelude_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "product", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `product`.\nReturn only the Scheme definition.\n\n```python\ndef product(xs):\n    out=1\n    for x in xs:\n        out*=x\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (product lst)\n  (fold-left * 1 lst))", "verify_expr": "(let ()\n  (define (fold-left f acc lst)\n  (if (null? lst)\n      acc\n      (fold-left f (f acc (car lst)) (cdr lst))))\n  (define (product lst)\n  (fold-left * 1 lst))\n  (and (= (product '()) 1) (= (product '(2 3 4)) 24)))", "tags": ["core", "base", "prelude", "python-to-scheme", "product"], "split": "eval"}
{"id": "core_prelude_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `andmap` in `core/base/prelude.ss`.\nKnown issue: All elements must satisfy predicate, not just one.\n\n```scheme\n(define (andmap pred lst)\n  (or (null? lst)\n      (or (pred (car lst)) (andmap pred (cdr lst)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(andmap number? '())\n(andmap number? '(1 2 3))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))", "verify_expr": "(let ()\n  (define (andmap pred lst)\n  (or (null? lst)\n      (and (pred (car lst))\n           (andmap pred (cdr lst)))))\n  (and (andmap number? '()) (andmap number? '(1 2 3)) (not (andmap number? '(1 \"x\" 3)))))", "tags": ["core", "base", "prelude", "bugfix", "andmap"], "split": "eval"}
{"id": "core_prelude_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-right", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-right` in `core/base/prelude.ss`.\nKnown issue: This behaves like fold-left.\n\n```scheme\n(define (fold-right f acc lst)\n  (if (null? lst) acc (fold-right f (f (car lst) acc) (cdr lst))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (fold-right + 0 '(1 2 3 4)) 10)\n(equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))", "verify_expr": "(let ()\n  (define (fold-right f acc lst)\n  (if (null? lst)\n      acc\n      (f (car lst) (fold-right f acc (cdr lst)))))\n  (and (= (fold-right + 0 '(1 2 3 4)) 10) (equal? (fold-right (lambda (x acc) (list x acc)) 0 '(1 2)) '(1 (2 0)))))", "tags": ["core", "base", "prelude", "bugfix", "fold-right"], "split": "eval"}
{"id": "core_prelude_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "drop", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `drop` in `core/base/prelude.ss`.\nKnown issue: Drop and take are not the same.\n\n```scheme\n(define (drop n lst)\n  (take n lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (drop 3 '(a b c d e)) '(d e))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))", "verify_expr": "(let ()\n  (define (drop n lst)\n  (if (or (= n 0) (null? lst))\n      lst\n      (drop (- n 1) (cdr lst))))\n  (equal? (drop 3 '(a b c d e)) '(d e)))", "tags": ["core", "base", "prelude", "bugfix", "drop"], "split": "eval"}
{"id": "core_prelude_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "span", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span` in `core/base/prelude.ss`.\nKnown issue: Must split at first failure of predicate.\n\n```scheme\n(define (span pred lst)\n  (values lst '()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))", "verify_expr": "(let ()\n  (define (span pred lst)\n  (cond\n    [(null? lst) (values '() '())]\n    [(pred (car lst))\n     (let-values ([(pre suf) (span pred (cdr lst))])\n       (values (cons (car lst) pre) suf))]\n    [else (values '() lst)]))\n  (let-values ([(pre suf) (span (lambda (x) (< x 3)) '(1 2 3 4))]) (and (equal? pre '(1 2)) (equal? suf '(3 4)))))", "tags": ["core", "base", "prelude", "bugfix", "span"], "split": "eval"}
{"id": "core_prelude_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "identity", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `identity` in `core/base/prelude.ss`.\nKnown issue: Identity must return input unchanged.\n\n```scheme\n(define (identity x)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (identity 42) 42)\n(equal? (identity '(a b)) '(a b))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (identity x)\n  x)", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (and (= (identity 42) 42) (equal? (identity '(a b)) '(a b))))", "tags": ["core", "base", "prelude", "bugfix", "identity"], "split": "eval"}
{"id": "core_prelude_bugfix_026", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distinct-by` in `core/base/prelude.ss`.\nKnown issue: Must deduplicate by computed key while preserving first occurrences.\n\n```scheme\n(define (distinct-by key-fn lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\"))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))", "verify_expr": "(let ()\n  (define (distinct-by key-fn lst)\n  (let loop ([lst lst] [seen '()] [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\n       (let* ([elem (car lst)]\n              [key (key-fn elem)])\n         (if (member key seen)\n             (loop (cdr lst) seen result)\n             (loop (cdr lst) (cons key seen) (cons elem result))))])))\n  (equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\")))", "tags": ["core", "base", "prelude", "bugfix", "distinct-by"], "split": "eval"}
{"id": "core_prelude_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "andmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether all elements in `(1 2 3)` are numbers.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(andmap number? '(1 2 3))", "verify_expr": "(equal? (andmap number? '(1 2 3)) #t)", "tags": ["core", "base", "prelude", "composition", "andmap", "direct"], "split": "eval"}
{"id": "core_prelude_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "fold-left", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute sum of `(1 2 3 4)` using fold-left.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(fold-left + 0 '(1 2 3 4))", "verify_expr": "(equal? (fold-left + 0 '(1 2 3 4)) 10)", "tags": ["core", "base", "prelude", "composition", "fold-left", "direct"], "split": "eval"}
{"id": "core_prelude_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "range", "prompt": "Task mode: compose existing APIs into one expression.\n\nGenerate range from 3 to 7.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (range 3 7) '(3 4 5 6))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(range 3 7)", "verify_expr": "(equal? (range 3 7) '(3 4 5 6))", "tags": ["core", "base", "prelude", "composition", "range", "direct"], "split": "eval"}
{"id": "core_prelude_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "last", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn last element of `(x y z)`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(last '(x y z))", "verify_expr": "(equal? (last '(x y z)) 'z)", "tags": ["core", "base", "prelude", "composition", "last", "direct"], "split": "eval"}
{"id": "core_prelude_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "sum", "prompt": "Task mode: compose existing APIs into one expression.\n\nSum values `(10 20 30)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (sum '(10 20 30)) 60)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sum '(10 20 30))", "verify_expr": "(equal? (sum '(10 20 30)) 60)", "tags": ["core", "base", "prelude", "composition", "sum", "direct"], "split": "eval"}
{"id": "core_prelude_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "flatten", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlatten list-of-lists `((1 2) () (3 4))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (flatten '((1 2) () (3 4))) '(1 2 3 4))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(flatten '((1 2) () (3 4)))", "verify_expr": "(equal? (flatten '((1 2) () (3 4))) '(1 2 3 4))", "tags": ["core", "base", "prelude", "composition", "flatten", "direct"], "split": "eval"}
{"id": "core_prelude_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "distinct-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nKeep first string per initial letter.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\"))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\"))", "verify_expr": "(equal? (distinct-by (lambda (s) (string-ref s 0)) '(\"apple\" \"apricot\" \"banana\" \"blueberry\")) '(\"apple\" \"banana\"))", "tags": ["core", "base", "prelude", "composition", "distinct-by", "direct"], "split": "eval"}
{"id": "core_prelude_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "partition", "prompt": "Task mode: small integration task across module primitives.\n\nCount partition sizes for `(1 2 3 4 5 6)` by even?.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([p (partition even? '(1 2 3 4 5 6))] [yes (car p)] [no (cadr p)]) (list (length yes) (length no))) '(3 3))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (partition even? '(1 2 3 4 5 6))] [yes (car p)] [no (cadr p)]) (list (length yes) (length no)))", "verify_expr": "(equal? (let* ([p (partition even? '(1 2 3 4 5 6))] [yes (car p)] [no (cadr p)]) (list (length yes) (length no))) '(3 3))", "tags": ["core", "base", "prelude", "composition", "partition", "integration"], "split": "eval"}
