{"id": "egraph_match_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-var?`\nSpec: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nWrite exactly one Scheme definition for `pattern-var?`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nCheck 2:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-var?`\nSpec: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nWrite exactly one Scheme definition for `pattern-var?`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nCheck 2:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f)) (= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-var? x)\n  ;; TODO: detect pattern variables like ?x but reject plain symbols and bare ?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-var?`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-var? x)\n  ;; TODO: detect pattern variables like ?x but reject plain symbols and bare ?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-var?`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Implement `pattern-var?` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `pattern-var?` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t) (equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp)))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-try-extend`\nSpec: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nWrite exactly one Scheme definition for `subst-try-extend`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-try-extend`\nSpec: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nWrite exactly one Scheme definition for `subst-try-extend`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  ;; TODO: insert new bindings, preserve identical bindings, reject conflicts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-try-extend`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  ;; TODO: insert new bindings, preserve identical bindings, reject conflicts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-try-extend`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(equal?\n  (let* ([s1 (subst-try-extend (empty-subst) '?x 2)]\n         [s2 (and s1 (subst-try-extend s1 '?x 3))])\n    (not s2))\n  #t)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t) (= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Implement `subst-try-extend` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `subst-try-extend` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-merge`\nSpec: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nWrite exactly one Scheme definition for `subst-merge`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-merge`\nSpec: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nWrite exactly one Scheme definition for `subst-merge`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 7)]\n         [b (subst-extend (empty-subst) '?y 8)]\n         [c (subst-merge a b)]\n         [d (and c\n                 (subst-merge c (subst-extend (empty-subst) '?z 9)))])\n    (and d (= (subst-lookup d '?y) 8)))\n  #t)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  ;; TODO: merge all bindings from subst1 into subst2 with compatibility checks\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-merge`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  ;; TODO: merge all bindings from subst1 into subst2 with compatibility checks\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-merge`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 1)]\n         [b (subst-extend (empty-subst) '?y 2)]\n         [m (subst-merge a b)])\n    (and m\n         (= (subst-lookup m '?x) 1)\n         (= (subst-lookup m '?y) 2)))\n  #t)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Implement `subst-merge` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `subst-merge` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch-pattern`\nSpec: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nWrite exactly one Scheme definition for `ematch-pattern`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch-pattern`\nSpec: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nWrite exactly one Scheme definition for `ematch-pattern`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(+ a b))]\n       [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]\n       [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))])\n  (and (= (length m1) 1)\n       (null? m2)\n       (let* ([s (car m1)]\n              [x (subst-lookup s '?x)]\n              [y (subst-lookup s '?y)])\n         (and (integer? x) (integer? y) (not (= x y))))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [id (egraph-add-term! eg '(+ x y))])\n    (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))\n  #t)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  ;; TODO: match variable, leaf, and pair patterns over the e-class nodes\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch-pattern`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  ;; TODO: match variable, leaf, and pair patterns over the e-class nodes\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch-pattern`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Implement `ematch-pattern` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `ematch-pattern` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch`\nSpec: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nWrite exactly one Scheme definition for `ematch`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch`\nSpec: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nWrite exactly one Scheme definition for `ematch`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)])\n    (= (length (ematch eg '?v x)) 1))\n  #t)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch eg pattern class-id)\n  ;; TODO: call ematch-pattern with an empty substitution\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch eg pattern class-id)\n  ;; TODO: call ematch-pattern with an empty substitution\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))])\n    (= (length (ematch eg '(f ?x) id)) 1))\n  #t)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t) (equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Implement `ematch` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `ematch` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))])\n    (null? (ematch eg '(g ?x) id)))\n  #t)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rule`\nSpec: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nWrite exactly one Scheme definition for `apply-rule`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rule`\nSpec: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nWrite exactly one Scheme definition for `apply-rule`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(= (let* ([eg (make-egraph)]\n          [r (make-rule '(+ ?x ?y) '(+ ?y ?x))]\n          [term (egraph-add-term! eg '(+ a b))])\n     (apply-rule eg r term)\n     (egraph-saturate-rebuild! eg)\n     (length (egraph-class-nodes eg term)))\n   2)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  ;; TODO: match lhs, instantiate rhs, add term, and merge results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rule`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  ;; TODO: match lhs, instantiate rhs, add term, and merge results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rule`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Implement `apply-rule` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `apply-rule` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [r (make-rule '?x '(+ ?x 0))]\n         [a-id (egraph-add-term! eg 'a)]\n         [sum-id (egraph-add-term! eg '(+ a 0))]\n         [ok (apply-rule eg r a-id)])\n    (egraph-saturate-rebuild! eg)\n    (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id))))\n  #t)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rules`\nSpec: Sweep all roots and rules once, counting how many rule applications matched.\n\nWrite exactly one Scheme definition for `apply-rules`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rules`\nSpec: Sweep all roots and rules once, counting how many rule applications matched.\n\nWrite exactly one Scheme definition for `apply-rules`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [rules (list (make-rule '(+ ?x 0) '?x))]\n       [_1 (egraph-add-term! eg '(+ a 0))]\n       [_2 (egraph-add-term! eg '(+ b 0))]\n       [count (apply-rules eg rules)])\n  (= count 2))\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))])\n     (egraph-add-term! eg '(+ a 0))\n     (egraph-add-term! eg '(+ b 0))\n     (apply-rules eg rules))\n   2)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "apply-rules"], "split": "train"}
{"id": "egraph_match_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rules eg rules)\n  ;; TODO: apply every rule to every root and count successful matches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rules`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rules eg rules)\n  ;; TODO: apply every rule to every root and count successful matches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rules`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "apply-rules"], "split": "train"}
{"id": "egraph_match_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Implement `apply-rules` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Sweep all roots and rules once, counting how many rule applications matched.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `apply-rules` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Sweep all roots and rules once, counting how many rule applications matched.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-var?`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-var?`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-var?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-var?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `pattern-var?`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `pattern-var?`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t) (equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f)))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-try-extend`.\nReturn only the Scheme definition.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-try-extend`.\nReturn only the Scheme definition.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)])\n     (if s (subst-lookup s '?x) -1))\n   7)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-try-extend`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n     [(not existing) (subst-extend subst var class-id)]\n     [(= existing class-id) subst]\n     [else #f])))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-try-extend`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n     [(not existing) (subst-extend subst var class-id)]\n     [(= existing class-id) subst]\n     [else #f])))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(equal?\n  (let* ([s1 (subst-try-extend (empty-subst) '?x 2)]\n         [s2 (and s1 (subst-try-extend s1 '?x 3))])\n    (not s2))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `subst-try-extend`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `subst-try-extend`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(equal?\n  (let* ([s1 (subst-try-extend (empty-subst) '?x 5)]\n         [s2 (and s1 (subst-try-extend s1 '?x 5))])\n    (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5)))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-merge`.\nReturn only the Scheme definition.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-merge`.\nReturn only the Scheme definition.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 7)]\n         [b (subst-extend (empty-subst) '?y 8)]\n         [c (subst-merge a b)]\n         [d (and c\n                 (subst-merge c (subst-extend (empty-subst) '?z 9)))])\n    (and d (= (subst-lookup d '?y) 8)))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [next (subst-try-extend result var class-id)])\n          (and next (loop (cdr s1) next))))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [next (subst-try-extend result var class-id)])\n          (and next (loop (cdr s1) next))))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 1)]\n         [b (subst-extend (empty-subst) '?y 2)]\n         [m (subst-merge a b)])\n    (and m\n         (= (subst-lookup m '?x) 1)\n         (= (subst-lookup m '?y) 2)))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `subst-merge`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `subst-merge`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 1)]\n         [b (subst-extend (empty-subst) '?x 2)])\n    (not (subst-merge a b)))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch-pattern`.\nReturn only the Scheme definition.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch-pattern`.\nReturn only the Scheme definition.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(+ a b))]\n       [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]\n       [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))])\n  (and (= (length m1) 1)\n       (null? m2)\n       (let* ([s (car m1)]\n              [x (subst-lookup s '?x)]\n              [y (subst-lookup s '?y)])\n         (and (integer? x) (integer? y) (not (= x y))))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [id (egraph-add-term! eg '(+ x y))])\n    (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))\n  #t)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch-pattern`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n     [(pattern-var? pattern)\n      (let ([new-subst (subst-try-extend subst pattern root)])\n        (if new-subst (list new-subst) '()))]\n     [(or (symbol? pattern) (number? pattern))\n      (if (exists (lambda (node)\n                    (and (eqv? (enode-op node) pattern)\n                         (zero? (enode-arity node))))\n                  (egraph-class-nodes eg root))\n          (list subst)\n          '())]\n     [(pair? pattern)\n      (let* ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)]\n             [matching\n              (filter (lambda (node)\n                        (and (eqv? (enode-op node) op)\n                             (= (enode-arity node) (length arg-patterns))))\n                      nodes)])\n        (apply append\n               (map (lambda (node)\n                      (ematch-children eg arg-patterns\n                                      (vector->list (enode-children node))\n                                      subst))\n                    matching)))]\n     [else '()])))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch-pattern`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n     [(pattern-var? pattern)\n      (let ([new-subst (subst-try-extend subst pattern root)])\n        (if new-subst (list new-subst) '()))]\n     [(or (symbol? pattern) (number? pattern))\n      (if (exists (lambda (node)\n                    (and (eqv? (enode-op node) pattern)\n                         (zero? (enode-arity node))))\n                  (egraph-class-nodes eg root))\n          (list subst)\n          '())]\n     [(pair? pattern)\n      (let* ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)]\n             [matching\n              (filter (lambda (node)\n                        (and (eqv? (enode-op node) op)\n                             (= (enode-arity node) (length arg-patterns))))\n                      nodes)])\n        (apply append\n               (map (lambda (node)\n                      (ematch-children eg arg-patterns\n                                      (vector->list (enode-children node))\n                                      subst))\n                    matching)))]\n     [else '()])))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `ematch-pattern`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `ematch-pattern`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch`.\nReturn only the Scheme definition.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch`.\nReturn only the Scheme definition.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)])\n    (= (length (ematch eg '?v x)) 1))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "ematch"], "split": "train"}
{"id": "egraph_match_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (empty-subst)))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (empty-subst)))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))])\n    (= (length (ematch eg '(f ?x) id)) 1))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "ematch"], "split": "train"}
{"id": "egraph_match_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `ematch`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `ematch`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(equal?\n  (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))])\n    (null? (ematch eg '(g ?x) id)))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "ematch"], "split": "train"}
{"id": "egraph_match_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rule`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rule`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_020", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rule`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rule`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(= (let* ([eg (make-egraph)]\n          [r (make-rule '(+ ?x ?y) '(+ ?y ?x))]\n          [term (egraph-add-term! eg '(+ a b))])\n     (apply-rule eg r term)\n     (egraph-saturate-rebuild! eg)\n     (length (egraph-class-nodes eg term)))\n   2)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `apply-rule`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `apply-rule`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [r (make-rule '?x '(+ ?x 0))]\n         [a-id (egraph-add-term! eg 'a)]\n         [sum-id (egraph-add-term! eg '(+ a 0))]\n         [ok (apply-rule eg r a-id)])\n    (egraph-saturate-rebuild! eg)\n    (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id))))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t) (equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rules`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rules`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_023", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rules`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)] [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rules`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)] [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [rules (list (make-rule '(+ ?x 0) '?x))]\n       [_1 (egraph-add-term! eg '(+ a 0))]\n       [_2 (egraph-add-term! eg '(+ b 0))]\n       [count (apply-rules eg rules)])\n  (= count 2))\n(equal?\n  (let* ([eg (make-egraph)]\n         [rules (list (make-rule '(* ?x 1) '?x))])\n    (egraph-add-term! eg '(+ a 0))\n    (= (apply-rules eg rules) 0))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `apply-rules`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `apply-rules`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [rules (list (make-rule '(+ ?x 0) '?x))]\n       [_1 (egraph-add-term! eg '(+ a 0))]\n       [_2 (egraph-add-term! eg '(+ b 0))]\n       [count (apply-rules eg rules)])\n  (= count 2))\n(= (let* ([eg (make-egraph)]\n          [rules (list\n                   (make-rule '(+ ?x 0) '?x)\n                   (make-rule '(* ?x 1) '?x))])\n     (egraph-add-term! eg '(+ a 0))\n     (egraph-add-term! eg '(* b 1))\n     (apply-rules eg rules))\n   2)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "apply-rules"], "split": "train"}
{"id": "egraph_match_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: A pattern variable must start with ? and have at least one character after it.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (> (string-length s) 0)))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: A pattern variable must start with ? and have at least one character after it.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (> (string-length s) 0)))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCheck 2:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t) (= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-var?"], "split": "train"}
{"id": "egraph_match_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: Bare ? is not a valid pattern variable; require length > 1.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 0)\n              (char=? (string-ref s 0) #\\?)))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: Bare ? is not a valid pattern variable; require length > 1.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 0)\n              (char=? (string-ref s 0) #\\?)))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)) (= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3) (equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-var?"], "split": "train"}
{"id": "egraph_match_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: Conflicting rebinding must return #f, not append another binding.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (subst-extend subst var class-id)\n        (subst-extend subst var class-id))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: Conflicting rebinding must return #f, not append another binding.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (subst-extend subst var class-id)\n        (subst-extend subst var class-id))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: When the variable is absent, extend with the new binding instead of leaving substitution unchanged.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) subst]\n      [(= existing class-id) subst]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: When the variable is absent, extend with the new binding instead of leaving substitution unchanged.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) subst]\n      [(= existing class-id) subst]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(equal?\n  (let* ([s1 (subst-try-extend (empty-subst) '?x 5)]\n         [s2 (and s1 (subst-try-extend s1 '?x 5))])\n    (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5)))\n  #t)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([s0 (empty-subst)]\n       [s1 (subst-try-extend s0 '?x 5)]\n       [s2 (and s1 (subst-try-extend s1 '?x 5))]\n       [s3 (and s1 (subst-try-extend s1 '?x 6))])\n  (and (pair? s1)\n       (pair? s2)\n       (not s3)\n       (= (subst-lookup s1 '?x) 5)))\n(equal?\n  (let* ([s1 (subst-try-extend (empty-subst) '?x 5)]\n         [s2 (and s1 (subst-try-extend s1 '?x 5))])\n    (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5)))\n  #t)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(and (let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5))) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t) (equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must detect conflicts and return #f on incompatible bindings.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (append subst1 subst2))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must detect conflicts and return #f on incompatible bindings.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (append subst1 subst2))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 7)]\n         [b (subst-extend (empty-subst) '?y 8)]\n         [c (subst-merge a b)]\n         [d (and c\n                 (subst-merge c (subst-extend (empty-subst) '?z 9)))])\n    (and d (= (subst-lookup d '?y) 8)))\n  #t)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 7)]\n         [b (subst-extend (empty-subst) '?y 8)]\n         [c (subst-merge a b)]\n         [d (and c\n                 (subst-merge c (subst-extend (empty-subst) '?z 9)))])\n    (and d (= (subst-lookup d '?y) 8)))\n  #t)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-merge"], "split": "train"}
{"id": "egraph_match_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Must process every binding from subst1, not only the first.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (if (null? subst1)\n      subst2\n      (let* ([b (car subst1)]\n             [v (car b)]\n             [c (cdr b)])\n        (subst-try-extend subst2 v c))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Must process every binding from subst1, not only the first.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (if (null? subst1)\n      subst2\n      (let* ([b (car subst1)]\n             [v (car b)]\n             [c (cdr b)])\n        (subst-try-extend subst2 v c))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 1)]\n         [b (subst-extend (empty-subst) '?y 2)]\n         [m (subst-merge a b)])\n    (and m\n         (= (subst-lookup m '?x) 1)\n         (= (subst-lookup m '?y) 2)))\n  #t)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([a (subst-extend (empty-subst) '?x 1)]\n       [b (subst-extend (empty-subst) '?y 2)]\n       [ok (subst-merge a b)]\n       [c (subst-extend (empty-subst) '?x 1)]\n       [d (subst-extend (empty-subst) '?x 3)]\n       [bad (subst-merge c d)])\n  (and (pair? ok)\n       (= (subst-lookup ok '?x) 1)\n       (= (subst-lookup ok '?y) 2)\n       (not bad)))\n(equal?\n  (let* ([a (subst-extend (empty-subst) '?x 1)]\n         [b (subst-extend (empty-subst) '?y 2)]\n         [m (subst-merge a b)])\n    (and m\n         (= (subst-lookup m '?x) 1)\n         (= (subst-lookup m '?y) 2)))\n  #t)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(and (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad))) (equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t) (equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-merge"], "split": "train"}
{"id": "egraph_match_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: Leaf matching must verify operator equality and zero arity, not only class non-emptiness.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (if (pair? (egraph-class-nodes eg root))\n           (list subst)\n           '())]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: Leaf matching must verify operator equality and zero arity, not only class non-emptiness.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (if (pair? (egraph-class-nodes eg root))\n           (list subst)\n           '())]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(+ a b))]\n       [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]\n       [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))])\n  (and (= (length m1) 1)\n       (null? m2)\n       (let* ([s (car m1)]\n              [x (subst-lookup s '?x)]\n              [y (subst-lookup s '?y)])\n         (and (integer? x) (integer? y) (not (= x y))))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [id (egraph-add-term! eg '(+ x y))])\n    (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))\n  #t)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(+ a b))]\n       [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]\n       [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))])\n  (and (= (length m1) 1)\n       (null? m2)\n       (let* ([s (car m1)]\n              [x (subst-lookup s '?x)]\n              [y (subst-lookup s '?y)])\n         (and (integer? x) (integer? y) (not (= x y))))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [id (egraph-add-term! eg '(+ x y))])\n    (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))\n  #t)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: For application patterns, accumulate matches across all matching nodes, not just the first node.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(pair? pattern)\n       (let* ([op (car pattern)]\n              [args (cdr pattern)]\n              [nodes (egraph-class-nodes eg root)]\n              [node (car nodes)])\n         (if (and (eqv? (enode-op node) op)\n                  (= (enode-arity node) (length args)))\n             (ematch-children eg args (vector->list (enode-children node)) subst)\n             '()))]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: For application patterns, accumulate matches across all matching nodes, not just the first node.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(pair? pattern)\n       (let* ([op (car pattern)]\n              [args (cdr pattern)]\n              [nodes (egraph-class-nodes eg root)]\n              [node (car nodes)])\n         (if (and (eqv? (enode-op node) op)\n                  (= (enode-arity node) (length args)))\n             (ematch-children eg args (vector->list (enode-children node)) subst)\n             '()))]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(+ a b))]\n       [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]\n       [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))])\n  (and (= (length m1) 1)\n       (null? m2)\n       (let* ([s (car m1)]\n              [x (subst-lookup s '?x)]\n              [y (subst-lookup s '?y)])\n         (and (integer? x) (integer? y) (not (= x y))))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [id (egraph-add-term! eg 'x)]\n         [ms (ematch-pattern eg 'x id (empty-subst))])\n    (= (length ms) 1))\n  #t)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y)))))) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t) (equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: ematch must return all substitutions, not truncate to one.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([matches (ematch-pattern eg pattern class-id (empty-subst))])\n    (if (null? matches) '() (list (car matches)))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: ematch must return all substitutions, not truncate to one.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([matches (ematch-pattern eg pattern class-id (empty-subst))])\n    (if (null? matches) '() (list (car matches)))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2) (equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch"], "split": "train"}
{"id": "egraph_match_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: Matching should begin with an empty substitution, without introducing extraneous bindings.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (subst-extend (empty-subst) '?seed 0)))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: Matching should begin with an empty substitution, without introducing extraneous bindings.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (subst-extend (empty-subst) '?seed 0)))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)])\n  (and (= (length mv) 1) (= (length mf) 1) (null? mg)))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)]) (and (= (length mv) 1) (= (length mf) 1) (null? mg))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2) (equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch"], "split": "train"}
{"id": "egraph_match_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: If there are no matches, apply-rule must return #f.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #t\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: If there are no matches, apply-rule must return #f.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #t\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(= (let* ([eg (make-egraph)]\n          [r (make-rule '(+ ?x ?y) '(+ ?y ?x))]\n          [term (egraph-add-term! eg '(+ a b))])\n     (apply-rule eg r term)\n     (egraph-saturate-rebuild! eg)\n     (length (egraph-class-nodes eg term)))\n   2)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2) (equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rule"], "split": "train"}
{"id": "egraph_match_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: New rhs term must be merged into the matched class-id, not merged with itself.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg rhs-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)\n```", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: New rhs term must be merged into the matched class-id, not merged with itself.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg rhs-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(equal?\n  (let* ([eg (make-egraph)]\n         [r (make-rule '?x '(+ ?x 0))]\n         [a-id (egraph-add-term! eg 'a)]\n         [sum-id (egraph-add-term! eg '(+ a 0))]\n         [ok (apply-rule eg r a-id)])\n    (egraph-saturate-rebuild! eg)\n    (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id))))\n  #t)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t) (equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rule"], "split": "train"}
{"id": "egraph_match_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Only successful apply-rule matches should increment count.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (apply-rule eg rule root)\n          (set! count (+ count 1)))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Only successful apply-rule matches should increment count.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (apply-rule eg rule root)\n          (set! count (+ count 1)))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([eg (make-egraph)]\n       [rules (list (make-rule '(+ ?x 0) '?x))]\n       [_1 (egraph-add-term! eg '(+ a 0))]\n       [_2 (egraph-add-term! eg '(+ b 0))]\n       [count (apply-rules eg rules)])\n  (= count 2))\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))])\n     (egraph-add-term! eg '(+ a 0))\n     (egraph-add-term! eg '(+ b 0))\n     (apply-rules eg rules))\n   2)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rules"], "split": "train"}
{"id": "egraph_match_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Must apply every rule, not only the first rule in the list.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (when (pair? rules)\n         (when (apply-rule eg (car rules) root)\n           (set! count (+ count 1)))))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Must apply every rule, not only the first rule in the list.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (when (pair? rules)\n         (when (apply-rule eg (car rules) root)\n           (set! count (+ count 1)))))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) (= count 2)) (equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rules"], "split": "train"}
{"id": "egraph_match_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Map pattern-var? over `(?x x ?foo ?)` and return the boolean list.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```", "prompt": "Task mode: small integration task across module primitives.\n\nMap pattern-var? over `(?x x ?foo ?)` and return the boolean list.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map pattern-var? '(?x x ?foo ?))", "verify_expr": "(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "mapping"], "split": "train"}
{"id": "egraph_match_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Extract normalized names from the pattern-variable subset of `(?left plus ?right ?tmp)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```", "prompt": "Task mode: small integration task across module primitives.\n\nExtract normalized names from the pattern-variable subset of `(?left plus ?right ?tmp)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))\n```\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp)))", "verify_expr": "(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "names"], "split": "train"}
{"id": "egraph_match_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Return whether all entries in `(?a ?b ?c)` are valid pattern variables.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether all entries in `(?a ?b ?c)` are valid pattern variables.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c))", "verify_expr": "(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "all-true"], "split": "train"}
{"id": "egraph_match_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Extend an empty substitution with `?x -> 7` and return the looked-up value for `?x`.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```", "prompt": "Task mode: small integration task across module primitives.\n\nExtend an empty substitution with `?x -> 7` and return the looked-up value for `?x`.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)\n```\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1))", "verify_expr": "(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "insert"], "split": "train"}
{"id": "egraph_match_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Attempt to rebind `?x` from 2 to 3 and return whether the extension fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nAttempt to rebind `?x` from 2 to 3 and return whether the extension fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "conflict"], "split": "train"}
{"id": "egraph_match_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Extend with `?x -> 1`, then `?y -> 2`, then test whether changing `?y` to 3 fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtend with `?x -> 1`, then `?y -> 2`, then test whether changing `?y` to 3 fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3)))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "multi-var"], "split": "train"}
{"id": "egraph_match_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge `(?x . 1)` with `(?y . 2)` and return whether both bindings are present.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge `(?x . 1)` with `(?y . 2)` and return whether both bindings are present.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "compatible"], "split": "train"}
{"id": "egraph_match_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge conflicting substitutions for `?x` and return whether merge fails.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge conflicting substitutions for `?x` and return whether merge fails.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "conflict"], "split": "train"}
{"id": "egraph_match_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge overlapping substitutions where `?x` is consistent and verify both vars remain available.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge overlapping substitutions where `?x` is consistent and verify both vars remain available.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "overlap"], "split": "train"}
{"id": "egraph_match_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match repeated-var pattern `(+ ?a ?a)` against `(+ x y)` and return whether it fails.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch repeated-var pattern `(+ ?a ?a)` against `(+ x y)` and return whether it fails.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "repeated-var"], "split": "train"}
{"id": "egraph_match_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match leaf pattern `x` against class for `x` and return whether exactly one substitution is returned.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMatch leaf pattern `x` against class for `x` and return whether exactly one substitution is returned.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "leaf"], "split": "train"}
{"id": "egraph_match_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match wrong operator `(* ?x ?y)` against `(+ a b)` and return whether no matches are produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch wrong operator `(* ?x ?y)` against `(+ a b)` and return whether no matches are produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "op-mismatch"], "split": "train"}
{"id": "egraph_match_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Run `ematch` with variable pattern `?v` on class of `x` and return whether there is one match.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun `ematch` with variable pattern `?v` on class of `x` and return whether there is one match.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "variable"], "split": "train"}
{"id": "egraph_match_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Run `ematch` for `(f ?x)` on class of `(f a)` and return whether one match exists.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```", "prompt": "Task mode: small integration task across module primitives.\n\nRun `ematch` for `(f ?x)` on class of `(f a)` and return whether one match exists.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (= (length (ematch eg '(f ?x) id)) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "application"], "split": "train"}
{"id": "egraph_match_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Run `ematch` for `(g ?x)` on class of `(f a)` and return whether it fails.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun `ematch` for `(g ?x)` on class of `(f a)` and return whether it fails.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "mismatch"], "split": "train"}
{"id": "egraph_match_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution `{?x->5}` to `?x` and return whether output is an eclass-ref with id 5.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution `{?x->5}` to `?x` and return whether output is an eclass-ref with id 5.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5)))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "var-instantiate"], "split": "train"}
{"id": "egraph_match_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution on `(+ ?x ?y)` and return whether both children are eclass refs.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution on `(+ ?x ?y)` and return whether both children are eclass refs.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r))))", "verify_expr": "(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "compound"], "split": "train"}
{"id": "egraph_match_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution to `(f ?x 42)` and return whether literal 42 is preserved.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution to `(f ?x 42)` and return whether literal 42 is preserved.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "literal-preserve"], "split": "train"}
{"id": "egraph_match_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution to nested pattern `(f (g ?x))` and return whether nested arg is an eclass-ref.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply substitution to nested pattern `(f (g ?x))` and return whether nested arg is an eclass-ref.\n\nEnsure `pattern-apply` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r))))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "nested"], "split": "train"}
{"id": "egraph_match_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply `(+ ?x 0) => ?x` to class of `(+ a 0)` and return whether it becomes equivalent to `a`.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply `(+ ?x 0) => ?x` to class of `(+ a 0)` and return whether it becomes equivalent to `a`.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "identity"], "split": "train"}
{"id": "egraph_match_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply commutativity rule `(+ ?x ?y) => (+ ?y ?x)` to `(+ a b)` and return class node count after rebuild.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```", "prompt": "Task mode: small integration task across module primitives.\n\nApply commutativity rule `(+ ?x ?y) => (+ ?y ?x)` to `(+ a b)` and return class node count after rebuild.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term)))", "verify_expr": "(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "commutativity"], "split": "train"}
{"id": "egraph_match_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply expansion rule `?x => (+ ?x 0)` to `a` and return whether `a` becomes equivalent to `(+ a 0)`.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply expansion rule `?x => (+ ?x 0)` to `a` and return whether `a` becomes equivalent to `(+ a 0)`.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "expansion"], "split": "train"}
{"id": "egraph_match_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Run apply-rules with rule `(+ ?x 0) => ?x` over `(+ a 0)` and `(+ b 0)`; return match count.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun apply-rules with rule `(+ ?x 0) => ?x` over `(+ a 0)` and `(+ b 0)`; return match count.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules))", "verify_expr": "(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(+ b 0)) (apply-rules eg rules)) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "count"], "split": "train"}
