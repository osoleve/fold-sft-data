{"id": "egraph_match_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-var?`\nSpec: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nWrite exactly one Scheme definition for `pattern-var?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-var?`\nSpec: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nWrite exactly one Scheme definition for `pattern-var?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-var? x)\n  ;; TODO: detect pattern variables like ?x but reject plain symbols and bare ?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-var?`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-var? x)\n  ;; TODO: detect pattern variables like ?x but reject plain symbols and bare ?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-var?`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Implement `pattern-var?` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `pattern-var?` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Return #t iff input is a symbol whose textual form starts with ? and has length > 1.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "pattern-var?"], "split": "train"}
{"id": "egraph_match_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-try-extend`\nSpec: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nWrite exactly one Scheme definition for `subst-try-extend`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-try-extend`\nSpec: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nWrite exactly one Scheme definition for `subst-try-extend`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  ;; TODO: insert new bindings, preserve identical bindings, reject conflicts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-try-extend`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  ;; TODO: insert new bindings, preserve identical bindings, reject conflicts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-try-extend`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Implement `subst-try-extend` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `subst-try-extend` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Add a binding when absent, preserve same binding, and reject conflicting binding with #f.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-merge`\nSpec: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nWrite exactly one Scheme definition for `subst-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `subst-merge`\nSpec: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nWrite exactly one Scheme definition for `subst-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  ;; TODO: merge all bindings from subst1 into subst2 with compatibility checks\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-merge`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  ;; TODO: merge all bindings from subst1 into subst2 with compatibility checks\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `subst-merge`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Implement `subst-merge` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `subst-merge` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Merge two substitution alists and fail with #f on any variable/class conflict.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "subst-merge"], "split": "train"}
{"id": "egraph_match_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch-pattern`\nSpec: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nWrite exactly one Scheme definition for `ematch-pattern`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch-pattern`\nSpec: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nWrite exactly one Scheme definition for `ematch-pattern`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (length m1) 1)\n(null? m2)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  ;; TODO: match variable, leaf, and pair patterns over the e-class nodes\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch-pattern`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  ;; TODO: match variable, leaf, and pair patterns over the e-class nodes\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch-pattern`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Implement `ematch-pattern` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `ematch-pattern` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match a pattern against an e-class recursively, returning every compatible substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch`\nSpec: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nWrite exactly one Scheme definition for `ematch`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `ematch`\nSpec: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nWrite exactly one Scheme definition for `ematch`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch eg pattern class-id)\n  ;; TODO: call ematch-pattern with an empty substitution\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ematch eg pattern class-id)\n  ;; TODO: call ematch-pattern with an empty substitution\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ematch`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Implement `ematch` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `ematch` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Entry-point wrapper that runs ematch-pattern using an empty substitution.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "ematch"], "split": "train"}
{"id": "egraph_match_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rule`\nSpec: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nWrite exactly one Scheme definition for `apply-rule`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rule`\nSpec: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nWrite exactly one Scheme definition for `apply-rule`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  ;; TODO: match lhs, instantiate rhs, add term, and merge results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rule`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  ;; TODO: match lhs, instantiate rhs, add term, and merge results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rule`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Implement `apply-rule` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `apply-rule` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Match rule lhs in a class, instantiate rhs for each match, add term, and merge into matched class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "apply-rule"], "split": "train"}
{"id": "egraph_match_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rules`\nSpec: Sweep all roots and rules once, counting how many rule applications matched.\n\nWrite exactly one Scheme definition for `apply-rules`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `apply-rules`\nSpec: Sweep all roots and rules once, counting how many rule applications matched.\n\nWrite exactly one Scheme definition for `apply-rules`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(+ b 0))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n(= (let* ([eg (make-egraph)]\n          [rules (list\n                   (make-rule '(+ ?x 0) '?x)\n                   (make-rule '(* ?x 1) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(* b 1))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "apply-rules"], "split": "train"}
{"id": "egraph_match_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rules eg rules)\n  ;; TODO: apply every rule to every root and count successful matches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rules`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-rules eg rules)\n  ;; TODO: apply every rule to every root and count successful matches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-rules`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "apply-rules"], "split": "train"}
{"id": "egraph_match_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Implement `apply-rules` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Sweep all roots and rules once, counting how many rule applications matched.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `apply-rules` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Sweep all roots and rules once, counting how many rule applications matched.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-var?`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-var?`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_var(x):\n    if not isinstance(x, Symbol):\n        return False\n    s = str(x)\n    return len(s) > 1 and s[0] == '?'\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-var?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-var? x)\n  (if (not (symbol? x))\n      #f\n      (let* ([txt (symbol->string x)]\n             [n (string-length txt)])\n        (and (> n 1)\n             (char=? #\\? (string-ref txt 0))))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-var?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-var? x)\n  (if (not (symbol? x))\n      #f\n      (let* ([txt (symbol->string x)]\n             [n (string-length txt)])\n        (and (> n 1)\n             (char=? #\\? (string-ref txt 0))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `pattern-var?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'patterns)\n\n(define (local-helper x) x)\n\n  (define (pattern-var? x)\n    (if (not (symbol? x))\n        #f\n        (let* ([txt (symbol->string x)]\n               [n (string-length txt)])\n          (and (> n 1)\n               (char=? #\\? (string-ref txt 0))))))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `pattern-var?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'patterns)\n\n(define (local-helper x) x)\n\n  (define (pattern-var? x)\n    (if (not (symbol? x))\n        #f\n        (let* ([txt (symbol->string x)]\n               [n (string-length txt)])\n          (and (> n 1)\n               (char=? #\\? (string-ref txt 0))))))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "pattern-var?"], "split": "train"}
{"id": "egraph_match_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-try-extend`.\nReturn only the Scheme definition.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-try-extend`.\nReturn only the Scheme definition.\n\n```python\ndef subst_try_extend(subst, var, class_id):\n    existing = subst_lookup(subst, var)\n    if existing is None:\n        return subst_extend(subst, var, class_id)\n    if existing == class_id:\n        return subst\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-try-extend`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (if (= existing class-id)\n            subst\n            #f)\n        (subst-extend subst var class-id))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-try-extend`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (if (= existing class-id)\n            subst\n            #f)\n        (subst-extend subst var class-id))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `subst-try-extend`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'substitutions)\n\n(define (local-helper x) x)\n\n  (define (subst-try-extend subst var class-id)\n    (let ([existing (subst-lookup subst var)])\n      (if existing\n          (if (= existing class-id)\n              subst\n              #f)\n          (subst-extend subst var class-id))))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `subst-try-extend`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'substitutions)\n\n(define (local-helper x) x)\n\n  (define (subst-try-extend subst var class-id)\n    (let ([existing (subst-lookup subst var)])\n      (if existing\n          (if (= existing class-id)\n              subst\n              #f)\n          (subst-extend subst var class-id))))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-merge`.\nReturn only the Scheme definition.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `subst-merge`.\nReturn only the Scheme definition.\n\n```python\ndef subst_merge(subst1, subst2):\n    result = subst2\n    for var, class_id in subst1:\n        result = subst_try_extend(result, var, class_id)\n        if result is None:\n            return None\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [next (subst-try-extend result var class-id)])\n          (and next (loop (cdr s1) next))))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `subst-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [next (subst-try-extend result var class-id)])\n          (and next (loop (cdr s1) next))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `subst-merge`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'substitutions)\n\n(define (local-helper x) x)\n\n  (define (subst-merge subst1 subst2)\n    (let loop ([s1 subst1] [result subst2])\n      (if (null? s1)\n          result\n          (let* ([binding (car s1)]\n                 [var (car binding)]\n                 [class-id (cdr binding)]\n                 [next (subst-try-extend result var class-id)])\n            (and next (loop (cdr s1) next))))))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `subst-merge`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'substitutions)\n\n(define (local-helper x) x)\n\n  (define (subst-merge subst1 subst2)\n    (let loop ([s1 subst1] [result subst2])\n      (if (null? s1)\n          result\n          (let* ([binding (car s1)]\n                 [var (car binding)]\n                 [class-id (cdr binding)]\n                 [next (subst-try-extend result var class-id)])\n            (and next (loop (cdr s1) next))))))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "subst-merge"], "split": "train"}
{"id": "egraph_match_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch-pattern`.\nReturn only the Scheme definition.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch-pattern`.\nReturn only the Scheme definition.\n\n```python\ndef ematch_pattern(eg, pattern, class_id, subst):\n    root = egraph_find(eg, class_id)\n    if pattern_var(pattern):\n        s = subst_try_extend(subst, pattern, root)\n        return [s] if s is not None else []\n    if is_leaf(pattern):\n        return [subst] if class_has_leaf(eg, root, pattern) else []\n    op, args = pattern[0], pattern[1:]\n    out = []\n    for node in class_nodes(eg, root):\n        if node.op == op and len(node.children) == len(args):\n            out.extend(ematch_children(eg, args, node.children, subst))\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (length m1) 1)\n(null? m2)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch-pattern`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n     [(pattern-var? pattern)\n      (let ([new-subst (subst-try-extend subst pattern root)])\n        (if new-subst (list new-subst) '()))]\n     [(or (symbol? pattern) (number? pattern))\n      (if (exists (lambda (node)\n                    (and (eqv? (enode-op node) pattern)\n                         (zero? (enode-arity node))))\n                  (egraph-class-nodes eg root))\n          (list subst)\n          '())]\n     [(pair? pattern)\n      (let* ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)]\n             [matching\n              (filter (lambda (node)\n                        (and (eqv? (enode-op node) op)\n                             (= (enode-arity node) (length arg-patterns))))\n                      nodes)])\n        (apply append\n               (map (lambda (node)\n                      (ematch-children eg arg-patterns\n                                      (vector->list (enode-children node))\n                                      subst))\n                    matching)))]\n     [else '()])))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch-pattern`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n     [(pattern-var? pattern)\n      (let ([new-subst (subst-try-extend subst pattern root)])\n        (if new-subst (list new-subst) '()))]\n     [(or (symbol? pattern) (number? pattern))\n      (if (exists (lambda (node)\n                    (and (eqv? (enode-op node) pattern)\n                         (zero? (enode-arity node))))\n                  (egraph-class-nodes eg root))\n          (list subst)\n          '())]\n     [(pair? pattern)\n      (let* ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)]\n             [matching\n              (filter (lambda (node)\n                        (and (eqv? (enode-op node) op)\n                             (= (enode-arity node) (length arg-patterns))))\n                      nodes)])\n        (apply append\n               (map (lambda (node)\n                      (ematch-children eg arg-patterns\n                                      (vector->list (enode-children node))\n                                      subst))\n                    matching)))]\n     [else '()])))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `ematch-pattern`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'matching)\n\n(define (local-helper x) x)\n\n  (define (ematch-pattern eg pattern class-id subst)\n    (let ([root (egraph-find eg class-id)])\n      (cond\n       [(pattern-var? pattern)\n        (let ([new-subst (subst-try-extend subst pattern root)])\n          (if new-subst (list new-subst) '()))]\n       [(or (symbol? pattern) (number? pattern))\n        (if (exists (lambda (node)\n                      (and (eqv? (enode-op node) pattern)\n                           (zero? (enode-arity node))))\n                    (egraph-class-nodes eg root))\n            (list subst)\n            '())]\n       [(pair? pattern)\n        (let* ([op (car pattern)]\n               [arg-patterns (cdr pattern)]\n               [nodes (egraph-class-nodes eg root)]\n               [matching\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n          (apply append\n                 (map (lambda (node)\n                        (ematch-children eg arg-patterns\n                                        (vector->list (enode-children node))\n                                        subst))\n                      matching)))]\n       [else '()])))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `ematch-pattern`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'matching)\n\n(define (local-helper x) x)\n\n  (define (ematch-pattern eg pattern class-id subst)\n    (let ([root (egraph-find eg class-id)])\n      (cond\n       [(pattern-var? pattern)\n        (let ([new-subst (subst-try-extend subst pattern root)])\n          (if new-subst (list new-subst) '()))]\n       [(or (symbol? pattern) (number? pattern))\n        (if (exists (lambda (node)\n                      (and (eqv? (enode-op node) pattern)\n                           (zero? (enode-arity node))))\n                    (egraph-class-nodes eg root))\n            (list subst)\n            '())]\n       [(pair? pattern)\n        (let* ([op (car pattern)]\n               [arg-patterns (cdr pattern)]\n               [nodes (egraph-class-nodes eg root)]\n               [matching\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n          (apply append\n                 (map (lambda (node)\n                        (ematch-children eg arg-patterns\n                                        (vector->list (enode-children node))\n                                        subst))\n                      matching)))]\n       [else '()])))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch`.\nReturn only the Scheme definition.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `ematch`.\nReturn only the Scheme definition.\n\n```python\ndef ematch(eg, pattern, class_id):\n    return ematch_pattern(eg, pattern, class_id, empty_subst())\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "ematch"], "split": "train"}
{"id": "egraph_match_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([seed (empty-subst)])\n    (ematch-pattern eg pattern class-id seed)))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ematch`.\nReturn only the final Fold definition.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([seed (empty-subst)])\n    (ematch-pattern eg pattern class-id seed)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "ematch"], "split": "train"}
{"id": "egraph_match_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `ematch`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'matching)\n\n(define (local-helper x) x)\n\n  (define (ematch eg pattern class-id)\n    (let ([seed (empty-subst)])\n      (ematch-pattern eg pattern class-id seed)))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `ematch`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'matching)\n\n(define (local-helper x) x)\n\n  (define (ematch eg pattern class-id)\n    (let ([seed (empty-subst)])\n      (ematch-pattern eg pattern class-id seed)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "ematch"], "split": "train"}
{"id": "egraph_match_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rule`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rule`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rule(eg, rule, class_id):\n    lhs, rhs = rule_lhs(rule), rule_rhs(rule)\n    matches = ematch(eg, lhs, class_id)\n    if not matches:\n        return False\n    for subst in matches:\n        rhs_term = pattern_apply(subst, rhs)\n        rhs_id = add_instantiated_term(eg, rhs_term)\n        egraph_merge(eg, class_id, rhs_id)\n    return True\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rule`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [subs (ematch eg lhs class-id)])\n    (cond\n     [(null? subs) #f]\n     [else\n      (for-each\n       (lambda (s)\n         (let* ([rhs-term (pattern-apply s rhs)]\n                [rhs-id (add-instantiated-term eg rhs-term)])\n           (egraph-merge! eg class-id rhs-id)))\n       subs)\n      #t])))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rule`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [subs (ematch eg lhs class-id)])\n    (cond\n     [(null? subs) #f]\n     [else\n      (for-each\n       (lambda (s)\n         (let* ([rhs-term (pattern-apply s rhs)]\n                [rhs-id (add-instantiated-term eg rhs-term)])\n           (egraph-merge! eg class-id rhs-id)))\n       subs)\n      #t])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `apply-rule`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'rewrites)\n\n(define (local-helper x) x)\n\n  (define (apply-rule eg rule class-id)\n    (let* ([lhs (rule-lhs rule)]\n           [rhs (rule-rhs rule)]\n           [subs (ematch eg lhs class-id)])\n      (cond\n       [(null? subs) #f]\n       [else\n        (for-each\n         (lambda (s)\n           (let* ([rhs-term (pattern-apply s rhs)]\n                  [rhs-id (add-instantiated-term eg rhs-term)])\n             (egraph-merge! eg class-id rhs-id)))\n         subs)\n        #t])))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `apply-rule`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'rewrites)\n\n(define (local-helper x) x)\n\n  (define (apply-rule eg rule class-id)\n    (let* ([lhs (rule-lhs rule)]\n           [rhs (rule-rhs rule)]\n           [subs (ematch eg lhs class-id)])\n      (cond\n       [(null? subs) #f]\n       [else\n        (for-each\n         (lambda (s)\n           (let* ([rhs-term (pattern-apply s rhs)]\n                  [rhs-id (add-instantiated-term eg rhs-term)])\n             (egraph-merge! eg class-id rhs-id)))\n         subs)\n        #t])))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "apply-rule"], "split": "train"}
{"id": "egraph_match_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rules`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `apply-rules`.\nReturn only the Scheme definition.\n\n```python\ndef apply_rules(eg, rules):\n    count = 0\n    for root in uf_roots(egraph_uf(eg)):\n        for rule in rules:\n            if apply_rule(eg, rule, root):\n                count += 1\n    return count\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rules`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (if (apply-rule eg rule root)\n              (set! count (+ count 1))\n              #f))\n        rules))\n     (uf-roots (egraph-uf eg)))\n    count))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `apply-rules`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (if (apply-rule eg rule root)\n              (set! count (+ count 1))\n              #f))\n        rules))\n     (uf-roots (egraph-uf eg)))\n    count))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(+ b 0))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n(= (let* ([eg (make-egraph)]\n          [rules (list\n                   (make-rule '(+ ?x 0) '?x)\n                   (make-rule '(* ?x 1) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(* b 1))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "apply-rules"], "split": "train"}
{"id": "egraph_match_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `apply-rules`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'rewrites)\n\n(define (local-helper x) x)\n\n  (define (apply-rules eg rules)\n    (let ([count 0])\n      (for-each\n       (lambda (root)\n         (for-each\n          (lambda (rule)\n            (if (apply-rule eg rule root)\n                (set! count (+ count 1))\n                #f))\n          rules))\n       (uf-roots (egraph-uf eg)))\n      count))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `apply-rules`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'rewrites)\n\n(define (local-helper x) x)\n\n  (define (apply-rules eg rules)\n    (let ([count 0])\n      (for-each\n       (lambda (root)\n         (for-each\n          (lambda (rule)\n            (if (apply-rule eg rule root)\n                (set! count (+ count 1))\n                #f))\n          rules))\n       (uf-roots (egraph-uf eg)))\n      count))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(+ b 0))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n(= (let* ([eg (make-egraph)]\n          [rules (list\n                   (make-rule '(+ ?x 0) '?x)\n                   (make-rule '(* ?x 1) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(* b 1))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "apply-rules"], "split": "train"}
{"id": "egraph_match_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: A pattern variable must start with ? and have at least one character after it.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (> (string-length s) 0))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: A pattern variable must start with ? and have at least one character after it.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (> (string-length s) 0))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-var?"], "split": "train"}
{"id": "egraph_match_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: The '?' marker must be the first character, not just present somewhere in the symbol.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s (- (string-length s) 1)) #\\?)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-var?` in `lattice/egraph/match.ss`.\nKnown issue: The '?' marker must be the first character, not just present somewhere in the symbol.\n\n```scheme\n(define (pattern-var? x)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s (- (string-length s) 1)) #\\?)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(pattern-var? '?x)\n(pattern-var? '?foo)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pattern-var? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is a pattern variable (symbol starting with ?).\")\n  (doc 'export #t)\n  (and (symbol? x)\n       (let ([s (symbol->string x)])\n         (and (> (string-length s) 1)\n              (char=? (string-ref s 0) #\\?)))))", "verify_expr": "(and (pattern-var? '?x) (pattern-var? '?foo) (not (pattern-var? 'x)) (not (pattern-var? 42)) (not (pattern-var? '?)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-var?"], "split": "train"}
{"id": "egraph_match_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: Conflicting rebinding must return #f, not append another binding.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (subst-extend subst var class-id)\n        (subst-extend subst var class-id))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: Conflicting rebinding must return #f, not append another binding.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (if existing\n        (subst-extend subst var class-id)\n        (subst-extend subst var class-id))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: When the variable is absent, extend with the new binding instead of leaving substitution unchanged.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) subst]\n      [(= existing class-id) subst]\n      [else #f])))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-try-extend` in `lattice/egraph/match.ss`.\nKnown issue: When the variable is absent, extend with the new binding instead of leaving substitution unchanged.\n\n```scheme\n(define (subst-try-extend subst var class-id)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) subst]\n      [(= existing class-id) subst]\n      [else #f])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(pair? s1)\n(pair? s2)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (subst-try-extend subst var class-id)\n  (doc 'type (-> Substitution PatternVar EClassId (Or Substitution #f)))\n  (doc 'description \"Try to extend substitution. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let ([existing (subst-lookup subst var)])\n    (cond\n      [(not existing) (subst-extend subst var class-id)]\n      [(= existing class-id) subst]\n      [else #f])))", "verify_expr": "(let* ([s0 (empty-subst)] [s1 (subst-try-extend s0 '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))] [s3 (and s1 (subst-try-extend s1 '?x 6))]) (and (pair? s1) (pair? s2) (not s3) (= (subst-lookup s1 '?x) 5)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-try-extend"], "split": "train"}
{"id": "egraph_match_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must detect conflicts and return #f on incompatible bindings.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (append subst1 subst2))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must detect conflicts and return #f on incompatible bindings.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (append subst1 subst2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-merge"], "split": "train"}
{"id": "egraph_match_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must preserve existing bindings from subst2, not rebuild from empty substitution.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result (empty-subst)])\n    (if (null? s1)\n        result\n        (let* ([b (car s1)]\n               [v (car b)]\n               [c (cdr b)]\n               [next (subst-try-extend result v c)])\n          (and next (loop (cdr s1) next))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `subst-merge` in `lattice/egraph/match.ss`.\nKnown issue: Merge must preserve existing bindings from subst2, not rebuild from empty substitution.\n\n```scheme\n(define (subst-merge subst1 subst2)\n  (let loop ([s1 subst1] [result (empty-subst)])\n    (if (null? s1)\n        result\n        (let* ([b (car s1)]\n               [v (car b)]\n               [c (cdr b)]\n               [next (subst-try-extend result v c)])\n          (and next (loop (cdr s1) next))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(pair? ok)\n(= (subst-lookup ok '?x) 1)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (subst-merge subst1 subst2)\n  (doc 'type (-> Substitution Substitution (Or Substitution #f)))\n  (doc 'description \"Merge two substitutions. Returns #f if incompatible.\")\n  (doc 'export #t)\n  (let loop ([s1 subst1] [result subst2])\n    (if (null? s1)\n        result\n        (let* ([binding (car s1)]\n               [var (car binding)]\n               [class-id (cdr binding)]\n               [new-result (subst-try-extend result var class-id)])\n          (if new-result\n              (loop (cdr s1) new-result)\n              #f)))))", "verify_expr": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [ok (subst-merge a b)] [c (subst-extend (empty-subst) '?x 1)] [d (subst-extend (empty-subst) '?x 3)] [bad (subst-merge c d)]) (and (pair? ok) (= (subst-lookup ok '?x) 1) (= (subst-lookup ok '?y) 2) (not bad)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "subst-merge"], "split": "train"}
{"id": "egraph_match_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: Leaf matching must verify operator equality and zero arity, not only class non-emptiness.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (if (pair? (egraph-class-nodes eg root))\n           (list subst)\n           '())]\n      [else '()])))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: Leaf matching must verify operator equality and zero arity, not only class non-emptiness.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (if (pair? (egraph-class-nodes eg root))\n           (list subst)\n           '())]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (length m1) 1)\n(null? m2)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(= (length m1) 1)\n(null? m2)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: For application patterns, every child pattern must be checked; matching only the first child is incorrect.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(pair? pattern)\n       (let* ([op (car pattern)]\n              [args (cdr pattern)]\n              [nodes (egraph-class-nodes eg root)]\n              [matching\n               (filter (lambda (node)\n                         (and (eqv? (enode-op node) op)\n                              (= (enode-arity node) (length args))))\n                       nodes)])\n         (append-map\n          (lambda (node)\n            (if (null? args)\n                (list subst)\n                (ematch-pattern eg (car args) (vector-ref (enode-children node) 0) subst)))\n          matching))]\n      [else '()])))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch-pattern` in `lattice/egraph/match.ss`.\nKnown issue: For application patterns, every child pattern must be checked; matching only the first child is incorrect.\n\n```scheme\n(define (ematch-pattern eg pattern class-id subst)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(pair? pattern)\n       (let* ([op (car pattern)]\n              [args (cdr pattern)]\n              [nodes (egraph-class-nodes eg root)]\n              [matching\n               (filter (lambda (node)\n                         (and (eqv? (enode-op node) op)\n                              (= (enode-arity node) (length args))))\n                       nodes)])\n         (append-map\n          (lambda (node)\n            (if (null? args)\n                (list subst)\n                (ematch-pattern eg (car args) (vector-ref (enode-children node) 0) subst)))\n          matching))]\n      [else '()])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (length m1) 1)\n(null? m2)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ematch-pattern eg pattern class-id subst)\n  (doc 'type (-> EGraph Pattern EClassId Substitution (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all valid substitutions.\")\n  (doc 'export #t)\n  (let ([root (egraph-find eg class-id)])\n    (cond\n      [(pattern-var? pattern)\n       (let ([new-subst (subst-try-extend subst pattern root)])\n         (if new-subst (list new-subst) '()))]\n      [(or (symbol? pattern) (number? pattern))\n       (let ([nodes (egraph-class-nodes eg root)])\n         (if (exists (lambda (node)\n                       (and (eqv? (enode-op node) pattern)\n                            (zero? (enode-arity node))))\n                     nodes)\n             (list subst)\n             '()))]\n      [(pair? pattern)\n       (let ([op (car pattern)]\n             [arg-patterns (cdr pattern)]\n             [nodes (egraph-class-nodes eg root)])\n         (let ([matching-nodes\n                (filter (lambda (node)\n                          (and (eqv? (enode-op node) op)\n                               (= (enode-arity node) (length arg-patterns))))\n                        nodes)])\n           (append-map (lambda (node)\n                         (ematch-children eg arg-patterns\n                                         (vector->list (enode-children node))\n                                         subst))\n                       matching-nodes)))]\n      [else '()])))", "verify_expr": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [m1 (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [m2 (ematch-pattern eg '(+ ?z ?z) id (empty-subst))]) (and (= (length m1) 1) (null? m2) (let* ([s (car m1)] [x (subst-lookup s '?x)] [y (subst-lookup s '?y)]) (and (integer? x) (integer? y) (not (= x y))))))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch-pattern"], "split": "train"}
{"id": "egraph_match_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: ematch must return all substitutions, not truncate to one.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([matches (ematch-pattern eg pattern class-id (empty-subst))])\n    (if (null? matches) '() (list (car matches)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: ematch must return all substitutions, not truncate to one.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (let ([matches (ematch-pattern eg pattern class-id (empty-subst))])\n    (if (null? matches) '() (list (car matches)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch"], "split": "train"}
{"id": "egraph_match_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: Matching should begin with an empty substitution, without introducing extraneous bindings.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (subst-extend (empty-subst) '?seed 0)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ematch` in `lattice/egraph/match.ss`.\nKnown issue: Matching should begin with an empty substitution, without introducing extraneous bindings.\n\n```scheme\n(define (ematch eg pattern class-id)\n  (ematch-pattern eg pattern class-id (subst-extend (empty-subst) '?seed 0)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [id (egraph-add-term! eg '(f x))]\n       [mv (ematch eg '?a id)]\n       [mf (ematch eg '(f ?z) id)]\n       [mg (ematch eg '(g ?z) id)]\n       [sv (and (pair? mv) (car mv))])\n  (and (= (length mv) 1)\n       (= (length mf) 1)\n       (null? mg)\n       sv\n       (not (subst-lookup sv '?seed))))\n(= (let* ([eg (make-egraph)]\n          [fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))])\n     (egraph-merge! eg fx fy)\n     (egraph-saturate-rebuild! eg)\n     (length (ematch eg '(f ?a) fx)))\n   2)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (ematch eg pattern class-id)\n  (doc 'type (-> EGraph Pattern EClassId (List Substitution)))\n  (doc 'description \"Match pattern against e-class, return all substitutions.\")\n  (doc 'export #t)\n  (ematch-pattern eg pattern class-id (empty-subst)))", "verify_expr": "(and (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f x))] [mv (ematch eg '?a id)] [mf (ematch eg '(f ?z) id)] [mg (ematch eg '(g ?z) id)] [sv (and (pair? mv) (car mv))]) (and (= (length mv) 1) (= (length mf) 1) (null? mg) sv (not (subst-lookup sv '?seed)))) (= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "ematch"], "split": "train"}
{"id": "egraph_match_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: If there are no matches, apply-rule must return #f.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #t\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: If there are no matches, apply-rule must return #f.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #t\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rule"], "split": "train"}
{"id": "egraph_match_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: New rhs term must be merged into the matched class-id, not merged with itself.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg rhs-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rule` in `lattice/egraph/match.ss`.\nKnown issue: New rhs term must be merged into the matched class-id, not merged with itself.\n\n```scheme\n(define (apply-rule eg rule class-id)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg rhs-id rhs-id))))\n           matches)\n          #t))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)]\n       [r (make-rule '(+ ?x 0) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))]\n       [a-id (egraph-add-term! eg 'a)]\n       [ok (apply-rule eg r term)])\n  (egraph-saturate-rebuild! eg)\n  (and ok (= (egraph-find eg term) (egraph-find eg a-id))))\n(let* ([eg (make-egraph)]\n       [r (make-rule '(* ?x 1) '?x)]\n       [term (egraph-add-term! eg '(+ a 0))])\n  (not (apply-rule eg r term)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (apply-rule eg rule class-id)\n  (doc 'type (-> EGraph Rule EClassId Boolean))\n  (doc 'description \"Apply rule to e-class. Returns #t if matched.\")\n  (doc 'export #t)\n  (let* ([lhs (rule-lhs rule)]\n         [rhs (rule-rhs rule)]\n         [matches (ematch eg lhs class-id)])\n    (if (null? matches)\n        #f\n        (begin\n          (for-each\n           (lambda (subst)\n             (let ([rhs-term (pattern-apply subst rhs)])\n               (let ([rhs-id (add-instantiated-term eg rhs-term)])\n                 (egraph-merge! eg class-id rhs-id))))\n           matches)\n          #t))))", "verify_expr": "(and (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rule"], "split": "train"}
{"id": "egraph_match_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Only successful apply-rule matches should increment count.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (apply-rule eg rule root)\n          (set! count (+ count 1)))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Only successful apply-rule matches should increment count.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (apply-rule eg rule root)\n          (set! count (+ count 1)))\n        rules))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(= (let* ([eg (make-egraph)]\n          [rules (list (make-rule '(+ ?x 0) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(+ b 0))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n(= (let* ([eg (make-egraph)]\n          [rules (list\n                   (make-rule '(+ ?x 0) '?x)\n                   (make-rule '(* ?x 1) '?x))]\n          [_1 (egraph-add-term! eg '(+ a 0))]\n          [_2 (egraph-add-term! eg '(* b 1))]\n          [count (apply-rules eg rules)])\n     count)\n   2)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rules"], "split": "train"}
{"id": "egraph_match_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Must apply every rule, not only the first rule in the list.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (when (pair? rules)\n         (when (apply-rule eg (car rules) root)\n           (set! count (+ count 1)))))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-rules` in `lattice/egraph/match.ss`.\nKnown issue: Must apply every rule, not only the first rule in the list.\n\n```scheme\n(define (apply-rules eg rules)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (when (pair? rules)\n         (when (apply-rule eg (car rules) root)\n           (set! count (+ count 1)))))\n     (uf-roots uf))\n    count))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (apply-rules eg rules)\n  (doc 'type (-> EGraph (List Rule) Nat))\n  (doc 'description \"Apply all rules to all e-classes once. Returns match count.\")\n  (doc 'export #t)\n  (let ([uf (egraph-uf eg)]\n        [count 0])\n    (for-each\n     (lambda (root)\n       (for-each\n        (lambda (rule)\n          (when (apply-rule eg rule root)\n            (set! count (+ count 1))))\n        rules))\n     (uf-roots uf))\n    count))", "verify_expr": "(and (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(+ b 0))] [count (apply-rules eg rules)]) count) 2) (= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [_1 (egraph-add-term! eg '(+ a 0))] [_2 (egraph-add-term! eg '(* b 1))] [count (apply-rules eg rules)]) count) 2))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "apply-rules"], "split": "train"}
{"id": "egraph_match_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Map pattern-var? over `(?x x ?foo ?)` and return the boolean list.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nMap pattern-var? over `(?x x ?foo ?)` and return the boolean list.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map pattern-var? '(?x x ?foo ?))", "verify_expr": "(equal? (map pattern-var? '(?x x ?foo ?)) '(#t #f #t #f))", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "mapping"], "split": "train"}
{"id": "egraph_match_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Extract normalized names from the pattern-variable subset of `(?left plus ?right ?tmp)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nExtract normalized names from the pattern-variable subset of `(?left plus ?right ?tmp)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp)))", "verify_expr": "(equal? (map pattern-var-name (filter pattern-var? '(?left plus ?right ?tmp))) '(left right tmp))", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "names"], "split": "train"}
{"id": "egraph_match_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Return whether all entries in `(?a ?b ?c)` are valid pattern variables.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether all entries in `(?a ?b ?c)` are valid pattern variables.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c))", "verify_expr": "(equal? (and (pattern-var? '?a) (pattern-var? '?b) (pattern-var? '?c)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "all-true"], "split": "train"}
{"id": "egraph_match_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Extend an empty substitution with `?x -> 7` and return the looked-up value for `?x`.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nExtend an empty substitution with `?x -> 7` and return the looked-up value for `?x`.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1))", "verify_expr": "(= (let ([s (subst-try-extend (empty-subst) '?x 7)]) (if s (subst-lookup s '?x) -1)) 7)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "insert"], "split": "train"}
{"id": "egraph_match_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Attempt to rebind `?x` from 2 to 3 and return whether the extension fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nAttempt to rebind `?x` from 2 to 3 and return whether the extension fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 2)] [s2 (and s1 (subst-try-extend s1 '?x 3))]) (not s2)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "conflict"], "split": "train"}
{"id": "egraph_match_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Extend with `?x -> 1`, then `?y -> 2`, then test whether changing `?y` to 3 fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtend with `?x -> 1`, then `?y -> 2`, then test whether changing `?y` to 3 fails.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3)))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 1)] [s2 (and s1 (subst-try-extend s1 '?y 2))] [s3 (and s2 (subst-try-extend s2 '?y 3))]) (and s2 (not s3))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "multi-var"], "split": "train"}
{"id": "egraph_match_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge `(?x . 1)` with `(?y . 2)` and return whether both bindings are present.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge `(?x . 1)` with `(?y . 2)` and return whether both bindings are present.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?y 2)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 1) (= (subst-lookup m '?y) 2))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "compatible"], "split": "train"}
{"id": "egraph_match_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge conflicting substitutions for `?x` and return whether merge fails.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge conflicting substitutions for `?x` and return whether merge fails.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 1)] [b (subst-extend (empty-subst) '?x 2)]) (not (subst-merge a b))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "conflict"], "split": "train"}
{"id": "egraph_match_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge overlapping substitutions where `?x` is consistent and verify both vars remain available.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge overlapping substitutions where `?x` is consistent and verify both vars remain available.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 3)] [b (subst-extend (subst-extend (empty-subst) '?x 3) '?z 9)] [m (subst-merge a b)]) (and m (= (subst-lookup m '?x) 3) (= (subst-lookup m '?z) 9))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "overlap"], "split": "train"}
{"id": "egraph_match_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match repeated-var pattern `(+ ?a ?a)` against `(+ x y)` and return whether it fails.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch repeated-var pattern `(+ ?a ?a)` against `(+ x y)` and return whether it fails.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x y))]) (null? (ematch-pattern eg '(+ ?a ?a) id (empty-subst)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "repeated-var"], "split": "train"}
{"id": "egraph_match_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match leaf pattern `x` against class for `x` and return whether exactly one substitution is returned.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMatch leaf pattern `x` against class for `x` and return whether exactly one substitution is returned.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [ms (ematch-pattern eg 'x id (empty-subst))]) (= (length ms) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "leaf"], "split": "train"}
{"id": "egraph_match_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match wrong operator `(* ?x ?y)` against `(+ a b)` and return whether no matches are produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch wrong operator `(* ?x ?y)` against `(+ a b)` and return whether no matches are produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))]) (null? (ematch-pattern eg '(* ?x ?y) id (empty-subst)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "op-mismatch"], "split": "train"}
{"id": "egraph_match_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Run `ematch` with variable pattern `?v` on class of `x` and return whether there is one match.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun `ematch` with variable pattern `?v` on class of `x` and return whether there is one match.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)]) (= (length (ematch eg '?v x)) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "variable"], "split": "train"}
{"id": "egraph_match_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Compare `ematch` vs `ematch-pattern` on `(f ?x)` for class `(f a)` and return whether they agree on match count.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompare `ematch` vs `ematch-pattern` on `(f ?x)` for class `(f a)` and return whether they agree on match count.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))] [m1 (ematch eg '(f ?x) id)] [m2 (ematch-pattern eg '(f ?x) id (empty-subst))]) (= (length m1) (length m2)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))] [m1 (ematch eg '(f ?x) id)] [m2 (ematch-pattern eg '(f ?x) id (empty-subst))]) (= (length m1) (length m2))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "wrapper-consistency", "multi-fn"], "split": "train"}
{"id": "egraph_match_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Run `ematch` for `(g ?x)` on class of `(f a)` and return whether it fails.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun `ematch` for `(g ?x)` on class of `(f a)` and return whether it fails.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f a))]) (null? (ematch eg '(g ?x) id))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "mismatch"], "split": "train"}
{"id": "egraph_match_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution `{?x->5}` to `?x` and return whether output is an eclass-ref with id 5.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution `{?x->5}` to `?x` and return whether output is an eclass-ref with id 5.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5)))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "var-instantiate"], "split": "train"}
{"id": "egraph_match_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution on `(+ ?x ?y)` and return whether both children are eclass refs.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution on `(+ ?x ?y)` and return whether both children are eclass refs.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r))))", "verify_expr": "(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "compound"], "split": "train"}
{"id": "egraph_match_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution to `(f ?x 42)` and return whether literal 42 is preserved.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply substitution to `(f ?x 42)` and return whether literal 42 is preserved.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "literal-preserve"], "split": "train"}
{"id": "egraph_match_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Apply substitution to nested pattern `(f (g ?x))` and return whether nested arg is an eclass-ref.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply substitution to nested pattern `(f (g ?x))` and return whether nested arg is an eclass-ref.\n\nEnsure `pattern-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r))))", "verify_expr": "(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-apply", "nested"], "split": "train"}
{"id": "egraph_match_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply `(+ ?x 0) => ?x` to class of `(+ a 0)` and return whether it becomes equivalent to `a`.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply `(+ ?x 0) => ?x` to class of `(+ a 0)` and return whether it becomes equivalent to `a`.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '(+ ?x 0) '?x)] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)] [ok (apply-rule eg r term)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg term) (egraph-find eg a-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "identity"], "split": "train"}
{"id": "egraph_match_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply commutativity rule `(+ ?x ?y) => (+ ?y ?x)` to `(+ a b)` and return class node count after rebuild.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nApply commutativity rule `(+ ?x ?y) => (+ ?y ?x)` to `(+ a b)` and return class node count after rebuild.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term)))", "verify_expr": "(= (let* ([eg (make-egraph)] [r (make-rule '(+ ?x ?y) '(+ ?y ?x))] [term (egraph-add-term! eg '(+ a b))]) (apply-rule eg r term) (egraph-saturate-rebuild! eg) (length (egraph-class-nodes eg term))) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "commutativity"], "split": "train"}
{"id": "egraph_match_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply expansion rule `?x => (+ ?x 0)` to `a` and return whether `a` becomes equivalent to `(+ a 0)`.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply expansion rule `?x => (+ ?x 0)` to `a` and return whether `a` becomes equivalent to `(+ a 0)`.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '?x '(+ ?x 0))] [a-id (egraph-add-term! eg 'a)] [sum-id (egraph-add-term! eg '(+ a 0))] [ok (apply-rule eg r a-id)]) (egraph-saturate-rebuild! eg) (and ok (= (egraph-find eg a-id) (egraph-find eg sum-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "expansion"], "split": "train"}
{"id": "egraph_match_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Run two simplification rules once, then confirm both rewritten terms are equivalent to their simplified symbols.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun two simplification rules once, then confirm both rewritten terms are equivalent to their simplified symbols.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [ta (egraph-add-term! eg '(+ a 0))] [tb (egraph-add-term! eg '(* b 1))] [a-id (egraph-add-term! eg 'a)] [b-id (egraph-add-term! eg 'b)] [count (apply-rules eg rules)]) (egraph-saturate-rebuild! eg) (and (= count 2) (= (egraph-find eg ta) (egraph-find eg a-id)) (= (egraph-find eg tb) (egraph-find eg b-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))] [ta (egraph-add-term! eg '(+ a 0))] [tb (egraph-add-term! eg '(* b 1))] [a-id (egraph-add-term! eg 'a)] [b-id (egraph-add-term! eg 'b)] [count (apply-rules eg rules)]) (egraph-saturate-rebuild! eg) (and (= count 2) (= (egraph-find eg ta) (egraph-find eg a-id)) (= (egraph-find eg tb) (egraph-find eg b-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "rewrite-effect", "multi-fn"], "split": "train"}
