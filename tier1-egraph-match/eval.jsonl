{"id": "egraph_match_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-apply`\nSpec: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nWrite exactly one Scheme definition for `pattern-apply`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-apply`\nSpec: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nWrite exactly one Scheme definition for `pattern-apply`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-apply subst pattern)\n  ;; TODO: replace pattern vars with eclass refs and recurse through pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-apply`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-apply subst pattern)\n  ;; TODO: replace pattern vars with eclass refs and recurse through pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-apply`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Implement `pattern-apply` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `pattern-apply` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-apply`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-apply`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_017", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n   [(pattern-var? pattern)\n    (let ([bound (subst-lookup subst pattern)])\n      (if bound\n          (make-eclass-ref bound)\n          (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n   [(pair? pattern)\n    (let ([head (car pattern)]\n          [tail (cdr pattern)])\n      (cons head\n            (map (lambda (part)\n                   (pattern-apply subst part))\n                 tail)))]\n   [else pattern]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n   [(pattern-var? pattern)\n    (let ([bound (subst-lookup subst pattern)])\n      (if bound\n          (make-eclass-ref bound)\n          (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n   [(pair? pattern)\n    (let ([head (car pattern)]\n          [tail (cdr pattern)])\n      (cons head\n            (map (lambda (part)\n                   (pattern-apply subst part))\n                 tail)))]\n   [else pattern]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `pattern-apply`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'instantiation)\n\n(define (local-helper x) x)\n\n  (define (pattern-apply subst pattern)\n    (cond\n     [(pattern-var? pattern)\n      (let ([bound (subst-lookup subst pattern)])\n        (if bound\n            (make-eclass-ref bound)\n            (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n     [(pair? pattern)\n      (let ([head (car pattern)]\n            [tail (cdr pattern)])\n        (cons head\n              (map (lambda (part)\n                     (pattern-apply subst part))\n                   tail)))]\n     [else pattern]))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `pattern-apply`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/match.ss excerpt\n(require 'prelude)\n(require 'egraph/core)\n(require 'egraph/union-find)\n\n(doc 'module 'egraph/match)\n(doc 'section 'instantiation)\n\n(define (local-helper x) x)\n\n  (define (pattern-apply subst pattern)\n    (cond\n     [(pattern-var? pattern)\n      (let ([bound (subst-lookup subst pattern)])\n        (if bound\n            (make-eclass-ref bound)\n            (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n     [(pair? pattern)\n      (let ([head (car pattern)]\n            [tail (cdr pattern)])\n        (cons head\n              (map (lambda (part)\n                     (pattern-apply subst part))\n                   tail)))]\n     [else pattern]))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "source-excerpt-to-fold", "doc-free-target", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Variable replacements must be wrapped with make-eclass-ref to disambiguate from numeric literals.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           binding\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Variable replacements must be wrapped with make-eclass-ref to disambiguate from numeric literals.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           binding\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Bound pattern variables must be substituted, not left unchanged.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     pattern]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Bound pattern variables must be substituted, not left unchanged.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     pattern]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (car t) '+)\n(eclass-ref? (cadr t))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42)))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Count how many entries are pattern variables in the list `(?x y ?z 10 ?foo)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount how many entries are pattern variables in the list `(?x y ?z 10 ?foo)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(length (filter pattern-var? '(?x y ?z 10 ?foo)))", "verify_expr": "(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "counting"], "split": "eval"}
{"id": "egraph_match_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Build a substitution with `subst-try-extend`, merge in `?z -> 9`, and verify all bindings survive.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a substitution with `subst-try-extend`, merge in `?z -> 9`, and verify all bindings survive.\n\nEnsure `subst-try-extend` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?y 8))] [m (and s2 (subst-merge s2 (subst-extend (empty-subst) '?z 9)))]) (and m (= (subst-lookup m '?x) 5) (= (subst-lookup m '?y) 8) (= (subst-lookup m '?z) 9)))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?y 8))] [m (and s2 (subst-merge s2 (subst-extend (empty-subst) '?z 9)))]) (and m (= (subst-lookup m '?x) 5) (= (subst-lookup m '?y) 8) (= (subst-lookup m '?z) 9))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "multi-fn", "merge"], "split": "eval"}
{"id": "egraph_match_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Create one substitution via `subst-try-extend`, merge with another, and verify all three variables are preserved.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate one substitution via `subst-try-extend`, merge with another, and verify all three variables are preserved.\n\nEnsure `subst-merge` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a0 (subst-try-extend (empty-subst) '?x 7)] [a (and a0 (subst-try-extend a0 '?y 8))] [b (subst-try-extend (empty-subst) '?z 9)] [m (and a b (subst-merge a b))]) (and m (= (subst-lookup m '?x) 7) (= (subst-lookup m '?y) 8) (= (subst-lookup m '?z) 9)))", "verify_expr": "(equal? (let* ([a0 (subst-try-extend (empty-subst) '?x 7)] [a (and a0 (subst-try-extend a0 '?y 8))] [b (subst-try-extend (empty-subst) '?z 9)] [m (and a b (subst-merge a b))]) (and m (= (subst-lookup m '?x) 7) (= (subst-lookup m '?y) 8) (= (subst-lookup m '?z) 9))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "multi-fn", "transitive"], "split": "eval"}
{"id": "egraph_match_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match `(+ ?x ?y)` against `(+ a b)`, then instantiate `(+ ?y ?x)` from the first substitution.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch `(+ ?x ?y)` against `(+ a b)`, then instantiate `(+ ?y ?x)` from the first substitution.\n\nEnsure `ematch-pattern` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [s (and (pair? ms) (car ms))] [rhs (and s (pattern-apply s '(+ ?y ?x)))]) (and s (pair? rhs) (eq? (car rhs) '+) (eclass-ref? (cadr rhs)) (eclass-ref? (caddr rhs))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))] [s (and (pair? ms) (car ms))] [rhs (and s (pattern-apply s '(+ ?y ?x)))]) (and s (pair? rhs) (eq? (car rhs) '+) (eclass-ref? (cadr rhs)) (eclass-ref? (caddr rhs)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "compound", "multi-fn"], "split": "eval"}
{"id": "egraph_match_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Merge classes of `(f x)` and `(f y)`, then count matches of `(f ?a)` from merged class.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge classes of `(f x)` and `(f y)`, then count matches of `(f ?a)` from merged class.\n\nEnsure `ematch` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx)))", "verify_expr": "(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "merged-class"], "split": "eval"}
{"id": "egraph_match_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply `(* ?x 1) => ?x` to class of `(+ a 0)` and return whether no match is reported.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply `(* ?x 1) => ?x` to class of `(+ a 0)` and return whether no match is reported.\n\nEnsure `apply-rule` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "no-match"], "split": "eval"}
{"id": "egraph_match_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Apply a commutativity+identity rule set and check that `ematch` can still find an addition shape in the rewritten class.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply a commutativity+identity rule set and check that `ematch` can still find an addition shape in the rewritten class.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x ?y) '(+ ?y ?x)) (make-rule '(+ ?x 0) '?x))] [t (egraph-add-term! eg '(+ a 0))]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (>= (length (ematch eg '(+ ?u ?v) t)) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x ?y) '(+ ?y ?x)) (make-rule '(+ ?x 0) '?x))] [t (egraph-add-term! eg '(+ a 0))]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (>= (length (ematch eg '(+ ?u ?v) t)) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "post-match", "multi-fn"], "split": "eval"}
{"id": "egraph_match_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Run a simplification rule set over non-matching terms and return whether the sweep records zero matches.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun a simplification rule set over non-matching terms and return whether the sweep records zero matches.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 1)) (egraph-add-term! eg '(* b 2)) (= (apply-rules eg rules) 0))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 1)) (egraph-add-term! eg '(* b 2)) (= (apply-rules eg rules) 0)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "no-op-sweep"], "split": "eval"}
{"id": "egraph_match_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Use `apply-rules` first, then a direct `apply-rule` call, and verify both rewrites contribute to expected equivalences.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse `apply-rules` first, then a direct `apply-rule` call, and verify both rewrites contribute to expected equivalences.\n\nEnsure `apply-rules` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [sum (egraph-add-term! eg '(+ a 0))] [prod (egraph-add-term! eg '(* b 1))] [a-id (egraph-add-term! eg 'a)] [b-id (egraph-add-term! eg 'b)] [extra (make-rule '(* ?x 1) '?x)] [count (apply-rules eg rules)] [ok2 (apply-rule eg extra prod)]) (egraph-saturate-rebuild! eg) (and (= count 1) ok2 (= (egraph-find eg sum) (egraph-find eg a-id)) (= (egraph-find eg prod) (egraph-find eg b-id))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [sum (egraph-add-term! eg '(+ a 0))] [prod (egraph-add-term! eg '(* b 1))] [a-id (egraph-add-term! eg 'a)] [b-id (egraph-add-term! eg 'b)] [extra (make-rule '(* ?x 1) '?x)] [count (apply-rules eg rules)] [ok2 (apply-rule eg extra prod)]) (egraph-saturate-rebuild! eg) (and (= count 1) ok2 (= (egraph-find eg sum) (egraph-find eg a-id)) (= (egraph-find eg prod) (egraph-find eg b-id)))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "staged-rewrite", "multi-fn"], "split": "eval"}
