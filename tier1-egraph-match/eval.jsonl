{"id": "egraph_match_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Implement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-apply`\nSpec: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nWrite exactly one Scheme definition for `pattern-apply`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph matching utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/match.ss\nFunction: `pattern-apply`\nSpec: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nWrite exactly one Scheme definition for `pattern-apply`.\nReturn only code, no explanation.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend (empty-subst) '?x 4)]\n         [r (pattern-apply s '(f (g ?x)))])\n    (eclass-ref? (cadr (cadr r))))\n  #t)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t) (equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "spec-to-code", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-apply subst pattern)\n  ;; TODO: replace pattern vars with eclass refs and recurse through pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-apply`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (pattern-apply subst pattern)\n  ;; TODO: replace pattern vars with eclass refs and recurse through pairs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pattern-apply`.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend (empty-subst) '?x 5)]\n         [r (pattern-apply s '?x)])\n    (and (eclass-ref? r) (= (eclass-ref-id r) 5)))\n  #t)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "skeleton-completion", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Implement `pattern-apply` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `pattern-apply` from this contract.\n\nModule: `lattice/egraph/match.ss`\nContract focus: Instantiate a pattern using substitution bindings, wrapping variable replacements as eclass refs.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve behavior for edge cases in matching/rewriting.\n3. Return only one production-ready definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t) (equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "contract-implementation", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-apply`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `pattern-apply`.\nReturn only the Scheme definition.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend (empty-subst) '?x 4)]\n         [r (pattern-apply s '(f (g ?x)))])\n    (eclass-ref? (cadr (cadr r))))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "python-to-scheme", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n   [(pattern-var? pattern)\n    (let ([binding (subst-lookup subst pattern)])\n      (if binding\n          (make-eclass-ref binding)\n          (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n   [(pair? pattern)\n    (cons (car pattern)\n          (map (lambda (p) (pattern-apply subst p))\n               (cdr pattern)))]\n   [else pattern]))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `pattern-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n   [(pattern-var? pattern)\n    (let ([binding (subst-lookup subst pattern)])\n      (if binding\n          (make-eclass-ref binding)\n          (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n   [(pair? pattern)\n    (cons (car pattern)\n          (map (lambda (p) (pattern-apply subst p))\n               (cdr pattern)))]\n   [else pattern]))\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend (empty-subst) '?x 5)]\n         [r (pattern-apply s '?x)])\n    (and (eclass-ref? r) (= (eclass-ref-id r) 5)))\n  #t)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "chez-to-fold", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Translate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `pattern-apply`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the reference implementation to idiomatic Fold Scheme.\n\nTarget module: `lattice/egraph/match.ss`\nTarget function: `pattern-apply`\n\nConstraints:\n- Preserve observable behavior exactly.\n- Keep the same function name/signature.\n- Return only code.\n\n```python\ndef pattern_apply(subst, pattern):\n    if pattern_var(pattern):\n        cid = subst_lookup(subst, pattern)\n        if cid is None:\n            raise ValueError('unbound pattern variable')\n        return make_eclass_ref(cid)\n    if isinstance(pattern, list):\n        return [pattern[0]] + [pattern_apply(subst, p) for p in pattern[1:]]\n    return pattern\n```\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend\n              (subst-extend (empty-subst) '?x 1)\n              '?y\n              2)]\n         [r (pattern-apply s '(+ ?x ?y))])\n    (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r))))\n  #t)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t) (equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "reference-translation", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Variable replacements must be wrapped with make-eclass-ref to disambiguate from numeric literals.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           binding\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Variable replacements must be wrapped with make-eclass-ref to disambiguate from numeric literals.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           binding\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t)\n```\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (empty-subst) '?x 5)] [r (pattern-apply s '?x)]) (and (eclass-ref? r) (= (eclass-ref-id r) 5))) #t) (equal? (let* ([s (subst-extend (empty-subst) '?x 4)] [r (pattern-apply s '(f (g ?x)))]) (eclass-ref? (cadr (cadr r)))) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Bound pattern variables must be substituted, not left unchanged.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     pattern]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pattern-apply` in `lattice/egraph/match.ss`.\nKnown issue: Bound pattern variables must be substituted, not left unchanged.\n\n```scheme\n(define (pattern-apply subst pattern)\n  (cond\n    [(pattern-var? pattern)\n     pattern]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))\n```\n\nReturn only the corrected definition.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t)\n```\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (subst-extend\n            (subst-extend (empty-subst) '?x 1)\n            '?y\n            2)]\n       [t (pattern-apply s '(+ ?x ?y 42))])\n  (and (eq? (car t) '+)\n       (eclass-ref? (cadr t))\n       (= (eclass-ref-id (cadr t)) 1)\n       (eclass-ref? (caddr t))\n       (= (eclass-ref-id (caddr t)) 2)\n       (= (cadddr t) 42)))\n(equal?\n  (let* ([s (subst-extend\n              (subst-extend (empty-subst) '?x 1)\n              '?y\n              2)]\n         [r (pattern-apply s '(+ ?x ?y))])\n    (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r))))\n  #t)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (pattern-apply subst pattern)\n  (doc 'type (-> Substitution Pattern Term))\n  (doc 'description \"Apply substitution to pattern, yielding a term with e-class refs.\")\n  (doc 'export #t)\n  (cond\n    [(pattern-var? pattern)\n     (let ([binding (subst-lookup subst pattern)])\n       (if binding\n           (make-eclass-ref binding)\n           (error 'pattern-apply \"Unbound pattern variable\" pattern)))]\n    [(pair? pattern)\n     (cons (car pattern)\n           (map (lambda (p) (pattern-apply subst p))\n                (cdr pattern)))]\n    [else pattern]))", "verify_expr": "(and (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [t (pattern-apply s '(+ ?x ?y 42))]) (and (eq? (car t) '+) (eclass-ref? (cadr t)) (= (eclass-ref-id (cadr t)) 1) (eclass-ref? (caddr t)) (= (eclass-ref-id (caddr t)) 2) (= (cadddr t) 42))) (equal? (let* ([s (subst-extend (subst-extend (empty-subst) '?x 1) '?y 2)] [r (pattern-apply s '(+ ?x ?y))]) (and (eclass-ref? (cadr r)) (eclass-ref? (caddr r)))) #t) (equal? (let* ([s (subst-extend (empty-subst) '?x 9)] [r (pattern-apply s '(f ?x 42))]) (= (caddr r) 42)) #t))", "tags": ["tier1", "egraph", "matching", "rewrite", "bugfix", "pattern-apply"], "split": "eval"}
{"id": "egraph_match_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "pattern-var?", "prompt_body": "Count how many entries are pattern variables in the list `(?x y ?z 10 ?foo)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount how many entries are pattern variables in the list `(?x y ?z 10 ?foo)`.\n\nEnsure `pattern-var?` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(length (filter pattern-var? '(?x y ?z 10 ?foo)))", "verify_expr": "(= (length (filter pattern-var? '(?x y ?z 10 ?foo))) 3)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "pattern-var?", "counting"], "split": "eval"}
{"id": "egraph_match_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-try-extend", "prompt_body": "Bind `?x -> 5`, then bind `?x -> 5` again, and return whether both states remain valid.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nBind `?x -> 5`, then bind `?x -> 5` again, and return whether both states remain valid.\n\nEnsure `subst-try-extend` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5)))", "verify_expr": "(equal? (let* ([s1 (subst-try-extend (empty-subst) '?x 5)] [s2 (and s1 (subst-try-extend s1 '?x 5))]) (and (pair? s1) (pair? s2) (= (subst-lookup s2 '?x) 5))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-try-extend", "idempotent"], "split": "eval"}
{"id": "egraph_match_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "subst-merge", "prompt_body": "Merge three substitutions transitively and return whether final lookup for `?y` is 8.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge three substitutions transitively and return whether final lookup for `?y` is 8.\n\nEnsure `subst-merge` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8)))", "verify_expr": "(equal? (let* ([a (subst-extend (empty-subst) '?x 7)] [b (subst-extend (empty-subst) '?y 8)] [c (subst-merge a b)] [d (and c (subst-merge c (subst-extend (empty-subst) '?z 9)))]) (and d (= (subst-lookup d '?y) 8))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "subst-merge", "transitive"], "split": "eval"}
{"id": "egraph_match_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch-pattern", "prompt_body": "Match `(+ ?x ?y)` against `(+ a b)` and return whether one substitution is produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatch `(+ ?x ?y)` against `(+ a b)` and return whether one substitution is produced.\n\nEnsure `ematch-pattern` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [ms (ematch-pattern eg '(+ ?x ?y) id (empty-subst))]) (= (length ms) 1)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch-pattern", "compound"], "split": "eval"}
{"id": "egraph_match_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "ematch", "prompt_body": "Merge classes of `(f x)` and `(f y)`, then count matches of `(f ?a)` from merged class.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge classes of `(f x)` and `(f y)`, then count matches of `(f ?a)` from merged class.\n\nEnsure `ematch` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)\n```\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx)))", "verify_expr": "(= (let* ([eg (make-egraph)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg fx fy) (egraph-saturate-rebuild! eg) (length (ematch eg '(f ?a) fx))) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "ematch", "merged-class"], "split": "eval"}
{"id": "egraph_match_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rule", "prompt_body": "Apply `(* ?x 1) => ?x` to class of `(+ a 0)` and return whether no match is reported.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply `(* ?x 1) => ?x` to class of `(+ a 0)` and return whether no match is reported.\n\nEnsure `apply-rule` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [r (make-rule '(* ?x 1) '?x)] [term (egraph-add-term! eg '(+ a 0))]) (not (apply-rule eg r term))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rule", "no-match"], "split": "eval"}
{"id": "egraph_match_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Run apply-rules with only `(* ?x 1) => ?x` against `(+ a 0)`; return whether count is zero.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun apply-rules with only `(* ?x 1) => ?x` against `(+ a 0)`; return whether count is zero.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)\n```\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (= (apply-rules eg rules) 0)) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "zero"], "split": "eval"}
{"id": "egraph_match_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Apply two rules (`(+ ?x 0)=>?x` and `(* ?x 1)=>?x`) on matching terms and return total match count.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply two rules (`(+ ?x 0)=>?x` and `(* ?x 1)=>?x`) on matching terms and return total match count.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules))", "verify_expr": "(= (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x) (make-rule '(* ?x 1) '?x))]) (egraph-add-term! eg '(+ a 0)) (egraph-add-term! eg '(* b 1)) (apply-rules eg rules)) 2)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "multi-rule"], "split": "eval"}
{"id": "egraph_match_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/match.ss", "source_test": "lattice/egraph/test-match.ss", "source_function": "apply-rules", "prompt_body": "Use apply-rules with `(+ ?x 0)=>?x` on `(+ a 0)` then rebuild; return whether term is equivalent to `a`.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse apply-rules with `(+ ?x 0)=>?x` on `(+ a 0)` then rebuild; return whether term is equivalent to `a`.\n\nEnsure `apply-rules` is part of the composed solution.\nBehavior check to satisfy:\n```scheme\n(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)\n```\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [rules (list (make-rule '(+ ?x 0) '?x))] [term (egraph-add-term! eg '(+ a 0))] [a-id (egraph-add-term! eg 'a)]) (apply-rules eg rules) (egraph-saturate-rebuild! eg) (= (egraph-find eg term) (egraph-find eg a-id))) #t)", "tags": ["tier1", "egraph", "matching", "rewrite", "composition", "apply-rules", "rewrite-effect"], "split": "eval"}
