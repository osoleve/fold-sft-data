{"id": "optics_bidirectional_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-chain`\nSpec: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nWrite exactly one Scheme definition for `migration-chain`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-chain`\nSpec: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nWrite exactly one Scheme definition for `migration-chain`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-chain migrations)\n  ;; TODO: reject empty input; compose the list into a single migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-chain`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-chain migrations)\n  ;; TODO: reject empty input; compose the list into a single migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-chain`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Implement `migration-chain` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `migration-chain` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-flip`\nSpec: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nWrite exactly one Scheme definition for `migration-flip`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-flip`\nSpec: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nWrite exactly one Scheme definition for `migration-flip`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-flip m)\n  ;; TODO: swap endpoints and invert iso direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-flip`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-flip m)\n  ;; TODO: swap endpoints and invert iso direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-flip`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Implement `migration-flip` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `migration-flip` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-chain`.\nReturn only the Scheme definition.\n\n```python\ndef migration_chain(ms):\n    if len(ms) == 0:\n        raise ValueError((\"migration-chain\", \"Empty migration list\"))\n    if len(ms) == 1:\n        return ms[0]\n\n    acc = ms[0]\n    for m in ms[1:]:\n        acc = migration_compose(acc, m)\n    return acc\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-chain`.\nReturn only the Scheme definition.\n\n```python\ndef migration_chain(ms):\n    if len(ms) == 0:\n        raise ValueError((\"migration-chain\", \"Empty migration list\"))\n    if len(ms) == 1:\n        return ms[0]\n\n    acc = ms[0]\n    for m in ms[1:]:\n        acc = migration_compose(acc, m)\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-chain`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-chain ms)\n  (cond\n    [(null? ms)\n     (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr ms))\n     (car ms)]\n    [else\n     (fold-left migration-compose (car ms) (cdr ms))]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-chain`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-chain ms)\n  (cond\n    [(null? ms)\n     (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr ms))\n     (car ms)]\n    [else\n     (fold-left migration-compose (car ms) (cdr ms))]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-chain`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-chain ms)\n    (cond\n      [(null? ms)\n       (error 'migration-chain \"Empty migration list\")]\n      [(null? (cdr ms))\n       (car ms)]\n      [else\n       (fold-left migration-compose (car ms) (cdr ms))]))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-chain`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-chain ms)\n    (cond\n      [(null? ms)\n       (error 'migration-chain \"Empty migration list\")]\n      [(null? (cdr ms))\n       (car ms)]\n      [else\n       (fold-left migration-compose (car ms) (cdr ms))]))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_019", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-flip`.\nReturn only the Scheme definition.\n\n```python\ndef migration_flip(migration):\n    iso_obj = migration_iso(migration)\n    flipped = make_p_iso(p_iso_backward(iso_obj), p_iso_forward(iso_obj))\n    name = symbol(f\"{migration_name(migration)}-reversed\")\n    return make_migration(name, migration_to(migration), migration_from(migration), flipped)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-flip`.\nReturn only the Scheme definition.\n\n```python\ndef migration_flip(migration):\n    iso_obj = migration_iso(migration)\n    flipped = make_p_iso(p_iso_backward(iso_obj), p_iso_forward(iso_obj))\n    name = symbol(f\"{migration_name(migration)}-reversed\")\n    return make_migration(name, migration_to(migration), migration_from(migration), flipped)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-flip`.\nReturn only the final Fold definition.\n\n```scheme\n(define (invert-migration m)\n  (let* ([iso (migration-iso m)]\n         [reversed (make-p-iso (p-iso-backward iso)\n                               (p-iso-forward iso))]\n         [name (string->symbol\n                (format \"~a-reversed\" (migration-name m)))])\n    (make-migration name\n                    (migration-to m)\n                    (migration-from m)\n                    reversed)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-flip`.\nReturn only the final Fold definition.\n\n```scheme\n(define (invert-migration m)\n  (let* ([iso (migration-iso m)]\n         [reversed (make-p-iso (p-iso-backward iso)\n                               (p-iso-forward iso))]\n         [name (string->symbol\n                (format \"~a-reversed\" (migration-name m)))])\n    (make-migration name\n                    (migration-to m)\n                    (migration-from m)\n                    reversed)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_021", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-flip`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'reversal)\n\n(define (passthrough x) x)\n\n  (define (invert-migration m)\n    (let* ([iso (migration-iso m)]\n           [reversed (make-p-iso (p-iso-backward iso)\n                                 (p-iso-forward iso))]\n           [name (string->symbol\n                  (format \"~a-reversed\" (migration-name m)))])\n      (make-migration name\n                      (migration-to m)\n                      (migration-from m)\n                      reversed)))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-flip`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'reversal)\n\n(define (passthrough x) x)\n\n  (define (invert-migration m)\n    (let* ([iso (migration-iso m)]\n           [reversed (make-p-iso (p-iso-backward iso)\n                                 (p-iso-forward iso))]\n           [name (string->symbol\n                  (format \"~a-reversed\" (migration-name m)))])\n      (make-migration name\n                      (migration-to m)\n                      (migration-from m)\n                      reversed)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Empty migration lists must raise an error, not return #f.\n\n```scheme\n(define (migration-chain migrations)\n  (if (null? migrations)\n      #f\n      (fold-left migration-compose (car migrations) (cdr migrations))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Empty migration lists must raise an error, not return #f.\n\n```scheme\n(define (migration-chain migrations)\n  (if (null? migrations)\n      #f\n      (fold-left migration-compose (car migrations) (cdr migrations))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Using fold-right with this seed changes composition semantics and can break endpoints.\n\n```scheme\n(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [else (fold-right migration-compose (car migrations) (cdr migrations))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Using fold-right with this seed changes composition semantics and can break endpoints.\n\n```scheme\n(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [else (fold-right migration-compose (car migrations) (cdr migrations))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migrations must swap from/to versions and derive a reversed name.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))])\n    (make-migration (migration-name m)\n                    (migration-from m)\n                    (migration-to m)\n                    flipped-iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migrations must swap from/to versions and derive a reversed name.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))])\n    (make-migration (migration-name m)\n                    (migration-from m)\n                    (migration-to m)\n                    flipped-iso)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migration must invert the iso direction, not reuse original iso.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)\n                    (migration-from m)\n                    iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migration must invert the iso direction, not reuse original iso.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)\n                    (migration-from m)\n                    iso)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Construct a migration and return its record tag symbol.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a migration and return its record tag symbol.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)))", "verify_expr": "(equal? (car (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))) 'migration)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "record"], "split": "eval"}
{"id": "optics_bidirectional_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Compose +1 then *2 migrations and migrate input 4 through the composed migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose +1 then *2 migrations and migrate input 4 through the composed migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 4))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 4)) 10)", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "compose"], "split": "eval"}
{"id": "optics_bidirectional_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Map rollback across prefixed strings using a prefix migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap rollback across prefixed strings using a prefix migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s))))]) (map (lambda (s) (rollback m s)) '(\"v2:a\" \"v2:bc\")))", "verify_expr": "(equal? (let ([m (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s))))]) (map (lambda (s) (rollback m s)) '(\"v2:a\" \"v2:bc\"))) '(\"a\" \"bc\"))", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "map"], "split": "eval"}
{"id": "optics_bidirectional_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Compose +1 then *2 migrations and apply the composed migration forward to 3.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose +1 then *2 migrations and apply the composed migration forward to 3.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migration-apply m3 3 'forward))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migration-apply m3 3 'forward)) 8)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "compose"], "split": "eval"}
{"id": "optics_bidirectional_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Check associative behavior by comparing left- and right-associated migration-compose results on input 6.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck associative behavior by comparing left- and right-associated migration-compose results on input 6.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso sub1 add1))] [left (migration-compose (migration-compose m1 m2) m3)] [right (migration-compose m1 (migration-compose m2 m3))]) (= (migrate left 6) (migrate right 6)))", "verify_expr": "(equal? (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso sub1 add1))] [left (migration-compose (migration-compose m1 m2) m3)] [right (migration-compose m1 (migration-compose m2 m3))]) (= (migrate left 6) (migrate right 6))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "associative"], "split": "eval"}
{"id": "optics_bidirectional_composition_038", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Create a migration from functions and test its version endpoints against v1->v2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate a migration from functions and test its version endpoints against v1->v2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (make-migration-from-functions 'num 'v1 'v2 add1 sub1)]) (migration-versions-match? m 'v1 'v2))", "verify_expr": "(equal? (let ([m (make-migration-from-functions 'num 'v1 'v2 add1 sub1)]) (migration-versions-match? m 'v1 'v2)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "versions"], "split": "eval"}
{"id": "optics_bidirectional_composition_044", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Compose increment then identity migration and rollback input 9.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose increment then identity migration and rollback input 9.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (rollback m3 9))", "verify_expr": "(= (let* ([m1 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (rollback m3 9)) 8)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "compose-right"], "split": "eval"}
{"id": "optics_bidirectional_composition_049", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Flip an increment migration and verify its laws on reversed domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlip an increment migration and verify its laws on reversed domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (verify-migration-laws f '(2 3 4) '(1 2 3)))", "verify_expr": "(equal? (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (verify-migration-laws f '(2 3 4) '(1 2 3))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "flip"], "split": "eval"}
{"id": "optics_bidirectional_composition_050", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Verify laws for an identity migration over symbol samples.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify laws for an identity migration over symbol samples.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(verify-migration-laws (make-identity-migration 'id 'v0) '(a b c) '(a b c))", "verify_expr": "(equal? (verify-migration-laws (make-identity-migration 'id 'v0) '(a b c) '(a b c)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "identity"], "split": "eval"}
