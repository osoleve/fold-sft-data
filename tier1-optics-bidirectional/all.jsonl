{"id": "optics_bidirectional_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-migration`\nSpec: Create a migration record tagged 'migration with name/from/to/iso slots in canonical order.\n\nWrite exactly one Scheme definition for `make-migration`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-migration`\nSpec: Create a migration record tagged 'migration with name/from/to/iso slots in canonical order.\n\nWrite exactly one Scheme definition for `make-migration`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  ;; TODO: construct a canonical migration record\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-migration`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  ;; TODO: construct a canonical migration record\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-migration`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Implement `make-migration` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Create a migration record tagged 'migration with name/from/to/iso slots in canonical order.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `make-migration` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Create a migration record tagged 'migration with name/from/to/iso slots in canonical order.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migrate`\nSpec: Apply the migration's forward direction by reading p-iso-forward from the migration iso.\n\nWrite exactly one Scheme definition for `migrate`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migrate`\nSpec: Apply the migration's forward direction by reading p-iso-forward from the migration iso.\n\nWrite exactly one Scheme definition for `migrate`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migrate"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migrate m data)\n  ;; TODO: apply migration in forward direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migrate`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migrate m data)\n  ;; TODO: apply migration in forward direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migrate`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (migrate m \"abc\") \"v2:abc\")\n(equal? (rollback m (migrate m \"x\")) \"x\")\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migrate"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Implement `migrate` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Apply the migration's forward direction by reading p-iso-forward from the migration iso.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `migrate` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Apply the migration's forward direction by reading p-iso-forward from the migration iso.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migrate"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `rollback`\nSpec: Apply the migration's backward direction by reading p-iso-backward from the migration iso.\n\nWrite exactly one Scheme definition for `rollback`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `rollback`\nSpec: Apply the migration's backward direction by reading p-iso-backward from the migration iso.\n\nWrite exactly one Scheme definition for `rollback`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "rollback"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (rollback m data)\n  ;; TODO: apply migration in backward direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `rollback`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (rollback m data)\n  ;; TODO: apply migration in backward direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `rollback`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "rollback"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Implement `rollback` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Apply the migration's backward direction by reading p-iso-backward from the migration iso.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `rollback` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Apply the migration's backward direction by reading p-iso-backward from the migration iso.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (rollback m \"v2:abc\") \"abc\")\n(equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "rollback"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-apply`\nSpec: Dispatch by direction symbol: 'forward uses migrate, 'backward uses rollback, else signal an error.\n\nWrite exactly one Scheme definition for `migration-apply`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-apply`\nSpec: Dispatch by direction symbol: 'forward uses migrate, 'backward uses rollback, else signal an error.\n\nWrite exactly one Scheme definition for `migration-apply`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-apply m data direction)\n  ;; TODO: dispatch on direction with explicit error for invalid symbols\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-apply`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-apply m data direction)\n  ;; TODO: dispatch on direction with explicit error for invalid symbols\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-apply`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Implement `migration-apply` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Dispatch by direction symbol: 'forward uses migrate, 'backward uses rollback, else signal an error.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `migration-apply` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Dispatch by direction symbol: 'forward uses migrate, 'backward uses rollback, else signal an error.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-compose`\nSpec: Compose two compatible migrations: forward m1 then m2, backward m2 then m1, preserving version endpoints.\n\nWrite exactly one Scheme definition for `migration-compose`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-compose`\nSpec: Compose two compatible migrations: forward m1 then m2, backward m2 then m1, preserving version endpoints.\n\nWrite exactly one Scheme definition for `migration-compose`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-compose m1 m2)\n  ;; TODO: validate version boundary and compose forward/backward transforms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-compose`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-compose m1 m2)\n  ;; TODO: validate version boundary and compose forward/backward transforms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-compose`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Implement `migration-compose` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose two compatible migrations: forward m1 then m2, backward m2 then m1, preserving version endpoints.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `migration-compose` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose two compatible migrations: forward m1 then m2, backward m2 then m1, preserving version endpoints.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-chain`\nSpec: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nWrite exactly one Scheme definition for `migration-chain`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-chain`\nSpec: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nWrite exactly one Scheme definition for `migration-chain`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-chain migrations)\n  ;; TODO: reject empty input; compose the list into a single migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-chain`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-chain migrations)\n  ;; TODO: reject empty input; compose the list into a single migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-chain`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Implement `migration-chain` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `migration-chain` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Compose a non-empty migration list; reject empty input and return the sole item for singleton lists.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-flip`\nSpec: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nWrite exactly one Scheme definition for `migration-flip`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `migration-flip`\nSpec: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nWrite exactly one Scheme definition for `migration-flip`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-flip m)\n  ;; TODO: swap endpoints and invert iso direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-flip`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (migration-flip m)\n  ;; TODO: swap endpoints and invert iso direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `migration-flip`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Implement `migration-flip` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `migration-flip` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Invert migration direction by swapping from/to versions and exchanging forward/backward transforms.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-migration-from-functions`\nSpec: Lift raw forward/backward functions into a migration via make-p-iso and make-migration.\n\nWrite exactly one Scheme definition for `make-migration-from-functions`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-migration-from-functions`\nSpec: Lift raw forward/backward functions into a migration via make-p-iso and make-migration.\n\nWrite exactly one Scheme definition for `make-migration-from-functions`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  ;; TODO: wrap raw functions into a migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-migration-from-functions`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  ;; TODO: wrap raw functions into a migration\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-migration-from-functions`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Implement `make-migration-from-functions` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Lift raw forward/backward functions into a migration via make-p-iso and make-migration.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `make-migration-from-functions` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Lift raw forward/backward functions into a migration via make-p-iso and make-migration.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-identity-migration`\nSpec: Create a migration that leaves data unchanged and keeps from/to at the same version.\n\nWrite exactly one Scheme definition for `make-identity-migration`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `make-identity-migration`\nSpec: Create a migration that leaves data unchanged and keeps from/to at the same version.\n\nWrite exactly one Scheme definition for `make-identity-migration`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-identity-migration name version)\n  ;; TODO: build an identity migration at one version\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-identity-migration`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-identity-migration name version)\n  ;; TODO: build an identity migration at one version\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-identity-migration`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Implement `make-identity-migration` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Create a migration that leaves data unchanged and keeps from/to at the same version.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `make-identity-migration` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Create a migration that leaves data unchanged and keeps from/to at the same version.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Implement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `verify-migration-laws`\nSpec: Delegate to verify-p-iso-laws on a migration's iso using source-domain and target-domain test samples.\n\nWrite exactly one Scheme definition for `verify-migration-laws`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this bidirectional optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/bidirectional.ss\nFunction: `verify-migration-laws`\nSpec: Delegate to verify-p-iso-laws on a migration's iso using source-domain and target-domain test samples.\n\nWrite exactly one Scheme definition for `verify-migration-laws`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "spec-to-code", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  ;; TODO: verify underlying iso invertibility laws on both sample sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `verify-migration-laws`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  ;; TODO: verify underlying iso invertibility laws on both sample sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `verify-migration-laws`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "skeleton-completion", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Implement `verify-migration-laws` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Delegate to verify-p-iso-laws on a migration's iso using source-domain and target-domain test samples.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `verify-migration-laws` from this contract.\n\nModule: `lattice/optics/bidirectional.ss`\nContract focus: Delegate to verify-p-iso-laws on a migration's iso using source-domain and target-domain test samples.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve edge-case behavior and migration semantics.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "contract-implementation", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-migration`.\nReturn only the Scheme definition.\n\n```python\ndef build_migration(name, from_version, to_version, iso_obj):\n    return [\"migration\", name, from_version, to_version, iso_obj]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-migration`.\nReturn only the Scheme definition.\n\n```python\ndef build_migration(name, from_version, to_version, iso_obj):\n    return [\"migration\", name, from_version, to_version, iso_obj]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-migration`.\nReturn only the final Fold definition.\n\n```scheme\n(define (build-migration tag src dst conversion)\n  (list 'migration tag src dst conversion))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-migration`.\nReturn only the final Fold definition.\n\n```scheme\n(define (build-migration tag src dst conversion)\n  (list 'migration tag src dst conversion))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-migration`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'migration-type)\n\n(define (passthrough x) x)\n\n  (define (build-migration tag src dst conversion)\n    (list 'migration tag src dst conversion))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-migration`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'migration-type)\n\n(define (passthrough x) x)\n\n  (define (build-migration tag src dst conversion)\n    (list 'migration tag src dst conversion))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migrate`.\nReturn only the Scheme definition.\n\n```python\ndef migrate_step(migration, payload):\n    iso_obj = migration_iso(migration)\n    fwd = p_iso_forward(iso_obj)\n    return fwd(payload)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migrate`.\nReturn only the Scheme definition.\n\n```python\ndef migrate_step(migration, payload):\n    iso_obj = migration_iso(migration)\n    fwd = p_iso_forward(iso_obj)\n    return fwd(payload)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migrate"], "split": "train"}
{"id": "optics_bidirectional_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migrate`.\nReturn only the final Fold definition.\n\n```scheme\n(define (run-forward migration payload)\n  (let* ([iso (migration-iso migration)]\n         [forward (p-iso-forward iso)])\n    (forward payload)))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migrate`.\nReturn only the final Fold definition.\n\n```scheme\n(define (run-forward migration payload)\n  (let* ([iso (migration-iso migration)]\n         [forward (p-iso-forward iso)])\n    (forward payload)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migrate"], "split": "train"}
{"id": "optics_bidirectional_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migrate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (run-forward migration payload)\n    (let* ([iso (migration-iso migration)]\n           [forward (p-iso-forward iso)])\n      (forward payload)))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migrate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (run-forward migration payload)\n    (let* ([iso (migration-iso migration)]\n           [forward (p-iso-forward iso)])\n      (forward payload)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (migrate m \"abc\") \"v2:abc\")\n(equal? (rollback m (migrate m \"x\")) \"x\")\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (migrate m data)\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migrate"], "split": "train"}
{"id": "optics_bidirectional_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `rollback`.\nReturn only the Scheme definition.\n\n```python\ndef rollback_step(migration, payload):\n    iso_obj = migration_iso(migration)\n    bwd = p_iso_backward(iso_obj)\n    return bwd(payload)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `rollback`.\nReturn only the Scheme definition.\n\n```python\ndef rollback_step(migration, payload):\n    iso_obj = migration_iso(migration)\n    bwd = p_iso_backward(iso_obj)\n    return bwd(payload)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (rollback m \"v2:abc\") \"abc\")\n(equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "rollback"], "split": "train"}
{"id": "optics_bidirectional_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `rollback`.\nReturn only the final Fold definition.\n\n```scheme\n(define (run-backward migration payload)\n  (let* ([iso (migration-iso migration)]\n         [backward (p-iso-backward iso)])\n    (backward payload)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `rollback`.\nReturn only the final Fold definition.\n\n```scheme\n(define (run-backward migration payload)\n  (let* ([iso (migration-iso migration)]\n         [backward (p-iso-backward iso)])\n    (backward payload)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "rollback"], "split": "train"}
{"id": "optics_bidirectional_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `rollback`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (run-backward migration payload)\n    (let* ([iso (migration-iso migration)]\n           [backward (p-iso-backward iso)])\n      (backward payload)))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `rollback`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (run-backward migration payload)\n    (let* ([iso (migration-iso migration)]\n           [backward (p-iso-backward iso)])\n      (backward payload)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (rollback m data)\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "rollback"], "split": "train"}
{"id": "optics_bidirectional_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-apply`.\nReturn only the Scheme definition.\n\n```python\ndef migration_apply(migration, payload, direction):\n    if direction == \"forward\":\n        return migrate(migration, payload)\n    if direction == \"backward\":\n        return rollback(migration, payload)\n    raise ValueError((\"migration-apply\", \"Invalid direction\", direction))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-apply`.\nReturn only the Scheme definition.\n\n```python\ndef migration_apply(migration, payload, direction):\n    if direction == \"forward\":\n        return migrate(migration, payload)\n    if direction == \"backward\":\n        return rollback(migration, payload)\n    raise ValueError((\"migration-apply\", \"Invalid direction\", direction))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-migration migration payload dir)\n  (cond\n    [(eq? dir 'forward)\n     (migrate migration payload)]\n    [(eq? dir 'backward)\n     (rollback migration payload)]\n    [else\n     (error 'migration-apply \"Invalid direction\" dir)]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-apply`.\nReturn only the final Fold definition.\n\n```scheme\n(define (apply-migration migration payload dir)\n  (cond\n    [(eq? dir 'forward)\n     (migrate migration payload)]\n    [(eq? dir 'backward)\n     (rollback migration payload)]\n    [else\n     (error 'migration-apply \"Invalid direction\" dir)]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-apply`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (apply-migration migration payload dir)\n    (cond\n      [(eq? dir 'forward)\n       (migrate migration payload)]\n      [(eq? dir 'backward)\n       (rollback migration payload)]\n      [else\n       (error 'migration-apply \"Invalid direction\" dir)]))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-apply`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'core-operations)\n\n(define (passthrough x) x)\n\n  (define (apply-migration migration payload dir)\n    (cond\n      [(eq? dir 'forward)\n       (migrate migration payload)]\n      [(eq? dir 'backward)\n       (rollback migration payload)]\n      [else\n       (error 'migration-apply \"Invalid direction\" dir)]))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (migration-apply m data direction)\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-compose`.\nReturn only the Scheme definition.\n\n```python\ndef migration_compose(first, second):\n    if migration_to(first) != migration_from(second):\n        raise ValueError(\"version mismatch\")\n\n    iso1 = migration_iso(first)\n    iso2 = migration_iso(second)\n\n    combo = make_p_iso(\n        lambda x: p_iso_forward(iso2)(p_iso_forward(iso1)(x)),\n        lambda y: p_iso_backward(iso1)(p_iso_backward(iso2)(y)),\n    )\n\n    name = symbol(f\"{migration_from(first)}->{migration_to(second)}\")\n    return make_migration(name, migration_from(first), migration_to(second), combo)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-compose`.\nReturn only the Scheme definition.\n\n```python\ndef migration_compose(first, second):\n    if migration_to(first) != migration_from(second):\n        raise ValueError(\"version mismatch\")\n\n    iso1 = migration_iso(first)\n    iso2 = migration_iso(second)\n\n    combo = make_p_iso(\n        lambda x: p_iso_forward(iso2)(p_iso_forward(iso1)(x)),\n        lambda y: p_iso_backward(iso1)(p_iso_backward(iso2)(y)),\n    )\n\n    name = symbol(f\"{migration_from(first)}->{migration_to(second)}\")\n    return make_migration(name, migration_from(first), migration_to(second), combo)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-migrations first second)\n  (unless (equal? (migration-to first) (migration-from second))\n    (error 'migration-compose \"Version mismatch\"))\n\n  (let* ([forward-1 (p-iso-forward (migration-iso first))]\n         [forward-2 (p-iso-forward (migration-iso second))]\n         [backward-1 (p-iso-backward (migration-iso first))]\n         [backward-2 (p-iso-backward (migration-iso second))]\n         [combined (make-p-iso\n                    (lambda (x) (forward-2 (forward-1 x)))\n                    (lambda (y) (backward-1 (backward-2 y))))]\n         [name (string->symbol\n                (format \"~a->~a\"\n                        (migration-from first)\n                        (migration-to second)))])\n    (make-migration name\n                    (migration-from first)\n                    (migration-to second)\n                    combined)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-migrations first second)\n  (unless (equal? (migration-to first) (migration-from second))\n    (error 'migration-compose \"Version mismatch\"))\n\n  (let* ([forward-1 (p-iso-forward (migration-iso first))]\n         [forward-2 (p-iso-forward (migration-iso second))]\n         [backward-1 (p-iso-backward (migration-iso first))]\n         [backward-2 (p-iso-backward (migration-iso second))]\n         [combined (make-p-iso\n                    (lambda (x) (forward-2 (forward-1 x)))\n                    (lambda (y) (backward-1 (backward-2 y))))]\n         [name (string->symbol\n                (format \"~a->~a\"\n                        (migration-from first)\n                        (migration-to second)))])\n    (make-migration name\n                    (migration-from first)\n                    (migration-to second)\n                    combined)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-migrations first second)\n    (unless (equal? (migration-to first) (migration-from second))\n      (error 'migration-compose \"Version mismatch\"))\n  \n    (let* ([forward-1 (p-iso-forward (migration-iso first))]\n           [forward-2 (p-iso-forward (migration-iso second))]\n           [backward-1 (p-iso-backward (migration-iso first))]\n           [backward-2 (p-iso-backward (migration-iso second))]\n           [combined (make-p-iso\n                      (lambda (x) (forward-2 (forward-1 x)))\n                      (lambda (y) (backward-1 (backward-2 y))))]\n           [name (string->symbol\n                  (format \"~a->~a\"\n                          (migration-from first)\n                          (migration-to second)))])\n      (make-migration name\n                      (migration-from first)\n                      (migration-to second)\n                      combined)))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-migrations first second)\n    (unless (equal? (migration-to first) (migration-from second))\n      (error 'migration-compose \"Version mismatch\"))\n  \n    (let* ([forward-1 (p-iso-forward (migration-iso first))]\n           [forward-2 (p-iso-forward (migration-iso second))]\n           [backward-1 (p-iso-backward (migration-iso first))]\n           [backward-2 (p-iso-backward (migration-iso second))]\n           [combined (make-p-iso\n                      (lambda (x) (forward-2 (forward-1 x)))\n                      (lambda (y) (backward-1 (backward-2 y))))]\n           [name (string->symbol\n                  (format \"~a->~a\"\n                          (migration-from first)\n                          (migration-to second)))])\n      (make-migration name\n                      (migration-from first)\n                      (migration-to second)\n                      combined)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-compose m1 m2)\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-chain`.\nReturn only the Scheme definition.\n\n```python\ndef migration_chain(ms):\n    if len(ms) == 0:\n        raise ValueError((\"migration-chain\", \"Empty migration list\"))\n    if len(ms) == 1:\n        return ms[0]\n\n    acc = ms[0]\n    for m in ms[1:]:\n        acc = migration_compose(acc, m)\n    return acc\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-chain`.\nReturn only the Scheme definition.\n\n```python\ndef migration_chain(ms):\n    if len(ms) == 0:\n        raise ValueError((\"migration-chain\", \"Empty migration list\"))\n    if len(ms) == 1:\n        return ms[0]\n\n    acc = ms[0]\n    for m in ms[1:]:\n        acc = migration_compose(acc, m)\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-chain`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-chain ms)\n  (cond\n    [(null? ms)\n     (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr ms))\n     (car ms)]\n    [else\n     (fold-left migration-compose (car ms) (cdr ms))]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-chain`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compose-chain ms)\n  (cond\n    [(null? ms)\n     (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr ms))\n     (car ms)]\n    [else\n     (fold-left migration-compose (car ms) (cdr ms))]))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-chain`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-chain ms)\n    (cond\n      [(null? ms)\n       (error 'migration-chain \"Empty migration list\")]\n      [(null? (cdr ms))\n       (car ms)]\n      [else\n       (fold-left migration-compose (car ms) (cdr ms))]))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-chain`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'composition)\n\n(define (passthrough x) x)\n\n  (define (compose-chain ms)\n    (cond\n      [(null? ms)\n       (error 'migration-chain \"Empty migration list\")]\n      [(null? (cdr ms))\n       (car ms)]\n      [else\n       (fold-left migration-compose (car ms) (cdr ms))]))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_translation_019", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-flip`.\nReturn only the Scheme definition.\n\n```python\ndef migration_flip(migration):\n    iso_obj = migration_iso(migration)\n    flipped = make_p_iso(p_iso_backward(iso_obj), p_iso_forward(iso_obj))\n    name = symbol(f\"{migration_name(migration)}-reversed\")\n    return make_migration(name, migration_to(migration), migration_from(migration), flipped)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `migration-flip`.\nReturn only the Scheme definition.\n\n```python\ndef migration_flip(migration):\n    iso_obj = migration_iso(migration)\n    flipped = make_p_iso(p_iso_backward(iso_obj), p_iso_forward(iso_obj))\n    name = symbol(f\"{migration_name(migration)}-reversed\")\n    return make_migration(name, migration_to(migration), migration_from(migration), flipped)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-flip`.\nReturn only the final Fold definition.\n\n```scheme\n(define (invert-migration m)\n  (let* ([iso (migration-iso m)]\n         [reversed (make-p-iso (p-iso-backward iso)\n                               (p-iso-forward iso))]\n         [name (string->symbol\n                (format \"~a-reversed\" (migration-name m)))])\n    (make-migration name\n                    (migration-to m)\n                    (migration-from m)\n                    reversed)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `migration-flip`.\nReturn only the final Fold definition.\n\n```scheme\n(define (invert-migration m)\n  (let* ([iso (migration-iso m)]\n         [reversed (make-p-iso (p-iso-backward iso)\n                               (p-iso-forward iso))]\n         [name (string->symbol\n                (format \"~a-reversed\" (migration-name m)))])\n    (make-migration name\n                    (migration-to m)\n                    (migration-from m)\n                    reversed)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_021", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-flip`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'reversal)\n\n(define (passthrough x) x)\n\n  (define (invert-migration m)\n    (let* ([iso (migration-iso m)]\n           [reversed (make-p-iso (p-iso-backward iso)\n                                 (p-iso-forward iso))]\n           [name (string->symbol\n                  (format \"~a-reversed\" (migration-name m)))])\n      (make-migration name\n                      (migration-to m)\n                      (migration-from m)\n                      reversed)))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `migration-flip`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'reversal)\n\n(define (passthrough x) x)\n\n  (define (invert-migration m)\n    (let* ([iso (migration-iso m)]\n           [reversed (make-p-iso (p-iso-backward iso)\n                                 (p-iso-forward iso))]\n           [name (string->symbol\n                  (format \"~a-reversed\" (migration-name m)))])\n      (make-migration name\n                      (migration-to m)\n                      (migration-from m)\n                      reversed)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-migration-from-functions`.\nReturn only the Scheme definition.\n\n```python\ndef make_migration_from_functions(name, from_ver, to_ver, forward, backward):\n    return make_migration(name, from_ver, to_ver, make_p_iso(forward, backward))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-migration-from-functions`.\nReturn only the Scheme definition.\n\n```python\ndef make_migration_from_functions(name, from_ver, to_ver, forward, backward):\n    return make_migration(name, from_ver, to_ver, make_p_iso(forward, backward))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-migration-from-functions`.\nReturn only the final Fold definition.\n\n```scheme\n(define (migration-from-fns label src dst fw bw)\n  (let ([iso (make-p-iso fw bw)])\n    (make-migration label src dst iso)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-migration-from-functions`.\nReturn only the final Fold definition.\n\n```scheme\n(define (migration-from-fns label src dst fw bw)\n  (let ([iso (make-p-iso fw bw)])\n    (make-migration label src dst iso)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-migration-from-functions`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'builders)\n\n(define (passthrough x) x)\n\n  (define (migration-from-fns label src dst fw bw)\n    (let ([iso (make-p-iso fw bw)])\n      (make-migration label src dst iso)))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-migration-from-functions`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'builders)\n\n(define (passthrough x) x)\n\n  (define (migration-from-fns label src dst fw bw)\n    (let ([iso (make-p-iso fw bw)])\n      (make-migration label src dst iso)))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_translation_025", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-identity-migration`.\nReturn only the Scheme definition.\n\n```python\ndef make_identity_migration(name, version):\n    return make_migration(name, version, version, p_iso_id)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-identity-migration`.\nReturn only the Scheme definition.\n\n```python\ndef make_identity_migration(name, version):\n    return make_migration(name, version, version, p_iso_id)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_026", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-identity-migration`.\nReturn only the final Fold definition.\n\n```scheme\n(define (identity-migration label v)\n  (let ([same v]\n        [iso p-iso-id])\n    (make-migration label same same iso)))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-identity-migration`.\nReturn only the final Fold definition.\n\n```scheme\n(define (identity-migration label v)\n  (let ([same v]\n        [iso p-iso-id])\n    (make-migration label same same iso)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_027", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-identity-migration`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'builders)\n\n(define (passthrough x) x)\n\n  (define (identity-migration label v)\n    (let ([same v]\n          [iso p-iso-id])\n      (make-migration label same same iso)))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-identity-migration`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'builders)\n\n(define (passthrough x) x)\n\n  (define (identity-migration label v)\n    (let ([same v]\n          [iso p-iso-id])\n      (make-migration label same same iso)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-identity-migration name version)\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_translation_028", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `verify-migration-laws`.\nReturn only the Scheme definition.\n\n```python\ndef verify_migration_laws(migration, test_as, test_bs):\n    return verify_p_iso_laws(migration_iso(migration), test_as, test_bs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `verify-migration-laws`.\nReturn only the Scheme definition.\n\n```python\ndef verify_migration_laws(migration, test_as, test_bs):\n    return verify_p_iso_laws(migration_iso(migration), test_as, test_bs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "python-to-scheme", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_translation_029", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `verify-migration-laws`.\nReturn only the final Fold definition.\n\n```scheme\n(define (migration-laws-hold? migration source-samples target-samples)\n  (let ([iso (migration-iso migration)])\n    (verify-p-iso-laws iso source-samples target-samples)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `verify-migration-laws`.\nReturn only the final Fold definition.\n\n```scheme\n(define (migration-laws-hold? migration source-samples target-samples)\n  (let ([iso (migration-iso migration)])\n    (verify-p-iso-laws iso source-samples target-samples)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "chez-to-fold", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_translation_030", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `verify-migration-laws`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'verification)\n\n(define (passthrough x) x)\n\n  (define (migration-laws-hold? migration source-samples target-samples)\n    (let ([iso (migration-iso migration)])\n      (verify-p-iso-laws iso source-samples target-samples)))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `verify-migration-laws`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/bidirectional.ss excerpt\n(require 'profunctor-optics)\n\n(doc 'module 'bidirectional)\n(doc 'section 'verification)\n\n(define (passthrough x) x)\n\n  (define (migration-laws-hold? migration source-samples target-samples)\n    (let ([iso (migration-iso migration)])\n      (verify-p-iso-laws iso source-samples target-samples)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "source-excerpt-to-fold", "doc-free-target", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Migration records must be tagged with the exact symbol 'migration.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  (list 'migratoin name from-version to-version iso))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Migration records must be tagged with the exact symbol 'migration.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  (list 'migratoin name from-version to-version iso))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: from-version and to-version are swapped.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  (list 'migration name to-version from-version iso))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: from-version and to-version are swapped.\n\n```scheme\n(define (make-migration name from-version to-version iso)\n  (list 'migration name to-version from-version iso))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(migration? m)\n(equal? (car m) 'migration)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-migration name from-version to-version iso)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version PIso Migration))\n  (doc 'description \"Create a named migration between two versions.\nThe iso's forward transforms from-version to to-version,\nand the backward transforms to-version back to from-version.\")\n  (list 'migration name from-version to-version iso))", "verify_expr": "(let* ([iso (make-p-iso add1 sub1)]\n       [m (make-migration 'inc 'v1 'v2 iso)])\n  (and (migration? m)\n       (equal? (car m) 'migration)\n       (equal? (migration-name m) 'inc)\n       (equal? (migration-from m) 'v1)\n       (equal? (migration-to m) 'v2)\n       (= (migrate m 10) 11)\n       (= (rollback m 11) 10)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-migration"], "split": "train"}
{"id": "optics_bidirectional_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migrate` in `lattice/optics/bidirectional.ss`.\nKnown issue: migrate must use the iso's forward function.\n\n```scheme\n(define (migrate m data)\n  ((p-iso-backward (migration-iso m)) data))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migrate` in `lattice/optics/bidirectional.ss`.\nKnown issue: migrate must use the iso's forward function.\n\n```scheme\n(define (migrate m data)\n  ((p-iso-backward (migration-iso m)) data))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migrate"], "split": "train"}
{"id": "optics_bidirectional_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migrate` in `lattice/optics/bidirectional.ss`.\nKnown issue: migrate cannot ignore the migration transform.\n\n```scheme\n(define (migrate m data)\n  data)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migrate` in `lattice/optics/bidirectional.ss`.\nKnown issue: migrate cannot ignore the migration transform.\n\n```scheme\n(define (migrate m data)\n  data)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (migrate m \"abc\") \"v2:abc\")\n(equal? (rollback m (migrate m \"x\")) \"x\")\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migrate m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the forward direction.\nTransforms data from `from-version` to `to-version`.\")\n  ((p-iso-forward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (migrate m \"abc\") \"v2:abc\")\n       (equal? (rollback m (migrate m \"x\")) \"x\")))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migrate"], "split": "train"}
{"id": "optics_bidirectional_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rollback` in `lattice/optics/bidirectional.ss`.\nKnown issue: rollback must use the iso's backward function.\n\n```scheme\n(define (rollback m data)\n  ((p-iso-forward (migration-iso m)) data))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rollback` in `lattice/optics/bidirectional.ss`.\nKnown issue: rollback must use the iso's backward function.\n\n```scheme\n(define (rollback m data)\n  ((p-iso-forward (migration-iso m)) data))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (rollback m \"v2:abc\") \"abc\")\n(equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (rollback m \"v2:abc\") \"abc\")\n(equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "rollback"], "split": "train"}
{"id": "optics_bidirectional_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rollback` in `lattice/optics/bidirectional.ss`.\nKnown issue: rollback cannot return payload unchanged in general.\n\n```scheme\n(define (rollback m data)\n  data)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rollback` in `lattice/optics/bidirectional.ss`.\nKnown issue: rollback cannot return payload unchanged in general.\n\n```scheme\n(define (rollback m data)\n  data)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (rollback m data)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Data))\n  (doc 'description \"Apply the migration in the backward direction.\nTransforms data from `to-version` back to `from-version`.\")\n  ((p-iso-backward (migration-iso m)) data))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'prefix 'raw 'tagged\n           (lambda (s) (string-append \"v2:\" s))\n           (lambda (s) (substring s 3 (string-length s))))])\n  (and (equal? (rollback m \"v2:abc\") \"abc\")\n       (equal? (migrate m (rollback m \"v2:x\")) \"v2:x\")))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "rollback"], "split": "train"}
{"id": "optics_bidirectional_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-apply` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward direction must dispatch to rollback.\n\n```scheme\n(define (migration-apply m data direction)\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (migrate m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-apply` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward direction must dispatch to rollback.\n\n```scheme\n(define (migration-apply m data direction)\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (migrate m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-apply` in `lattice/optics/bidirectional.ss`.\nKnown issue: Invalid direction must raise an error, not silently fallback.\n\n```scheme\n(define (migration-apply m data direction)\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (migrate m data)]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-apply` in `lattice/optics/bidirectional.ss`.\nKnown issue: Invalid direction must raise an error, not silently fallback.\n\n```scheme\n(define (migration-apply m data direction)\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (migrate m data)]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(= (migration-apply m 10 'forward) 11)\n(= (migration-apply m 10 'backward) 9)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-apply m data direction)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Data Direction Data))\n  (doc 'description \"Apply migration in specified direction ('forward or 'backward).\")\n  (case direction\n    [(forward) (migrate m data)]\n    [(backward) (rollback m data)]\n    [else (error 'migration-apply \"Invalid direction\" direction)]))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))])\n  (and (= (migration-apply m 10 'forward) 11)\n       (= (migration-apply m 10 'backward) 9)\n       (guard (ex [else #t])\n         (begin\n           (migration-apply m 10 'sideways)\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-apply"], "split": "train"}
{"id": "optics_bidirectional_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-compose` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward composition order must be iso1.backward after iso2.backward.\n\n```scheme\n(define (migration-compose m1 m2)\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        (compose2 (p-iso-backward iso2) (p-iso-backward iso1)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-compose` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward composition order must be iso1.backward after iso2.backward.\n\n```scheme\n(define (migration-compose m1 m2)\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        (compose2 (p-iso-backward iso2) (p-iso-backward iso1)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-compose` in `lattice/optics/bidirectional.ss`.\nKnown issue: Composed migration name should reflect endpoint versions, not reuse m1 name.\n\n```scheme\n(define (migration-compose m1 m2)\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))])\n    (make-migration (migration-name m1)\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-compose` in `lattice/optics/bidirectional.ss`.\nKnown issue: Composed migration name should reflect endpoint versions, not reuse m1 name.\n\n```scheme\n(define (migration-compose m1 m2)\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))])\n    (make-migration (migration-name m1)\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal? (migration-from m3) 'v1)\n(equal? (migration-to m3) 'v3)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (migration-compose m1 m2)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration Migration))\n  (doc 'description \"Compose two migrations: (m1 ; m2) where m1.to = m2.from.\nResult transforms from m1.from to m2.to.\n\nForward:  m1.forward then m2.forward\nBackward: m2.backward then m1.backward\")\n  ;; Validate version compatibility\n  (unless (equal? (migration-to m1) (migration-from m2))\n    (error 'migration-compose\n           \"Version mismatch: ~a.to (~a) != ~a.from (~a)\"\n           (migration-name m1) (migration-to m1)\n           (migration-name m2) (migration-from m2)))\n\n  (let* ([iso1 (migration-iso m1)]\n         [iso2 (migration-iso m2)]\n         [combined-iso (make-p-iso\n                        ;; Forward: apply m1 then m2\n                        (compose2 (p-iso-forward iso2) (p-iso-forward iso1))\n                        ;; Backward: apply m2 then m1 (reverse order)\n                        (compose2 (p-iso-backward iso1) (p-iso-backward iso2)))]\n         [combined-name (string->symbol\n                         (format \"~a->~a\"\n                                 (migration-from m1)\n                                 (migration-to m2)))])\n    (make-migration combined-name\n                    (migration-from m1)\n                    (migration-to m2)\n                    combined-iso)))", "verify_expr": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'double 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (migration-compose m1 m2)])\n  (and (equal? (migration-from m3) 'v1)\n       (equal? (migration-to m3) 'v3)\n       (= (migrate m3 5) 12)\n       (= (rollback m3 12) 5)\n       (guard (ex [else #t])\n         (begin\n           (migration-compose m1 (make-migration 'bad 'x 'y p-iso-id))\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-compose"], "split": "train"}
{"id": "optics_bidirectional_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Empty migration lists must raise an error, not return #f.\n\n```scheme\n(define (migration-chain migrations)\n  (if (null? migrations)\n      #f\n      (fold-left migration-compose (car migrations) (cdr migrations))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Empty migration lists must raise an error, not return #f.\n\n```scheme\n(define (migration-chain migrations)\n  (if (null? migrations)\n      #f\n      (fold-left migration-compose (car migrations) (cdr migrations))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Using fold-right with this seed changes composition semantics and can break endpoints.\n\n```scheme\n(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [else (fold-right migration-compose (car migrations) (cdr migrations))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-chain` in `lattice/optics/bidirectional.ss`.\nKnown issue: Using fold-right with this seed changes composition semantics and can break endpoints.\n\n```scheme\n(define (migration-chain migrations)\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [else (fold-right migration-compose (car migrations) (cdr migrations))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (migrate chain 5) 9)\n(= (rollback chain 9) 5)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-chain migrations)\n  (doc 'export #t)\n  (doc 'type '(-> (List Migration) Migration))\n  (doc 'description \"Compose a list of migrations into a single migration.\nMigrations must form a valid chain: each m.to = next m.from.\")\n  (cond\n    [(null? migrations) (error 'migration-chain \"Empty migration list\")]\n    [(null? (cdr migrations)) (car migrations)]\n    [else (fold-left migration-compose (car migrations) (cdr migrations))]))", "verify_expr": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))]\n       [m2 (make-migration 'b 'v2 'v3\n                           (make-p-iso (lambda (x) (* x 2))\n                                       (lambda (x) (/ x 2))))]\n       [m3 (make-migration 'c 'v3 'v4\n                           (make-p-iso (lambda (x) (- x 3))\n                                       (lambda (x) (+ x 3))))]\n       [chain (migration-chain (list m1 m2 m3))]\n       [single (migration-chain (list m1))])\n  (and (= (migrate chain 5) 9)\n       (= (rollback chain 9) 5)\n       (= (migrate single 5) 6)\n       (guard (ex [else #t])\n         (begin\n           (migration-chain '())\n           #f))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-chain"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migrations must swap from/to versions and derive a reversed name.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))])\n    (make-migration (migration-name m)\n                    (migration-from m)\n                    (migration-to m)\n                    flipped-iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migrations must swap from/to versions and derive a reversed name.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))])\n    (make-migration (migration-name m)\n                    (migration-from m)\n                    (migration-to m)\n                    flipped-iso)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migration must invert the iso direction, not reuse original iso.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)\n                    (migration-from m)\n                    iso)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `migration-flip` in `lattice/optics/bidirectional.ss`.\nKnown issue: Flipped migration must invert the iso direction, not reuse original iso.\n\n```scheme\n(define (migration-flip m)\n  (let* ([iso (migration-iso m)]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)\n                    (migration-from m)\n                    iso)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (migration-from flipped) 'v2)\n(equal? (migration-to flipped) 'v1)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (migration-flip m)\n  (doc 'export #t)\n  (doc 'type '(-> Migration Migration))\n  (doc 'description \"Reverse a migration: swap forward/backward and from/to versions.\")\n  (let* ([iso (migration-iso m)]\n         [flipped-iso (make-p-iso\n                       (p-iso-backward iso)\n                       (p-iso-forward iso))]\n         [flipped-name (string->symbol\n                        (format \"~a-reversed\" (migration-name m)))])\n    (make-migration flipped-name\n                    (migration-to m)     ; Swap from/to\n                    (migration-from m)\n                    flipped-iso)))", "verify_expr": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]\n       [flipped (migration-flip m)]\n       [double-flipped (migration-flip flipped)])\n  (and (equal? (migration-from flipped) 'v2)\n       (equal? (migration-to flipped) 'v1)\n       (= (migrate flipped 10) 9)\n       (= (rollback flipped 10) 11)\n       (= (migrate double-flipped 7) (migrate m 7))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "migration-flip"], "split": "eval"}
{"id": "optics_bidirectional_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration-from-functions` in `lattice/optics/bidirectional.ss`.\nKnown issue: Forward/backward arguments are reversed when building the iso.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (make-migration name from-ver to-ver (make-p-iso backward forward)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration-from-functions` in `lattice/optics/bidirectional.ss`.\nKnown issue: Forward/backward arguments are reversed when building the iso.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (make-migration name from-ver to-ver (make-p-iso backward forward)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration-from-functions` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward function must come from argument, not identity.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (make-migration name from-ver to-ver (make-p-iso forward identity)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-migration-from-functions` in `lattice/optics/bidirectional.ss`.\nKnown issue: Backward function must come from argument, not identity.\n\n```scheme\n(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (make-migration name from-ver to-ver (make-p-iso forward identity)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(migration? m)\n(= (migrate m 4) 12)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-migration-from-functions name from-ver to-ver forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Version (-> a b) (-> b a) Migration))\n  (doc 'description \"Create a migration from forward and backward functions.\")\n  (make-migration name from-ver to-ver (make-p-iso forward backward)))", "verify_expr": "(let* ([m (make-migration-from-functions\n           'triple 'v1 'v2\n           (lambda (x) (* x 3))\n           (lambda (y) (/ y 3)))])\n  (and (migration? m)\n       (= (migrate m 4) 12)\n       (= (rollback m 12) 4)\n       (equal? (migration-to m) 'v2)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-migration-from-functions"], "split": "train"}
{"id": "optics_bidirectional_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Identity migration should keep from/to at the provided version.\n\n```scheme\n(define (make-identity-migration name version)\n  (make-migration name 'v0 version p-iso-id))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Identity migration should keep from/to at the provided version.\n\n```scheme\n(define (make-identity-migration name version)\n  (make-migration name 'v0 version p-iso-id))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Identity migration must use p-iso-id, not a non-identity transform.\n\n```scheme\n(define (make-identity-migration name version)\n  (make-migration name version version\n                  (make-p-iso add1 sub1)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-identity-migration` in `lattice/optics/bidirectional.ss`.\nKnown issue: Identity migration must use p-iso-id, not a non-identity transform.\n\n```scheme\n(define (make-identity-migration name version)\n  (make-migration name version version\n                  (make-p-iso add1 sub1)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(migration? m)\n(equal? (migration-from m) 'v9)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-identity-migration name version)\n  (doc 'export #t)\n  (doc 'type '(-> Symbol Version Migration))\n  (doc 'description \"Create a no-op migration (useful as a base case).\")\n  (make-migration name version version p-iso-id))", "verify_expr": "(let ([m (make-identity-migration 'id 'v9)])\n  (and (migration? m)\n       (equal? (migration-from m) 'v9)\n       (equal? (migration-to m) 'v9)\n       (equal? (migrate m '(1 2)) '(1 2))\n       (equal? (rollback m '(a . b)) '(a . b))))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "make-identity-migration"], "split": "train"}
{"id": "optics_bidirectional_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `verify-migration-laws` in `lattice/optics/bidirectional.ss`.\nKnown issue: Must verify both iso directions (source and target domains), not one side only.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  (let ([iso (migration-iso m)])\n    (andmap (lambda (a) (equal? ((p-iso-backward iso) ((p-iso-forward iso) a)) a))\n            test-as)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `verify-migration-laws` in `lattice/optics/bidirectional.ss`.\nKnown issue: Must verify both iso directions (source and target domains), not one side only.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  (let ([iso (migration-iso m)])\n    (andmap (lambda (a) (equal? ((p-iso-backward iso) ((p-iso-forward iso) a)) a))\n            test-as)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `verify-migration-laws` in `lattice/optics/bidirectional.ss`.\nKnown issue: Argument order to verify-p-iso-laws is swapped.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-bs test-as)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `verify-migration-laws` in `lattice/optics/bidirectional.ss`.\nKnown issue: Argument order to verify-p-iso-laws is swapped.\n\n```scheme\n(define (verify-migration-laws m test-as test-bs)\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-bs test-as)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\nprefix-ok\n(not bad-ok)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (verify-migration-laws m test-as test-bs)\n  (doc 'export #t)\n  (doc 'type '(-> Migration (List a) (List b) Boolean))\n  (doc 'description \"Verify that migration satisfies iso laws on test data.\ntest-as: data in from-version format\ntest-bs: data in to-version format\")\n  (let ([iso (migration-iso m)])\n    (verify-p-iso-laws iso test-as test-bs)))", "verify_expr": "(let* ([good-prefix (make-migration-from-functions\n                     'good-prefix 'v1 'v2\n                     (lambda (s) (string-append \"v2:\" s))\n                     (lambda (s)\n                       (if (and (<= 3 (string-length s))\n                                (string=? (substring s 0 3) \"v2:\"))\n                           (substring s 3 (string-length s))\n                           (error 'good-prefix-backward \"bad payload\"))))]\n       [bad-one-sided (make-migration-from-functions\n                       'bad-one-sided 'v1 'v2\n                       abs\n                       identity)]\n       [prefix-ok (guard (ex [else #f])\n                    (verify-migration-laws good-prefix\n                                           '(\"a\" \"bc\")\n                                           '(\"v2:a\" \"v2:bc\")))]\n       [bad-ok (guard (ex [else #f])\n                 (verify-migration-laws bad-one-sided\n                                        '(1 2 3)\n                                        '(-1 2 -3)))])\n  (and prefix-ok (not bad-ok)))", "tags": ["tier1", "optics", "bidirectional", "bugfix", "verify-migration-laws"], "split": "train"}
{"id": "optics_bidirectional_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Construct a migration and return its record tag symbol.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a migration and return its record tag symbol.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)))", "verify_expr": "(equal? (car (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))) 'migration)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "record"], "split": "eval"}
{"id": "optics_bidirectional_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Create an increment migration and apply it forward to 10.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate an increment migration and apply it forward to 10.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(migrate (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 10)", "verify_expr": "(= (migrate (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 10) 11)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Create an increment migration and apply rollback to 11.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate an increment migration and apply rollback to 11.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(rollback (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 11)", "verify_expr": "(= (rollback (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 11) 10)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Build a prefixing migration and roundtrip the string \"abc\".\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a prefixing migration and roundtrip the string \"abc\".\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-migration 'prefix 'raw 'tagged (make-p-iso (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))))]) (rollback m (migrate m \"abc\")))", "verify_expr": "(equal? (let* ([m (make-migration 'prefix 'raw 'tagged (make-p-iso (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))))]) (rollback m (migrate m \"abc\"))) \"abc\")", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "roundtrip"], "split": "train"}
{"id": "optics_bidirectional_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration", "prompt_body": "Create two migrations and test whether they are composition-compatible.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCreate two migrations and test whether they are composition-compatible.\n\nEnsure `make-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 p-iso-id)] [m2 (make-migration 'b 'v2 'v3 p-iso-id)]) (migration-compatible? m1 m2))", "verify_expr": "(equal? (let* ([m1 (make-migration 'a 'v1 'v2 p-iso-id)] [m2 (make-migration 'b 'v2 'v3 p-iso-id)]) (migration-compatible? m1 m2)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration", "compatibility"], "split": "train"}
{"id": "optics_bidirectional_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Run migrate on a +1 migration with input 5.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nRun migrate on a +1 migration with input 5.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(migrate (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 5)", "verify_expr": "(= (migrate (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 5) 6)", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "numeric"], "split": "train"}
{"id": "optics_bidirectional_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Compose +1 then *2 migrations and migrate input 4 through the composed migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose +1 then *2 migrations and migrate input 4 through the composed migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 4))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 4)) 10)", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "compose"], "split": "eval"}
{"id": "optics_bidirectional_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Map migrate across three numbers with an increment migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap migrate across three numbers with an increment migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]) (map (lambda (n) (migrate m n)) '(1 2 3)))", "verify_expr": "(equal? (let ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]) (map (lambda (n) (migrate m n)) '(1 2 3))) '(2 3 4))", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "map"], "split": "train"}
{"id": "optics_bidirectional_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Flip an increment migration and migrate 10 through the flipped migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlip an increment migration and migrate 10 through the flipped migration.\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migrate f 10))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migrate f 10)) 9)", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "flip"], "split": "train"}
{"id": "optics_bidirectional_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migrate", "prompt_body": "Use migrate with an identity migration on list '(a b c).\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nUse migrate with an identity migration on list '(a b c).\n\nEnsure `migrate` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(migrate (make-identity-migration 'id 'v3) '(a b c))", "verify_expr": "(equal? (migrate (make-identity-migration 'id 'v3) '(a b c)) '(a b c))", "tags": ["tier1", "optics", "bidirectional", "composition", "migrate", "identity"], "split": "train"}
{"id": "optics_bidirectional_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Run rollback on a +1 migration with input 6.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nRun rollback on a +1 migration with input 6.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(rollback (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 6)", "verify_expr": "(= (rollback (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 6) 5)", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "numeric"], "split": "train"}
{"id": "optics_bidirectional_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Roundtrip through migrate then rollback for value 12.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nRoundtrip through migrate then rollback for value 12.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]) (rollback m (migrate m 12)))", "verify_expr": "(= (let ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))]) (rollback m (migrate m 12))) 12)", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "roundtrip"], "split": "train"}
{"id": "optics_bidirectional_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Map rollback across prefixed strings using a prefix migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap rollback across prefixed strings using a prefix migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s))))]) (map (lambda (s) (rollback m s)) '(\"v2:a\" \"v2:bc\")))", "verify_expr": "(equal? (let ([m (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s))))]) (map (lambda (s) (rollback m s)) '(\"v2:a\" \"v2:bc\"))) '(\"a\" \"bc\"))", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "map"], "split": "eval"}
{"id": "optics_bidirectional_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Compose +1 then *2 migrations and rollback 10 through the composed migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose +1 then *2 migrations and rollback 10 through the composed migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (rollback m3 10))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (rollback m3 10)) 4)", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "compose"], "split": "train"}
{"id": "optics_bidirectional_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "rollback", "prompt_body": "Flip an increment migration and rollback 10 through the flipped migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nFlip an increment migration and rollback 10 through the flipped migration.\n\nEnsure `rollback` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (rollback f 10))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (rollback f 10)) 11)", "tags": ["tier1", "optics", "bidirectional", "composition", "rollback", "flip"], "split": "train"}
{"id": "optics_bidirectional_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Call migration-apply in forward direction for an increment migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCall migration-apply in forward direction for an increment migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'forward)", "verify_expr": "(= (migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'forward) 9)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Call migration-apply in backward direction for an increment migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCall migration-apply in backward direction for an increment migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'backward)", "verify_expr": "(= (migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'backward) 7)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Evaluate migration-apply with an unsupported direction and return a caught marker symbol.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate migration-apply with an unsupported direction and return a caught marker symbol.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else 'bad-direction]) (migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'sideways))", "verify_expr": "(equal? (guard (ex [else 'bad-direction]) (migration-apply (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1)) 8 'sideways)) 'bad-direction)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "error-path"], "split": "train"}
{"id": "optics_bidirectional_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Compose +1 then *2 migrations and apply the composed migration forward to 3.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose +1 then *2 migrations and apply the composed migration forward to 3.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migration-apply m3 3 'forward))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migration-apply m3 3 'forward)) 8)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "compose"], "split": "eval"}
{"id": "optics_bidirectional_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-apply", "prompt_body": "Use migration-apply in backward mode on a flipped migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse migration-apply in backward mode on a flipped migration.\n\nEnsure `migration-apply` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migration-apply f 9 'backward))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migration-apply f 9 'backward)) 10)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-apply", "flip"], "split": "train"}
{"id": "optics_bidirectional_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Compose +1 then *2 migrations and migrate 5 through the composition.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose +1 then *2 migrations and migrate 5 through the composition.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'double 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 5))", "verify_expr": "(= (let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'double 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (migrate m3 5)) 12)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Using the same composed migration, rollback 12 to the source version value.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nUsing the same composed migration, rollback 12 to the source version value.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'double 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (rollback m3 12))", "verify_expr": "(= (let* ([m1 (make-migration 'add1 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'double 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (rollback m3 12)) 5)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Compose two compatible migrations and return their boundary versions as a pair.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose two compatible migrations and return their boundary versions as a pair.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 p-iso-id)] [m2 (make-migration 'b 'v2 'v3 p-iso-id)] [m3 (migration-compose m1 m2)]) (cons (migration-from m3) (migration-to m3)))", "verify_expr": "(equal? (let* ([m1 (make-migration 'a 'v1 'v2 p-iso-id)] [m2 (make-migration 'b 'v2 'v3 p-iso-id)] [m3 (migration-compose m1 m2)]) (cons (migration-from m3) (migration-to m3))) '(v1 . v3))", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "versions"], "split": "train"}
{"id": "optics_bidirectional_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Attempt to compose incompatible migrations and catch the failure as a symbol.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nAttempt to compose incompatible migrations and catch the failure as a symbol.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else 'mismatch]) (migration-compose (make-migration 'a 'v1 'v2 p-iso-id) (make-migration 'b 'x 'y p-iso-id)))", "verify_expr": "(equal? (guard (ex [else 'mismatch]) (migration-compose (make-migration 'a 'v1 'v2 p-iso-id) (make-migration 'b 'x 'y p-iso-id))) 'mismatch)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "error-path"], "split": "train"}
{"id": "optics_bidirectional_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-compose", "prompt_body": "Check associative behavior by comparing left- and right-associated migration-compose results on input 6.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck associative behavior by comparing left- and right-associated migration-compose results on input 6.\n\nEnsure `migration-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso sub1 add1))] [left (migration-compose (migration-compose m1 m2) m3)] [right (migration-compose m1 (migration-compose m2 m3))]) (= (migrate left 6) (migrate right 6)))", "verify_expr": "(equal? (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso sub1 add1))] [left (migration-compose (migration-compose m1 m2) m3)] [right (migration-compose m1 (migration-compose m2 m3))]) (= (migrate left 6) (migrate right 6))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-compose", "associative"], "split": "eval"}
{"id": "optics_bidirectional_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Chain +1, *2, and -3 migrations, then migrate input 5.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nChain +1, *2, and -3 migrations, then migrate input 5.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso (lambda (x) (- x 3)) (lambda (x) (+ x 3))))] [chain (migration-chain (list m1 m2 m3))]) (migrate chain 5))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (make-migration 'c 'v3 'v4 (make-p-iso (lambda (x) (- x 3)) (lambda (x) (+ x 3))))] [chain (migration-chain (list m1 m2 m3))]) (migrate chain 5)) 9)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-chain", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Chain a singleton migration list and apply migrate to 7.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nChain a singleton migration list and apply migrate to 7.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [chain (migration-chain (list m1))]) (migrate chain 7))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [chain (migration-chain (list m1))]) (migrate chain 7)) 8)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-chain", "singleton"], "split": "train"}
{"id": "optics_bidirectional_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Invoke migration-chain on an empty list and catch the expected error marker.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nInvoke migration-chain on an empty list and catch the expected error marker.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(guard (ex [else 'empty]) (migration-chain '()))", "verify_expr": "(equal? (guard (ex [else 'empty]) (migration-chain '())) 'empty)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-chain", "error-path"], "split": "train"}
{"id": "optics_bidirectional_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Chain two migrations (+1 then *2) and rollback 10.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nChain two migrations (+1 then *2) and rollback 10.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [chain (migration-chain (list m1 m2))]) (rollback chain 10))", "verify_expr": "(= (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [chain (migration-chain (list m1 m2))]) (rollback chain 10)) 4)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-chain", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-chain", "prompt_body": "Chain identity followed by increment migration and migrate input 3.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nChain identity followed by increment migration and migrate input 3.\n\nEnsure `migration-chain` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-identity-migration 'id 'v1)] [m2 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [chain (migration-chain (list m1 m2))]) (migrate chain 3))", "verify_expr": "(= (let* ([m1 (make-identity-migration 'id 'v1)] [m2 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [chain (migration-chain (list m1 m2))]) (migrate chain 3)) 4)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-chain", "identity-compose"], "split": "train"}
{"id": "optics_bidirectional_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Flip an increment migration and return its version endpoints as a pair.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nFlip an increment migration and return its version endpoints as a pair.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (cons (migration-from f) (migration-to f)))", "verify_expr": "(equal? (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (cons (migration-from f) (migration-to f))) '(v2 . v1))", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-flip", "versions"], "split": "train"}
{"id": "optics_bidirectional_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Flip an increment migration and migrate value 10.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlip an increment migration and migrate value 10.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migrate f 10))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (migrate f 10)) 9)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-flip", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_033", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Flip an increment migration and rollback value 10.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlip an increment migration and rollback value 10.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (rollback f 10))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (rollback f 10)) 11)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-flip", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_034", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Double-flip a migration and compare migrate output against the original on input 4.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDouble-flip a migration and compare migrate output against the original on input 4.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [ff (migration-flip (migration-flip m))]) (= (migrate ff 4) (migrate m 4)))", "verify_expr": "(equal? (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [ff (migration-flip (migration-flip m))]) (= (migrate ff 4) (migrate m 4))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-flip", "involution"], "split": "train"}
{"id": "optics_bidirectional_composition_035", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "migration-flip", "prompt_body": "Compose a migration with its flipped counterpart and migrate input 7.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose a migration with its flipped counterpart and migrate input 7.\n\nEnsure `migration-flip` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)] [id-like (migration-compose m f)]) (migrate id-like 7))", "verify_expr": "(= (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)] [id-like (migration-compose m f)]) (migrate id-like 7)) 7)", "tags": ["tier1", "optics", "bidirectional", "composition", "migration-flip", "compose"], "split": "train"}
{"id": "optics_bidirectional_composition_036", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Build a prefix migration from raw functions and migrate \"abc\".\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a prefix migration from raw functions and migrate \"abc\".\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(migrate (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))) \"abc\")", "verify_expr": "(equal? (migrate (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))) \"abc\") \"v2:abc\")", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_037", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Build the same prefix migration and rollback \"v2:abc\".\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild the same prefix migration and rollback \"v2:abc\".\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(rollback (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))) \"v2:abc\")", "verify_expr": "(equal? (rollback (make-migration-from-functions 'prefix 'raw 'tagged (lambda (s) (string-append \"v2:\" s)) (lambda (s) (substring s 3 (string-length s)))) \"v2:abc\") \"abc\")", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_038", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Create a migration from functions and test its version endpoints against v1->v2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate a migration from functions and test its version endpoints against v1->v2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (make-migration-from-functions 'num 'v1 'v2 add1 sub1)]) (migration-versions-match? m 'v1 'v2))", "verify_expr": "(equal? (let ([m (make-migration-from-functions 'num 'v1 'v2 add1 sub1)]) (migration-versions-match? m 'v1 'v2)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "versions"], "split": "eval"}
{"id": "optics_bidirectional_composition_039", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Compose a function-built migration with an identity migration and migrate input 2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose a function-built migration with an identity migration and migrate input 2.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration-from-functions 'num 'v1 'v2 add1 sub1)] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (migrate m3 2))", "verify_expr": "(= (let* ([m1 (make-migration-from-functions 'num 'v1 'v2 add1 sub1)] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (migrate m3 2)) 3)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "compose"], "split": "train"}
{"id": "optics_bidirectional_composition_040", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-migration-from-functions", "prompt_body": "Run verify-migration-laws over a migration created from add1/sub1.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun verify-migration-laws over a migration created from add1/sub1.\n\nEnsure `make-migration-from-functions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(verify-migration-laws (make-migration-from-functions 'num 'v1 'v2 add1 sub1) '(1 2 3) '(2 3 4))", "verify_expr": "(equal? (verify-migration-laws (make-migration-from-functions 'num 'v1 'v2 add1 sub1) '(1 2 3) '(2 3 4)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-migration-from-functions", "laws"], "split": "train"}
{"id": "optics_bidirectional_composition_041", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Migrate numeric value 42 through an identity migration.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nMigrate numeric value 42 through an identity migration.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(migrate (make-identity-migration 'id 'v5) 42)", "verify_expr": "(= (migrate (make-identity-migration 'id 'v5) 42) 42)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "forward"], "split": "train"}
{"id": "optics_bidirectional_composition_042", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Rollback list '(a b) through an identity migration.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nRollback list '(a b) through an identity migration.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(rollback (make-identity-migration 'id 'v5) '(a b))", "verify_expr": "(equal? (rollback (make-identity-migration 'id 'v5) '(a b)) '(a b))", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "backward"], "split": "train"}
{"id": "optics_bidirectional_composition_043", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Compose identity then increment migration and migrate input 5.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose identity then increment migration and migrate input 5.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-identity-migration 'id 'v1)] [m2 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m3 (migration-compose m1 m2)]) (migrate m3 5))", "verify_expr": "(= (let* ([m1 (make-identity-migration 'id 'v1)] [m2 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m3 (migration-compose m1 m2)]) (migrate m3 5)) 6)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "compose-left"], "split": "train"}
{"id": "optics_bidirectional_composition_044", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Compose increment then identity migration and rollback input 9.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose increment then identity migration and rollback input 9.\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m1 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (rollback m3 9))", "verify_expr": "(= (let* ([m1 (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-identity-migration 'id 'v2)] [m3 (migration-compose m1 m2)]) (rollback m3 9)) 8)", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "compose-right"], "split": "eval"}
{"id": "optics_bidirectional_composition_045", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "make-identity-migration", "prompt_body": "Chain two identity migrations and migrate input '(x y).\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nChain two identity migrations and migrate input '(x y).\n\nEnsure `make-identity-migration` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m1 (make-identity-migration 'id1 'v1)] [m2 (make-identity-migration 'id2 'v1)] [chain (migration-chain (list m1 m2))]) (migrate chain '(x y)))", "verify_expr": "(equal? (let* ([m1 (make-identity-migration 'id1 'v1)] [m2 (make-identity-migration 'id2 'v1)] [chain (migration-chain (list m1 m2))]) (migrate chain '(x y))) '(x y))", "tags": ["tier1", "optics", "bidirectional", "composition", "make-identity-migration", "chain"], "split": "train"}
{"id": "optics_bidirectional_composition_046", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Check laws for add1/sub1 migration on sample domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck laws for add1/sub1 migration on sample domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(verify-migration-laws (make-migration-from-functions 'num 'v1 'v2 add1 sub1) '(1 2 3) '(2 3 4))", "verify_expr": "(equal? (verify-migration-laws (make-migration-from-functions 'num 'v1 'v2 add1 sub1) '(1 2 3) '(2 3 4)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "good-laws"], "split": "train"}
{"id": "optics_bidirectional_composition_047", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Check laws for a broken migration whose backward function is identity.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck laws for a broken migration whose backward function is identity.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(verify-migration-laws (make-migration-from-functions 'bad 'v1 'v2 add1 identity) '(1 2 3) '(2 3 4))", "verify_expr": "(equal? (verify-migration-laws (make-migration-from-functions 'bad 'v1 'v2 add1 identity) '(1 2 3) '(2 3 4)) #f)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "bad-laws"], "split": "train"}
{"id": "optics_bidirectional_composition_048", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Compose +1 and *2 migrations, then verify iso laws for the composition.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose +1 and *2 migrations, then verify iso laws for the composition.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (verify-migration-laws m3 '(1 2 3) '(4 6 8)))", "verify_expr": "(equal? (let* ([m1 (make-migration 'a 'v1 'v2 (make-p-iso add1 sub1))] [m2 (make-migration 'b 'v2 'v3 (make-p-iso (lambda (x) (* x 2)) (lambda (x) (/ x 2))))] [m3 (migration-compose m1 m2)]) (verify-migration-laws m3 '(1 2 3) '(4 6 8))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "compose"], "split": "train"}
{"id": "optics_bidirectional_composition_049", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Flip an increment migration and verify its laws on reversed domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFlip an increment migration and verify its laws on reversed domains.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (verify-migration-laws f '(2 3 4) '(1 2 3)))", "verify_expr": "(equal? (let* ([m (make-migration 'inc 'v1 'v2 (make-p-iso add1 sub1))] [f (migration-flip m)]) (verify-migration-laws f '(2 3 4) '(1 2 3))) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "flip"], "split": "eval"}
{"id": "optics_bidirectional_composition_050", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/bidirectional.ss", "source_test": "lattice/optics/test-bidirectional.ss", "source_function": "verify-migration-laws", "prompt_body": "Verify laws for an identity migration over symbol samples.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify laws for an identity migration over symbol samples.\n\nEnsure `verify-migration-laws` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(verify-migration-laws (make-identity-migration 'id 'v0) '(a b c) '(a b c))", "verify_expr": "(equal? (verify-migration-laws (make-identity-migration 'id 'v0) '(a b c) '(a b c)) #t)", "tags": ["tier1", "optics", "bidirectional", "composition", "verify-migration-laws", "identity"], "split": "eval"}
