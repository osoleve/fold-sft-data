{"id": "nt_modular_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod+`\nSpec: Return (a + b) mod m for m > 0.\n\nWrite exactly one Scheme function definition for `mod+`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod+"], "split": "train"}
{"id": "nt_modular_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod+ a b m)\n  ;; TODO: return (a + b) mod m\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod+`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (mod+ 7 5 12) 0))\n(let () (= (mod+ -3 5 7) 2))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod+"], "split": "train"}
{"id": "nt_modular_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-`\nSpec: Return (a - b) mod m for m > 0.\n\nWrite exactly one Scheme function definition for `mod-`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n(let () (= (mod- 3 5 7) 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-"], "split": "train"}
{"id": "nt_modular_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod- a b m)\n  ;; TODO: return (a - b) mod m\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod-`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod-"], "split": "train"}
{"id": "nt_modular_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod*`\nSpec: Return (a * b) mod m for m > 0.\n\nWrite exactly one Scheme function definition for `mod*`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod*"], "split": "train"}
{"id": "nt_modular_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod* a b m)\n  ;; TODO: return (a * b) mod m\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod*`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (mod* 3 4 7) 5))\n(let () (= (mod* 5 6 13) 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod*"], "split": "train"}
{"id": "nt_modular_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `gcd`\nSpec: Implement Euclidean gcd and normalize the final result to non-negative.\n\nWrite exactly one Scheme function definition for `gcd`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (gcd 12 8) 4))\n(let () (= (gcd 7 0) 7))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "gcd"], "split": "train"}
{"id": "nt_modular_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (gcd a b)\n  ;; TODO: Euclidean algorithm with non-negative output\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `gcd`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (gcd 12 8) 4))\n(let () (= (gcd 7 0) 7))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "gcd"], "split": "train"}
{"id": "nt_modular_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-inverse`\nSpec: Return modular inverse of a mod m when gcd(a,m)=1, else #f.\n\nWrite exactly one Scheme function definition for `mod-inverse`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-inverse"], "split": "train"}
{"id": "nt_modular_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod-inverse a m)\n  ;; TODO: use extended-gcd and return #f when no inverse exists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod-inverse`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (mod-inverse 3 7) 5))\n(let () (= (mod-inverse 5 13) 8))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod-inverse"], "split": "train"}
{"id": "nt_modular_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `crt`\nSpec: Solve a list of congruences; return #f when any inverse is missing.\n\nWrite exactly one Scheme function definition for `crt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "crt"], "split": "train"}
{"id": "nt_modular_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (crt remainders moduli)\n  ;; TODO: combine congruences with modular inverses\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `crt`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "crt"], "split": "train"}
{"id": "nt_modular_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-reduce", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `montgomery-reduce`\nSpec: Implement Montgomery reduction with the final conditional subtraction.\n\nWrite exactly one Scheme function definition for `montgomery-reduce`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "montgomery-reduce"], "split": "train"}
{"id": "nt_modular_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-reduce", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (montgomery-reduce T m R m-prime)\n  ;; TODO: compute t then u, then conditionally subtract m\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `montgomery-reduce`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "montgomery-reduce"], "split": "train"}
{"id": "nt_modular_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `montgomery-setup`\nSpec: Compute (R, m-prime) where R is the smallest power-of-two strictly greater than m.\n\nWrite exactly one Scheme function definition for `montgomery-setup`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "montgomery-setup"], "split": "train"}
{"id": "nt_modular_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (montgomery-setup m)\n  ;; TODO: pick R as smallest power-of-two > m, compute m-prime\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `montgomery-setup`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "montgomery-setup"], "split": "train"}
{"id": "nt_modular_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `montgomery-mult`\nSpec: Multiply two Montgomery-form values via montgomery-reduce.\n\nWrite exactly one Scheme function definition for `montgomery-mult`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "montgomery-mult"], "split": "train"}
{"id": "nt_modular_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (montgomery-mult a b m R m-prime)\n  ;; TODO: multiply and reduce in Montgomery domain\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `montgomery-mult`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "montgomery-mult"], "split": "train"}
{"id": "nt_modular_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "from-montgomery", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `from-montgomery`\nSpec: Map a Montgomery value back via montgomery-reduce.\n\nWrite exactly one Scheme function definition for `from-montgomery`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "from-montgomery"], "split": "train"}
{"id": "nt_modular_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "from-montgomery", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (from-montgomery a m R m-prime)\n  ;; TODO: convert out of Montgomery form\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `from-montgomery`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "from-montgomery"], "split": "train"}
{"id": "nt_modular_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `quadratic-residue?`\nSpec: Use Euler's criterion and treat 0 as a quadratic residue.\n\nWrite exactly one Scheme function definition for `quadratic-residue?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (quadratic-residue? 4 7))\n(let () (not (quadratic-residue? 3 7)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "quadratic-residue?"], "split": "train"}
{"id": "nt_modular_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (quadratic-residue? a p)\n  ;; TODO: Euler criterion with explicit 0 case\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `quadratic-residue?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (quadratic-residue? 4 7))\n(let () (not (quadratic-residue? 3 7)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "quadratic-residue?"], "split": "train"}
{"id": "nt_modular_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `legendre-symbol`\nSpec: Return 1, -1, or 0 for odd prime p.\n\nWrite exactly one Scheme function definition for `legendre-symbol`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (legendre-symbol 1 7) 1))\n(let () (= (legendre-symbol 3 7) -1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "legendre-symbol"], "split": "train"}
{"id": "nt_modular_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (legendre-symbol a p)\n  ;; TODO: return 1, -1, or 0\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `legendre-symbol`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "legendre-symbol"], "split": "train"}
{"id": "nt_modular_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-sqrt-both`\nSpec: Return both square roots from mod-sqrt as an ordered list (smaller first), deduplicating when roots coincide.\n\nWrite exactly one Scheme function definition for `mod-sqrt-both`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))", "verify_expr": "(let ()\n  (define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))\n  (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-sqrt-both"], "split": "train"}
{"id": "nt_modular_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod-sqrt-both a p)\n  ;; TODO: call mod-sqrt and return one or two roots\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod-sqrt-both`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))", "verify_expr": "(let ()\n  (define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))\n  (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod-sqrt-both"], "split": "train"}
{"id": "nt_modular_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `mod+`.\nReturn only the Scheme definition.\n\n```python\ndef mod_add(a, b, m):\n    return (a + b) % m\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (mod+ 7 5 12) 0))\n(let () (= (mod+ -3 5 7) 2))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "mod+"], "split": "train"}
{"id": "nt_modular_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `mod+`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mod-add a b m)\n  (remainder (+ a b) m))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "mod+"], "split": "train"}
{"id": "nt_modular_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `mod-`.\nReturn only the Scheme definition.\n\n```python\ndef mod_sub(a, b, m):\n    return (a - b) % m\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n(let () (= (mod- 3 5 7) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "mod-"], "split": "train"}
{"id": "nt_modular_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `mod-`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mod-sub a b m)\n  (remainder (- a b) m))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n(let () (= (mod- 3 5 7) 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "mod-"], "split": "train"}
{"id": "nt_modular_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `mod*`.\nReturn only the Scheme definition.\n\n```python\ndef mod_mul(a, b, m):\n    return (a * b) % m\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "mod*"], "split": "train"}
{"id": "nt_modular_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `mod*`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mod-mul a b m)\n  (remainder (* a b) m))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "mod*"], "split": "train"}
{"id": "nt_modular_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `gcd`.\nReturn only the Scheme definition.\n\n```python\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (gcd 12 8) 4))\n(let () (= (gcd 7 0) 7))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "gcd"], "split": "train"}
{"id": "nt_modular_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `gcd`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (gcd0 a b)\n  (if (= b 0) a (gcd0 b (modulo a b))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (gcd 12 8) 4))\n(let () (= (gcd 7 0) 7))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "gcd"], "split": "train"}
{"id": "nt_modular_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `mod-inverse`.\nReturn only the Scheme definition.\n\n```python\ndef mod_inverse(a, m):\n    g, x, _ = egcd(a, m)\n    return x % m if g == 1 else None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (mod-inverse 3 7) 5))\n(let () (= (mod-inverse 5 13) 8))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "mod-inverse"], "split": "train"}
{"id": "nt_modular_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `mod-inverse`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (inv a m)\n  (let* ((triplet (extended-gcd a m))\n         (g (car triplet))\n         (x (cadr triplet)))\n    (if (= g 1) x #f)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "mod-inverse"], "split": "train"}
{"id": "nt_modular_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `crt`.\nReturn only the Scheme definition.\n\n```python\ndef crt(remainders, moduli):\n    if not remainders or not moduli:\n        return 0\n    M = 1\n    for m in moduli:\n        M *= m\n    total = 0\n    for ai, mi in zip(remainders, moduli):\n        Mi = M // mi\n        yi = mod_inverse(Mi, mi)\n        if yi is None:\n            return None\n        total += ai * Mi * yi\n    return total % M\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "crt"], "split": "train"}
{"id": "nt_modular_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `crt`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (crt0 rs ms)\n  (let ((M (apply * ms)))\n    (let loop ((rs rs) (ms ms) (acc 0))\n      (if (null? rs)\n          (modulo acc M)\n          (let* ((ai (car rs))\n                 (mi (car ms))\n                 (Mi (quotient M mi))\n                 (yi (mod-inverse Mi mi)))\n            (loop (cdr rs) (cdr ms) (+ acc (* ai Mi yi))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "crt"], "split": "train"}
{"id": "nt_modular_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `montgomery-setup`.\nReturn only the Scheme definition.\n\n```python\ndef mont_setup(m):\n    R = 1\n    while R <= m:\n        R <<= 1\n    _, m_inv, _ = egcd(m, R)\n    m_prime = (-m_inv) % R\n    return R, m_prime\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "montgomery-setup"], "split": "train"}
{"id": "nt_modular_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `montgomery-setup`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mont-setup m)\n  (let loop ((r 1))\n    (if (> r m)\n        (let* ((eg (extended-gcd m r))\n               (m-inv (cadr eg)))\n          (list r (modulo (- m-inv) r)))\n        (loop (* r 2)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "montgomery-setup"], "split": "train"}
{"id": "nt_modular_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `montgomery-mult`.\nReturn only the Scheme definition.\n\n```python\ndef mont_mult(a, b, m, R, m_prime):\n    T = a * b\n    t = (T * m_prime) % R\n    u = (T + t * m) // R\n    return u - m if u >= m else u\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "montgomery-mult"], "split": "train"}
{"id": "nt_modular_translation_020", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `montgomery-mult`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mont-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "montgomery-mult"], "split": "train"}
{"id": "nt_modular_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `quadratic-residue?`.\nReturn only the Scheme definition.\n\n```python\ndef is_qr(a, p):\n    a_mod = a % p\n    return a_mod == 0 or pow(a_mod, (p - 1) // 2, p) == 1\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (quadratic-residue? 4 7))\n(let () (not (quadratic-residue? 3 7)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "quadratic-residue?"], "split": "train"}
{"id": "nt_modular_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `quadratic-residue?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (qr? a p)\n  (= 1 (mod-expt (modulo a p) (quotient (- p 1) 2) p)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (quadratic-residue? 4 7))\n(let () (not (quadratic-residue? 3 7)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "quadratic-residue?"], "split": "train"}
{"id": "nt_modular_translation_023", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `legendre-symbol`.\nReturn only the Scheme definition.\n\n```python\ndef legendre(a, p):\n    a_mod = a % p\n    if a_mod == 0:\n        return 0\n    return 1 if pow(a_mod, (p - 1) // 2, p) == 1 else -1\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (legendre-symbol 1 7) 1))\n(let () (= (legendre-symbol 3 7) -1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "legendre-symbol"], "split": "train"}
{"id": "nt_modular_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `legendre-symbol`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (legendre0 a p)\n  (cond ((= (modulo a p) 0) 0)\n        ((= 1 (mod-expt (modulo a p) (quotient (- p 1) 2) p)) 1)\n        (else -1)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (legendre-symbol 1 7) 1))\n(let () (= (legendre-symbol 3 7) -1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "legendre-symbol"], "split": "train"}
{"id": "nt_modular_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod+` in `lattice/number-theory/modular.ss`.\nKnown issue: Negative inputs should still normalize to [0, m).\n\n```scheme\n(define (mod+ a b m)\n  (remainder (+ a b) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Negative inputs should still normalize to [0, m).\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod+ 7 5 12) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod+"], "split": "train"}
{"id": "nt_modular_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod+` in `lattice/number-theory/modular.ss`.\nKnown issue: The modulus is ignored.\n\n```scheme\n(define (mod+ a b m)\n  (+ a b))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The modulus is ignored.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod+ 7 5 12) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod+ 7 5 12) 0))\n(let () (= (mod+ -3 5 7) 2))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod+"], "split": "train"}
{"id": "nt_modular_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-` in `lattice/number-theory/modular.ss`.\nKnown issue: Subtracting in the wrong order flips results.\n\n```scheme\n(define (mod- a b m)\n  (modulo (- b a) m))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Subtracting in the wrong order flips results.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n(let () (= (mod- 3 5 7) 5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-"], "split": "train"}
{"id": "nt_modular_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-` in `lattice/number-theory/modular.ss`.\nKnown issue: Result is not reduced modulo m.\n\n```scheme\n(define (mod- a b m)\n  (- a b))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod- 5 3 7) 2))\n(let () (= (mod- 3 5 7) 5))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-"], "split": "train"}
{"id": "nt_modular_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod*` in `lattice/number-theory/modular.ss`.\nKnown issue: Must reduce the product modulo m.\n\n```scheme\n(define (mod* a b m)\n  (* a b))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must reduce the product modulo m.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod* 3 4 7) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod* 3 4 7) 5))\n(let () (= (mod* 5 6 13) 4))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod*"], "split": "train"}
{"id": "nt_modular_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod*` in `lattice/number-theory/modular.ss`.\nKnown issue: Addition is used instead of multiplication.\n\n```scheme\n(define (mod* a b m)\n  (modulo (+ a b) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Addition is used instead of multiplication.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod* 3 4 7) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod* 3 4 7) 5))\n(let () (= (mod* 5 6 13) 4))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod* a b m)\n  (modulo (* a b) m))", "verify_expr": "(let ()\n  (define (mod* a b m)\n  (modulo (* a b) m))\n  (and (= (mod* 3 4 7) 5) (= (mod* 5 6 13) 4) (= (mod* 123 456 1000) 88)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod*"], "split": "train"}
{"id": "nt_modular_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `gcd` in `lattice/number-theory/modular.ss`.\nKnown issue: Result sign should be normalized.\n\n```scheme\n(define (gcd a b)\n  (if (= b 0)\n      a\n      (gcd b (modulo a b))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "gcd"], "split": "train"}
{"id": "nt_modular_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `gcd` in `lattice/number-theory/modular.ss`.\nKnown issue: Euclidean step should use modulo, not quotient.\n\n```scheme\n(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (quotient a b))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "gcd"], "split": "train"}
{"id": "nt_modular_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-inverse` in `lattice/number-theory/modular.ss`.\nKnown issue: Inverse should be reduced modulo m.\n\n```scheme\n(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)] [g (car result)] [x (cadr result)])\n    (if (= g 1) x #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod-inverse 3 7) 5))\n(let () (= (mod-inverse 5 13) 8))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-inverse"], "split": "train"}
{"id": "nt_modular_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-inverse` in `lattice/number-theory/modular.ss`.\nKnown issue: The invertibility check is against the wrong gcd value.\n\n```scheme\n(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)] [g (car result)] [x (cadr result)])\n    (if (= g -1) (modulo x m) #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The invertibility check is against the wrong gcd value.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod-inverse 3 7) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod-inverse 3 7) 5))\n(let () (= (mod-inverse 5 13) 8))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-inverse"], "split": "train"}
{"id": "nt_modular_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `crt` in `lattice/number-theory/modular.ss`.\nKnown issue: When yi is #f, solver should fail instead of multiplying by #f.\n\n```scheme\n(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders] [ms moduli] [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)] [mi (car ms)] [Mi (quotient M mi)] [yi (mod-inverse Mi mi)])\n                (loop (cdr rs) (cdr ms) (+ result (* ai Mi yi)))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: When yi is #f, solver should fail instead of multiplying by #f.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "crt"], "split": "train"}
{"id": "nt_modular_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `crt` in `lattice/number-theory/modular.ss`.\nKnown issue: M must be the product of moduli, not the sum.\n\n```scheme\n(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left + 0 moduli)])\n        (let loop ([rs remainders] [ms moduli] [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)] [mi (car ms)] [Mi (quotient M mi)] [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs) (cdr ms) (+ result (* ai Mi yi)))\n                    #f)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: M must be the product of moduli, not the sum.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "crt"], "split": "train"}
{"id": "nt_modular_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-reduce", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `montgomery-reduce` in `lattice/number-theory/modular.ss`.\nKnown issue: Need final conditional subtraction when u >= m.\n\n```scheme\n(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    u))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "montgomery-reduce"], "split": "train"}
{"id": "nt_modular_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `montgomery-setup` in `lattice/number-theory/modular.ss`.\nKnown issue: R must be strictly greater than m.\n\n```scheme\n(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (>= r m) r (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: R must be strictly greater than m.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "montgomery-setup"], "split": "train"}
{"id": "nt_modular_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `montgomery-mult` in `lattice/number-theory/modular.ss`.\nKnown issue: Montgomery multiplication should call montgomery-reduce.\n\n```scheme\n(define (montgomery-mult a b m R m-prime)\n  (modulo (* a b) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "montgomery-mult"], "split": "train"}
{"id": "nt_modular_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "from-montgomery", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `from-montgomery` in `lattice/number-theory/modular.ss`.\nKnown issue: Conversion from Montgomery domain requires montgomery-reduce.\n\n```scheme\n(define (from-montgomery a m R m-prime)\n  (modulo a m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Conversion from Montgomery domain requires montgomery-reduce.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "from-montgomery"], "split": "train"}
{"id": "nt_modular_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `quadratic-residue?` in `lattice/number-theory/modular.ss`.\nKnown issue: a == 0 mod p is also a quadratic residue.\n\n```scheme\n(define (quadratic-residue? a p)\n  (= 1 (mod-expt (modulo a p) (quotient (- p 1) 2) p)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: a == 0 mod p is also a quadratic residue.\n\nExpected behavior after patch:\n```scheme\n(let () (quadratic-residue? 4 7))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (quadratic-residue? 4 7))\n(let () (not (quadratic-residue? 3 7)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "quadratic-residue?"], "split": "train"}
{"id": "nt_modular_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `legendre-symbol` in `lattice/number-theory/modular.ss`.\nKnown issue: Return value must be 1 or -1, not booleans.\n\n```scheme\n(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (if (= a-mod 0)\n        0\n        (quadratic-residue? a-mod p))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Return value must be 1 or -1, not booleans.\n\nExpected behavior after patch:\n```scheme\n(let () (= (legendre-symbol 1 7) 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "legendre-symbol"], "split": "train"}
{"id": "nt_modular_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-sqrt-both` in `lattice/number-theory/modular.ss`.\nKnown issue: Roots must be reduced modulo p, ordered smaller-first, and deduplicated.\n\n```scheme\n(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (list r (- p r))\n        #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))", "verify_expr": "(let ()\n  (define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))\n  (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-sqrt-both"], "split": "train"}
{"id": "nt_modular_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-sqrt-both` in `lattice/number-theory/modular.ss`.\nKnown issue: Second root should be p-r (mod p) unless both roots coincide.\n\n```scheme\n(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (list r r)\n        #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))", "verify_expr": "(let ()\n  (define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))\n  (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-sqrt-both"], "split": "train"}
{"id": "nt_modular_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute (7 + 5) mod 12 using `mod+`. Return a single Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod+ 7 5 12)", "verify_expr": "(equal? (let () (mod+ 7 5 12)) (modulo (+ 7 5) 12))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "direct"], "split": "train"}
{"id": "nt_modular_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (-22 + 8) mod 17 using `mod+`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod+ -22 8 17)", "verify_expr": "(equal? (let () (mod+ -22 8 17)) (modulo (+ -22 8) 17))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "direct"], "split": "train"}
{"id": "nt_modular_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute (123 + 456) mod 97 using `mod+`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod+ 123 456 97)", "verify_expr": "(equal? (let () (mod+ 123 456 97)) (modulo (+ 123 456) 97))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "direct"], "split": "train"}
{"id": "nt_modular_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (0 + 9) mod 11 using `mod+`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod+ 0 9 11)", "verify_expr": "(equal? (let () (mod+ 0 9 11)) (modulo (+ 0 9) 11))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "direct"], "split": "train"}
{"id": "nt_modular_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (3 - 5) mod 7 using `mod-`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod- 3 5 7)", "verify_expr": "(equal? (let () (mod- 3 5 7)) (modulo (- 3 5) 7))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "direct"], "split": "train"}
{"id": "nt_modular_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (42 - 58) mod 100 using `mod-`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod- 42 58 100)", "verify_expr": "(equal? (let () (mod- 42 58 100)) (modulo (- 42 58) 100))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "direct"], "split": "train"}
{"id": "nt_modular_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (999 - 1) mod 10 using `mod-`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod- 999 1 10)", "verify_expr": "(equal? (let () (mod- 999 1 10)) (modulo (- 999 1) 10))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "direct"], "split": "train"}
{"id": "nt_modular_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute (0 - 9) mod 11 using `mod-`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod- 0 9 11)", "verify_expr": "(equal? (let () (mod- 0 9 11)) (modulo (- 0 9) 11))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "direct"], "split": "train"}
{"id": "nt_modular_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (3 * 4) mod 7 with `mod*`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod* 3 4 7)", "verify_expr": "(equal? (let () (mod* 3 4 7)) (modulo (* 3 4) 7))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "direct"], "split": "train"}
{"id": "nt_modular_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (-22 * 8) mod 17 with `mod*`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod* -22 8 17)", "verify_expr": "(equal? (let () (mod* -22 8 17)) (modulo (* -22 8) 17))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "direct"], "split": "train"}
{"id": "nt_modular_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (123 * 456) mod 1000 with `mod*`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod* 123 456 1000)", "verify_expr": "(equal? (let () (mod* 123 456 1000)) (modulo (* 123 456) 1000))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "direct"], "split": "train"}
{"id": "nt_modular_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (77 * 91) mod 97 with `mod*`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod* 77 91 97)", "verify_expr": "(equal? (let () (mod* 77 91 97)) (modulo (* 77 91) 97))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "direct"], "split": "train"}
{"id": "nt_modular_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn a boolean that checks commutativity: mod+(81,23,29) == mod+(23,81,29).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (mod+ 81 23 29) (mod+ 23 81 29))", "verify_expr": "(equal? (let () (= (mod+ 81 23 29) (mod+ 23 81 29))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "property"], "split": "train"}
{"id": "nt_modular_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: small integration task across module primitives.\n\nCheck associativity for modular addition with a=5, b=9, c=14, m=17.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod+ (mod+ 5 9 17) 14 17) (mod+ 5 (mod+ 9 14 17) 17))", "verify_expr": "(equal? (let () (= (mod+ (mod+ 5 9 17) 14 17) (mod+ 5 (mod+ 9 14 17) 17))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "property"], "split": "train"}
{"id": "nt_modular_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that modular subtraction equals adding a negated value for a=15,b=42,m=23.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod- 15 42 23) (mod+ 15 (- 42) 23))", "verify_expr": "(equal? (let () (= (mod- 15 42 23) (mod+ 15 (- 42) 23))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "property"], "split": "train"}
{"id": "nt_modular_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nCheck the identity mod-(a,a,m)=0 for a=37,m=19.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod- 37 37 19) 0)", "verify_expr": "(equal? (let () (= (mod- 37 37 19) 0)) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "property"], "split": "train"}
{"id": "nt_modular_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn a boolean that checks commutativity for mod* with a=12,b=31,m=37.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (mod* 12 31 37) (mod* 31 12 37))", "verify_expr": "(equal? (let () (= (mod* 12 31 37) (mod* 31 12 37))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "property"], "split": "train"}
{"id": "nt_modular_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck distributivity: a*(b+c) mod m equals a*b + a*c mod m for a=7,b=9,c=13,m=23.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (mod* 7 (mod+ 9 13 23) 23) (mod+ (mod* 7 9 23) (mod* 7 13 23) 23))", "verify_expr": "(equal? (let () (= (mod* 7 (mod+ 9 13 23) 23) (mod+ (mod* 7 9 23) (mod* 7 13 23) 23))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "property"], "split": "train"}
{"id": "nt_modular_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: small integration task across module primitives.\n\nCheck multiplicative identity for a=-44,m=29.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod* -44 1 29) (modulo -44 29))", "verify_expr": "(equal? (let () (= (mod* -44 1 29) (modulo -44 29))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "property"], "split": "train"}
{"id": "nt_modular_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse map with `mod+` on pair list ((3 5) (10 9) (14 -2)) modulo 13.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map (lambda (p) (mod+ (car p) (cadr p) 13)) '((3 5) (10 9) (14 -2)))", "verify_expr": "(equal? (let () (map (lambda (p) (mod+ (car p) (cadr p) 13)) '((3 5) (10 9) (14 -2)))) '(8 6 12))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "list"], "split": "train"}
{"id": "nt_modular_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: small integration task across module primitives.\n\nUse map with `mod-` on pair list ((2 9) (15 4) (-3 8)) modulo 13.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map (lambda (p) (mod- (car p) (cadr p) 13)) '((2 9) (15 4) (-3 8)))", "verify_expr": "(equal? (let () (map (lambda (p) (mod- (car p) (cadr p) 13)) '((2 9) (15 4) (-3 8)))) '(6 11 2))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-", "list"], "split": "train"}
{"id": "nt_modular_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap `mod*` with scalar 7 modulo 17 over '(1 2 3 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (x) (mod* x 7 17)) '(1 2 3 4 5))", "verify_expr": "(equal? (let () (map (lambda (x) (mod* x 7 17)) '(1 2 3 4 5))) '(7 14 4 11 1))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "list"], "split": "train"}
{"id": "nt_modular_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute modular sum of '(12 19 7 5) modulo 13 using a named-let accumulator.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([xs '(12 19 7 5)] [acc 0]) (if (null? xs) acc (loop (cdr xs) (mod+ acc (car xs) 13))))", "verify_expr": "(equal? (let () (let loop ([xs '(12 19 7 5)] [acc 0]) (if (null? xs) acc (loop (cdr xs) (mod+ acc (car xs) 13))))) 4)", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "list", "fold"], "split": "train"}
{"id": "nt_modular_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: small integration task across module primitives.\n\nCompute modular product of '(3 4 5 6) modulo 17 using a named-let accumulator.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([xs '(3 4 5 6)] [acc 1]) (if (null? xs) acc (loop (cdr xs) (mod* acc (car xs) 17))))", "verify_expr": "(equal? (let () (let loop ([xs '(3 4 5 6)] [acc 1]) (if (null? xs) acc (loop (cdr xs) (mod* acc (car xs) 17))))) 3)", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "list", "fold"], "split": "train"}
{"id": "nt_modular_composition_034", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: small integration task across module primitives.\n\nMap `mod-inverse` over all non-zero residues modulo 11.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (a) (mod-inverse a 11)) '(1 2 3 4 5 6 7 8 9 10))", "verify_expr": "(equal? (let () (map (lambda (a) (mod-inverse a 11)) '(1 2 3 4 5 6 7 8 9 10))) '(1 6 4 3 9 2 8 7 5 10))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-inverse", "list"], "split": "train"}
{"id": "nt_modular_composition_035", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff every non-zero residue modulo 11 satisfies a*inv(a)=1.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([as '(1 2 3 4 5 6 7 8 9 10)]) (if (null? as) #t (let* ([a (car as)] [inv (mod-inverse a 11)]) (and inv (= (mod* a inv 11) 1) (loop (cdr as))))))", "verify_expr": "(equal? (let () (let loop ([as '(1 2 3 4 5 6 7 8 9 10)]) (if (null? as) #t (let* ([a (car as)] [inv (mod-inverse a 11)]) (and inv (= (mod* a inv 11) 1) (loop (cdr as))))))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-inverse", "list", "property"], "split": "train"}
{"id": "nt_modular_composition_036", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve CRT for (2,3,2)/(3,5,7), then return a list confirming each congruence.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([x (crt '(2 3 2) '(3 5 7))]) (list (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2)))", "verify_expr": "(equal? (let () (let ([x (crt '(2 3 2) '(3 5 7))]) (list (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2)))) '(#t #t #t))", "tags": ["tier0", "number-theory", "modular", "composition", "crt", "list", "composition"], "split": "train"}
{"id": "nt_modular_composition_037", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate gcd(240, 46) with `gcd`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(gcd 240 46)", "verify_expr": "(equal? (let () (gcd 240 46)) 2)", "tags": ["tier0", "number-theory", "modular", "composition", "gcd", "integration"], "split": "train"}
{"id": "nt_modular_composition_038", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate gcd(-99, 78) with `gcd` and rely on normalized sign.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(gcd -99 78)", "verify_expr": "(equal? (let () (gcd -99 78)) 3)", "tags": ["tier0", "number-theory", "modular", "composition", "gcd", "integration"], "split": "train"}
{"id": "nt_modular_composition_039", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute lcm(12,18) from gcd using lcm(a,b)=|ab|/gcd(a,b).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a 12] [b 18]) (quotient (abs (* a b)) (gcd a b)))", "verify_expr": "(equal? (let () (let ([a 12] [b 18]) (quotient (abs (* a b)) (gcd a b)))) 36)", "tags": ["tier0", "number-theory", "modular", "composition", "gcd", "integration"], "split": "train"}
{"id": "nt_modular_composition_043", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute inverse of 3 mod 7 with `mod-inverse`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod-inverse 3 7)", "verify_expr": "(equal? (let () (mod-inverse 3 7)) 5)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-inverse", "integration"], "split": "train"}
{"id": "nt_modular_composition_044", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute inverse of 10 mod 15 with `mod-inverse` (expect #f).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod-inverse 10 15)", "verify_expr": "(equal? (let () (mod-inverse 10 15)) #f)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-inverse", "integration"], "split": "train"}
{"id": "nt_modular_composition_045", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck multiplicative inverse property for a=5, m=13 in one expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([inv (mod-inverse 5 13)]) (and inv (= (mod* 5 inv 13) 1)))", "verify_expr": "(equal? (let () (let ([inv (mod-inverse 5 13)]) (and inv (= (mod* 5 inv 13) 1)))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-inverse", "integration"], "split": "train"}
{"id": "nt_modular_composition_046", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSolve x=2 (mod 3), x=3 (mod 5), x=2 (mod 7) via `crt`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(crt '(2 3 2) '(3 5 7))", "verify_expr": "(equal? (let () (crt '(2 3 2) '(3 5 7))) 23)", "tags": ["tier0", "number-theory", "modular", "composition", "crt", "integration"], "split": "train"}
{"id": "nt_modular_composition_047", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve x=1 (mod 2), x=2 (mod 3), x=3 (mod 5) via `crt`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(crt '(1 2 3) '(2 3 5))", "verify_expr": "(equal? (let () (crt '(1 2 3) '(2 3 5))) 23)", "tags": ["tier0", "number-theory", "modular", "composition", "crt", "integration"], "split": "train"}
{"id": "nt_modular_composition_048", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate `crt` on empty congruence lists.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(crt '() '())", "verify_expr": "(equal? (let () (crt '() '())) 0)", "tags": ["tier0", "number-theory", "modular", "composition", "crt", "integration", "edge-case"], "split": "train"}
{"id": "nt_modular_composition_049", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCall `montgomery-setup` with modulus 17 and return R.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (montgomery-setup 17))", "verify_expr": "(let ([r (let () (car (montgomery-setup 17)))]) (and (> r 17) (= (bitwise-and r (- r 1)) 0)))", "tags": ["tier0", "number-theory", "modular", "composition", "montgomery-setup", "montgomery"], "split": "train"}
{"id": "nt_modular_composition_051", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMultiply 3 and 5 modulo 17 using Montgomery-domain conversion and `montgomery-mult`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)]) (from-montgomery prodM m R m-prime))", "verify_expr": "(equal? (let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)]) (from-montgomery prodM m R m-prime))) 15)", "tags": ["tier0", "number-theory", "modular", "composition", "montgomery-mult", "montgomery"], "split": "train"}
{"id": "nt_modular_composition_052", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-reduce", "prompt": "Task mode: small integration task across module primitives.\n\nUse `montgomery-reduce` on the edge case T=17, m=17 (with setup-derived R,m-prime).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (montgomery-reduce 17 17 R m-prime))", "verify_expr": "(equal? (let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (montgomery-reduce 17 17 R m-prime))) 0)", "tags": ["tier0", "number-theory", "modular", "composition", "montgomery-reduce", "montgomery", "edge-case"], "split": "train"}
{"id": "nt_modular_composition_055", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck whether 4 is a quadratic residue mod 7.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(quadratic-residue? 4 7)", "verify_expr": "(equal? (let () (quadratic-residue? 4 7)) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "quadratic-residue?", "quadratic"], "split": "train"}
{"id": "nt_modular_composition_056", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether 3 is a quadratic residue mod 7.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(quadratic-residue? 3 7)", "verify_expr": "(equal? (let () (quadratic-residue? 3 7)) #f)", "tags": ["tier0", "number-theory", "modular", "composition", "quadratic-residue?", "quadratic"], "split": "train"}
{"id": "nt_modular_composition_057", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute Legendre symbol (3/7) with `legendre-symbol`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(legendre-symbol 3 7)", "verify_expr": "(equal? (let () (legendre-symbol 3 7)) -1)", "tags": ["tier0", "number-theory", "modular", "composition", "legendre-symbol", "quadratic"], "split": "train"}
{"id": "nt_modular_composition_058", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: small integration task across module primitives.\n\nCompute Legendre symbol (4/7) with `legendre-symbol`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(legendre-symbol 4 7)", "verify_expr": "(equal? (let () (legendre-symbol 4 7)) 1)", "tags": ["tier0", "number-theory", "modular", "composition", "legendre-symbol", "quadratic"], "split": "train"}
{"id": "nt_modular_composition_059", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: small integration task across module primitives.\n\nReturn both square roots of 4 modulo 13 using `mod-sqrt-both`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod-sqrt-both 4 13)", "verify_expr": "(let ([roots (let () (mod-sqrt-both 4 13))]) (and roots (= (length roots) 2) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4)))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-sqrt-both", "quadratic"], "split": "train"}
{"id": "nt_modular_composition_060", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff roots of 9 modulo 13 are valid and sum to 13.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([roots (mod-sqrt-both 9 13)]) (and roots (= (length roots) 2) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 9) (= (modulo (* (cadr roots) (cadr roots)) 13) 9)))", "verify_expr": "(equal? (let () (let ([roots (mod-sqrt-both 9 13)]) (and roots (= (length roots) 2) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 9) (= (modulo (* (cadr roots) (cadr roots)) 13) 9)))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-sqrt-both", "quadratic"], "split": "train"}
