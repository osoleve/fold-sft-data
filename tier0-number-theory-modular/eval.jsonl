{"id": "nt_modular_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-`\nSpec: Return (a - b) mod m for m > 0.\n\nWrite exactly one Scheme function definition for `mod-`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (mod- 5 3 7) 2)\n(= (mod- 3 5 7) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod- a b m)\n  (modulo (- a b) m))", "verify_expr": "(let ()\n  (define (mod- a b m)\n  (modulo (- a b) m))\n  (and (= (mod- 5 3 7) 2) (= (mod- 3 5 7) 5) (= (mod- 10 15 13) 8)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-"], "split": "eval"}
{"id": "nt_modular_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-expt`\nSpec: Implement square-and-multiply modular exponentiation for exp >= 0.\n\nWrite exactly one Scheme function definition for `mod-expt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-expt"], "split": "eval"}
{"id": "nt_modular_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-inverse", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-inverse`\nSpec: Return modular inverse of a mod m when gcd(a,m)=1, else #f.\n\nWrite exactly one Scheme function definition for `mod-inverse`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (and (= (mod-inverse 3 7) 5) (= (mod-inverse 5 13) 8) (not (mod-inverse 10 15))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-inverse"], "split": "eval"}
{"id": "nt_modular_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-mult", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `montgomery-mult`\nSpec: Multiply two Montgomery-form values via montgomery-reduce.\n\nWrite exactly one Scheme function definition for `montgomery-mult`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (montgomery-mult a b m R m-prime)\n  (montgomery-reduce (* a b) m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [aM (to-montgomery 3 m R)] [bM (to-montgomery 5 m R)] [prodM (montgomery-mult aM bM m R m-prime)] [prod (from-montgomery prodM m R m-prime)]) (= prod 15)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "montgomery-mult"], "split": "eval"}
{"id": "nt_modular_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "from-montgomery", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `from-montgomery`\nSpec: Map a Montgomery value back via montgomery-reduce.\n\nWrite exactly one Scheme function definition for `from-montgomery`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))", "verify_expr": "(let ()\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 11 m R)]) (= (from-montgomery x m R m-prime) 11)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "from-montgomery"], "split": "eval"}
{"id": "nt_modular_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "crt", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `crt`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (crt0 rs ms)\n  (let ((M (apply * ms)))\n    (let loop ((rs rs) (ms ms) (acc 0))\n      (if (null? rs)\n          (modulo acc M)\n          (let* ((ai (car rs))\n                 (mi (car ms))\n                 (Mi (quotient M mi))\n                 (yi (mod-inverse Mi mi)))\n            (loop (cdr rs) (cdr ms) (+ acc (* ai Mi yi))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (mod-inverse a m)\n  (let* ([result (extended-gcd a m)]\n         [g (car result)]\n         [x (cadr result)])\n    (if (= g 1)\n        (modulo x m)\n        #f)))\n  (define (crt remainders moduli)\n  (if (or (null? remainders) (null? moduli))\n      0\n      (let ([M (fold-left * 1 moduli)])\n        (let loop ([rs remainders]\n                   [ms moduli]\n                   [result 0])\n          (if (null? rs)\n              (modulo result M)\n              (let* ([ai (car rs)]\n                     [mi (car ms)]\n                     [Mi (quotient M mi)]\n                     [yi (mod-inverse Mi mi)])\n                (if yi\n                    (loop (cdr rs)\n                          (cdr ms)\n                          (+ result (* ai Mi yi)))\n                    #f)))))))\n  (let ([x (crt '(2 3 2) '(3 5 7))] [bad (crt '(1 1) '(2 4))]) (and x (= (modulo x 3) 2) (= (modulo x 5) 3) (= (modulo x 7) 2) (not bad))))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "crt"], "split": "eval"}
{"id": "nt_modular_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-setup", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `montgomery-setup`.\nReturn only the Scheme definition.\n\n```python\ndef mont_setup(m):\n    R = 1\n    while R <= m:\n        R <<= 1\n    _, m_inv, _ = egcd(m, R)\n    m_prime = (-m_inv) % R\n    return R, m_prime\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (let* ([setup (montgomery-setup 1)] [R (car setup)] [m-prime (cadr setup)]) (and (> R 1) (= (bitwise-and R (- R 1)) 0) (= (modulo (+ (* 1 m-prime) 1) R) 0))))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "montgomery-setup"], "split": "eval"}
{"id": "nt_modular_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "quadratic-residue?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `quadratic-residue?`.\nReturn only the Scheme definition.\n\n```python\ndef is_qr(a, p):\n    a_mod = a % p\n    return a_mod == 0 or pow(a_mod, (p - 1) // 2, p) == 1\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(quadratic-residue? 4 7)\n(not (quadratic-residue? 3 7))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (quadratic-residue? a p)\n  (let ([a-mod (modulo a p)])\n    (or (= a-mod 0)\n        (= 1 (mod-expt a-mod (quotient (- p 1) 2) p)))))\n  (and (quadratic-residue? 4 7) (not (quadratic-residue? 3 7)) (quadratic-residue? 0 7)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "quadratic-residue?"], "split": "eval"}
{"id": "nt_modular_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "legendre-symbol", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `legendre-symbol`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (legendre0 a p)\n  (cond ((= (modulo a p) 0) 0)\n        ((= 1 (mod-expt (modulo a p) (quotient (- p 1) 2) p)) 1)\n        (else -1)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (legendre-symbol 1 7) 1)\n(= (legendre-symbol 3 7) -1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (define (legendre-symbol a p)\n  (let ([a-mod (modulo a p)])\n    (cond\n      [(= a-mod 0) 0]\n      [(= 1 (mod-expt a-mod (quotient (- p 1) 2) p)) 1]\n      [else -1])))\n  (and (= (legendre-symbol 1 7) 1) (= (legendre-symbol 3 7) -1) (= (legendre-symbol 0 7) 0)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "legendre-symbol"], "split": "eval"}
{"id": "nt_modular_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod+` in `lattice/number-theory/modular.ss`.\nKnown issue: Negative inputs should still normalize to [0, m).\n\n```scheme\n(define (mod+ a b m)\n  (remainder (+ a b) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod+ a b m)\n  (modulo (+ a b) m))", "verify_expr": "(let ()\n  (define (mod+ a b m)\n  (modulo (+ a b) m))\n  (and (= (mod+ 7 5 12) 0) (= (mod+ -3 5 7) 2) (= (mod+ -8 3 7) 2) (= (mod+ 10 15 13) 12)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod+"], "split": "eval"}
{"id": "nt_modular_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "gcd", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `gcd` in `lattice/number-theory/modular.ss`.\nKnown issue: Result sign should be normalized.\n\n```scheme\n(define (gcd a b)\n  (if (= b 0)\n      a\n      (gcd b (modulo a b))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))", "verify_expr": "(let ()\n  (define (gcd a b)\n  (if (= b 0)\n      (abs a)\n      (gcd b (modulo a b))))\n  (and (= (gcd 12 8) 4) (= (gcd 7 0) 7) (= (gcd -12 8) 4) (= (gcd 12 -8) 4)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "gcd"], "split": "eval"}
{"id": "nt_modular_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "montgomery-reduce", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `montgomery-reduce` in `lattice/number-theory/modular.ss`.\nKnown issue: Need final conditional subtraction when u >= m.\n\n```scheme\n(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    u))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)]) (= (montgomery-reduce 17 17 R m-prime) 0)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "montgomery-reduce"], "split": "eval"}
{"id": "nt_modular_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-sqrt-both` in `lattice/number-theory/modular.ss`.\nKnown issue: Second root should be p-r (mod p) unless both roots coincide.\n\n```scheme\n(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (list r r)\n        #f)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))", "verify_expr": "(let ()\n  (define (mod-sqrt-both a p)\n  (let ([r (mod-sqrt a p)])\n    (if r\n        (let ([r2 (modulo (- p r) p)])\n          (if (= r r2)\n              (list r)\n              (if (<= r r2)\n                  (list r r2)\n                  (list r2 r))))\n        #f)))\n  (let ([roots (mod-sqrt-both 4 13)] [roots0 (mod-sqrt-both 0 13)]) (and roots (= (length roots) 2) (<= (car roots) (cadr roots)) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 4) (= (modulo (* (cadr roots) (cadr roots)) 13) 4) (equal? roots0 '(0)))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-sqrt-both"], "split": "eval"}
{"id": "nt_modular_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute (7 + 5) mod 12 using `mod+`. Return a single Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let () (mod+ 7 5 12)) (modulo (+ 7 5) 12))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod+ 7 5 12)", "verify_expr": "(equal? (let () (mod+ 7 5 12)) (modulo (+ 7 5) 12))", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "direct"], "split": "eval"}
{"id": "nt_modular_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (123 * 456) mod 1000 with `mod*`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let () (mod* 123 456 1000)) (modulo (* 123 456) 1000))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod* 123 456 1000)", "verify_expr": "(equal? (let () (mod* 123 456 1000)) (modulo (* 123 456) 1000))", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "direct"], "split": "eval"}
{"id": "nt_modular_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod*", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn a boolean that checks commutativity for mod* with a=12,b=31,m=37.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (mod* 12 31 37) (mod* 31 12 37))", "verify_expr": "(equal? (let () (= (mod* 12 31 37) (mod* 31 12 37))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod*", "property"], "split": "eval"}
{"id": "nt_modular_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod+", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute modular sum of '(12 19 7 5) modulo 13 using a named-let accumulator.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let () (let loop ([xs '(12 19 7 5)] [acc 0]) (if (null? xs) acc (loop (cdr xs) (mod+ acc (car xs) 13))))) 4)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([xs '(12 19 7 5)] [acc 0]) (if (null? xs) acc (loop (cdr xs) (mod+ acc (car xs) 13))))", "verify_expr": "(equal? (let () (let loop ([xs '(12 19 7 5)] [acc 0]) (if (null? xs) acc (loop (cdr xs) (mod+ acc (car xs) 13))))) 4)", "tags": ["tier0", "number-theory", "modular", "composition", "mod+", "list", "fold"], "split": "eval"}
{"id": "nt_modular_composition_040", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff extended-gcd satisfies Bezout identity for (240,46).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (= g (+ (* 240 x) (* 46 y))))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (= g (+ (* 240 x) (* 46 y))))", "verify_expr": "(equal? (let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (= g (+ (* 240 x) (* 46 y))))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "extended-gcd", "integration"], "split": "eval"}
{"id": "nt_modular_composition_050", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "to-montgomery", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert 5 into Montgomery form for modulus 17, then round-trip back in one expression.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 5 17 R)]) (from-montgomery x 17 R m-prime))) 5)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 5 17 R)]) (from-montgomery x 17 R m-prime))", "verify_expr": "(equal? (let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 5 17 R)]) (from-montgomery x 17 R m-prime))) 5)", "tags": ["tier0", "number-theory", "modular", "composition", "to-montgomery", "montgomery"], "split": "eval"}
{"id": "nt_modular_composition_060", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-sqrt-both", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff roots of 9 modulo 13 are valid and sum to 13.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([roots (mod-sqrt-both 9 13)]) (and roots (= (length roots) 2) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 9) (= (modulo (* (cadr roots) (cadr roots)) 13) 9)))", "verify_expr": "(equal? (let () (let ([roots (mod-sqrt-both 9 13)]) (and roots (= (length roots) 2) (= (+ (car roots) (cadr roots)) 13) (= (modulo (* (car roots) (car roots)) 13) 9) (= (modulo (* (cadr roots) (cadr roots)) 13) 9)))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-sqrt-both", "quadratic"], "split": "eval"}
