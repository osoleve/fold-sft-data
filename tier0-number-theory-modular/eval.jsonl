{"id": "nt_modular_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `mod-expt`\nSpec: Implement square-and-multiply modular exponentiation for exp >= 0.\n\nWrite exactly one Scheme function definition for `mod-expt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "mod-expt"], "split": "eval"}
{"id": "nt_modular_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (mod-expt base exp m)\n  ;; TODO: implement square-and-multiply with a named let\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mod-expt`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (mod-expt 2 10 1000) 24))\n(let () (= (mod-expt 3 20 100) 1))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "mod-expt"], "split": "eval"}
{"id": "nt_modular_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `extended-gcd`\nSpec: Return (g x y) where g = gcd(a,b) and g = ax + by using iterative state updates.\n\nWrite exactly one Scheme function definition for `extended-gcd`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "extended-gcd"], "split": "eval"}
{"id": "nt_modular_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (extended-gcd a b)\n  ;; TODO: iterative EEA returning (g x y)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extended-gcd`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "extended-gcd"], "split": "eval"}
{"id": "nt_modular_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "to-montgomery", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 number-theory code in Fold-native Scheme.\n\nTarget module: lattice/number-theory/modular.ss\nFunction: `to-montgomery`\nSpec: Map a to Montgomery representation aR mod m.\n\nWrite exactly one Scheme function definition for `to-montgomery`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (to-montgomery a m R)\n  (modulo (* a R) m))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))", "tags": ["tier0", "number-theory", "modular", "spec-to-code", "to-montgomery"], "split": "eval"}
{"id": "nt_modular_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "to-montgomery", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton so it satisfies the modular arithmetic test suite.\n\n```scheme\n(define (to-montgomery a m R)\n  ;; TODO: convert to Montgomery form\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `to-montgomery`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (to-montgomery a m R)\n  (modulo (* a R) m))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))", "tags": ["tier0", "number-theory", "modular", "skeleton-completion", "to-montgomery"], "split": "eval"}
{"id": "nt_modular_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `mod-expt`.\nReturn only the Scheme definition.\n\n```python\ndef mod_pow(base, exp, m):\n    b = base % m\n    result = 1\n    while exp > 0:\n        if exp & 1:\n            result = (result * b) % m\n        b = (b * b) % m\n        exp //= 2\n    return result % m\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "mod-expt"], "split": "eval"}
{"id": "nt_modular_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `mod-expt`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mod-pow base exp m)\n  (let loop ((b (modulo base m))\n             (e exp)\n             (acc 1))\n    (if (= e 0)\n        acc\n        (if (odd? e)\n            (loop (modulo (* b b) m) (quotient e 2) (modulo (* acc b) m))\n            (loop (modulo (* b b) m) (quotient e 2) acc)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (mod-expt 2 10 1000) 24))\n(let () (= (mod-expt 3 20 100) 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "mod-expt"], "split": "eval"}
{"id": "nt_modular_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and keep the target function name `extended-gcd`.\nReturn only the Scheme definition.\n\n```python\ndef egcd(a, b):\n    old_r, r = a, b\n    old_s, s = 1, 0\n    old_t, t = 0, 1\n    while r != 0:\n        q = old_r // r\n        old_r, r = r, old_r - q * r\n        old_s, s = s, old_s - q * s\n        old_t, t = t, old_t - q * t\n    return old_r, old_s, old_t\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))", "tags": ["tier0", "number-theory", "modular", "python-to-scheme", "extended-gcd"], "split": "eval"}
{"id": "nt_modular_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style for `lattice/number-theory/modular.ss`.\nTarget function name must be `extended-gcd`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (egcd a b)\n  (let loop ((old-r a) (r b)\n             (old-s 1) (s 0)\n             (old-t 0) (t 1))\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ((q (quotient old-r r))\n               (nr (- old-r (* q r)))\n               (ns (- old-s (* q s)))\n               (nt (- old-t (* q t))))\n          (loop r nr s ns t nt)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))", "tags": ["tier0", "number-theory", "modular", "chez-to-fold", "extended-gcd"], "split": "eval"}
{"id": "nt_modular_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-expt` in `lattice/number-theory/modular.ss`.\nKnown issue: Base case must normalize for m=1.\n\n```scheme\n(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)] [e exp] [result 1])\n    (cond\n      [(= e 0) result]\n      [(odd? e) (loop (modulo (* b b) m) (quotient e 2) (modulo (* result b) m))]\n      [else (loop (modulo (* b b) m) (quotient e 2) result)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Base case must normalize for m=1.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod-expt 2 10 1000) 24))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-expt"], "split": "eval"}
{"id": "nt_modular_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mod-expt` in `lattice/number-theory/modular.ss`.\nKnown issue: Odd-step accumulator multiplies by itself instead of b.\n\n```scheme\n(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)] [e exp] [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e) (loop (modulo (* b b) m) (quotient e 2) (modulo (* result result) m))]\n      [else (loop (modulo (* b b) m) (quotient e 2) result)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Odd-step accumulator multiplies by itself instead of b.\n\nExpected behavior after patch:\n```scheme\n(let () (= (mod-expt 2 10 1000) 24))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (mod-expt 2 10 1000) 24))\n(let () (= (mod-expt 3 20 100) 1))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))", "verify_expr": "(let ()\n  (define (mod-expt base exp m)\n  (let loop ([b (modulo base m)]\n             [e exp]\n             [result 1])\n    (cond\n      [(= e 0) (modulo result m)]\n      [(odd? e)\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             (modulo (* result b) m))]\n      [else\n       (loop (modulo (* b b) m)\n             (quotient e 2)\n             result)])))\n  (and (= (mod-expt 2 10 1000) 24) (= (mod-expt 3 20 100) 1) (= (mod-expt 7 0 1) 0)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "mod-expt"], "split": "eval"}
{"id": "nt_modular_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extended-gcd` in `lattice/number-theory/modular.ss`.\nKnown issue: new-s uses old-s twice; it must use current s.\n\n```scheme\n(define (extended-gcd a b)\n  (let loop ([old-r a] [r b] [old-s 1] [s 0] [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q old-s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (and (= g 2) (= g (+ (* 240 x) (* 46 y))))))", "tags": ["tier0", "number-theory", "modular", "bugfix", "extended-gcd"], "split": "eval"}
{"id": "nt_modular_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "to-montgomery", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `to-montgomery` in `lattice/number-theory/modular.ss`.\nKnown issue: Conversion multiplies by R, not by m.\n\n```scheme\n(define (to-montgomery a m R)\n  (modulo (* a m) m))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Conversion multiplies by R, not by m.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (to-montgomery a m R)\n  (modulo (* a R) m))", "verify_expr": "(let ()\n  (define (extended-gcd a b)\n  (let loop ([old-r a] [r b]\n             [old-s 1] [s 0]\n             [old-t 0] [t 1])\n    (if (= r 0)\n        (list old-r old-s old-t)\n        (let* ([q (quotient old-r r)]\n               [new-r (- old-r (* q r))]\n               [new-s (- old-s (* q s))]\n               [new-t (- old-t (* q t))])\n          (loop r new-r s new-s t new-t)))))\n  (define (montgomery-setup m)\n  (let* ([R (let loop ([r 1])\n              (if (> r m)\n                  r\n                  (loop (* r 2))))]\n         [result (extended-gcd m R)]\n         [m-inv (cadr result)]\n         [m-prime (modulo (- m-inv) R)])\n    (list R m-prime)))\n  (define (montgomery-reduce T m R m-prime)\n  (let* ([t (modulo (* T m-prime) R)]\n         [u (quotient (+ T (* t m)) R)])\n    (if (>= u m)\n        (- u m)\n        u)))\n  (define (from-montgomery a m R m-prime)\n  (montgomery-reduce a m R m-prime))\n  (define (to-montgomery a m R)\n  (modulo (* a R) m))\n  (let* ([m 17] [setup (montgomery-setup m)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 9 m R)]) (= (from-montgomery x m R m-prime) 9)))", "tags": ["tier0", "number-theory", "modular", "bugfix", "to-montgomery"], "split": "eval"}
{"id": "nt_modular_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (2^100) mod 1000000007 using `mod-expt`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(mod-expt 2 100 1000000007)", "verify_expr": "(equal? (let () (mod-expt 2 100 1000000007)) (modulo (expt 2 100) 1000000007))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "direct"], "split": "eval"}
{"id": "nt_modular_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (7^0) mod 1 using `mod-expt`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(mod-expt 7 0 1)", "verify_expr": "(equal? (let () (mod-expt 7 0 1)) (modulo (expt 7 0) 1))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "direct", "edge-case"], "split": "eval"}
{"id": "nt_modular_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: small integration task across module primitives.\n\nCompute (5^3) mod 13 using `mod-expt`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod-expt 5 3 13)", "verify_expr": "(equal? (let () (mod-expt 5 3 13)) (modulo (expt 5 3) 13))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "direct"], "split": "eval"}
{"id": "nt_modular_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute (123^45) mod 89 using `mod-expt`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mod-expt 123 45 89)", "verify_expr": "(equal? (let () (mod-expt 123 45 89)) (modulo (expt 123 45) 89))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "direct"], "split": "eval"}
{"id": "nt_modular_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck exponent base case: a^0 mod m = 1 for a=9,m=13.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod-expt 9 0 13) 1)", "verify_expr": "(equal? (let () (= (mod-expt 9 0 13) 1)) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "property"], "split": "eval"}
{"id": "nt_modular_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck exponent one case: a^1 mod m = a mod m for a=27,m=19.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (mod-expt 27 1 19) (modulo 27 19))", "verify_expr": "(equal? (let () (= (mod-expt 27 1 19) (modulo 27 19))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "property"], "split": "eval"}
{"id": "nt_modular_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck additive exponent law for a=7,e1=5,e2=8,m=19.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (mod-expt 7 (+ 5 8) 19) (mod* (mod-expt 7 5 19) (mod-expt 7 8 19) 19))", "verify_expr": "(equal? (let () (= (mod-expt 7 (+ 5 8) 19) (mod* (mod-expt 7 5 19) (mod-expt 7 8 19) 19))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "property"], "split": "eval"}
{"id": "nt_modular_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a powers table [3^e mod 17] for exponents 0..4.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (e) (mod-expt 3 e 17)) '(0 1 2 3 4))", "verify_expr": "(equal? (let () (map (lambda (e) (mod-expt 3 e 17)) '(0 1 2 3 4))) '(1 3 9 10 13))", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "list"], "split": "eval"}
{"id": "nt_modular_composition_033", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate polynomial x^3 + 2x + 5 at x=4 over Z_17 using modular operators only.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([x 4]) (mod+ (mod+ (mod-expt x 3 17) (mod* 2 x 17) 17) 5 17))", "verify_expr": "(equal? (let () (let ([x 4]) (mod+ (mod+ (mod-expt x 3 17) (mod* 2 x 17) 17) 5 17))) 9)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "list", "composition"], "split": "eval"}
{"id": "nt_modular_composition_040", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff extended-gcd satisfies Bezout identity for (240,46).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (= g (+ (* 240 x) (* 46 y))))", "verify_expr": "(equal? (let () (let* ([r (extended-gcd 240 46)] [g (car r)] [x (cadr r)] [y (caddr r)]) (= g (+ (* 240 x) (* 46 y))))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "extended-gcd", "integration"], "split": "eval"}
{"id": "nt_modular_composition_041", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract gcd component from extended-gcd(17,13).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (extended-gcd 17 13))", "verify_expr": "(equal? (let () (car (extended-gcd 17 13))) 1)", "tags": ["tier0", "number-theory", "modular", "composition", "extended-gcd", "integration"], "split": "eval"}
{"id": "nt_modular_composition_042", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "extended-gcd", "prompt": "Task mode: small integration task across module primitives.\n\nExtract gcd component from extended-gcd(391,299).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (extended-gcd 391 299))", "verify_expr": "(equal? (let () (car (extended-gcd 391 299))) 23)", "tags": ["tier0", "number-theory", "modular", "composition", "extended-gcd", "integration"], "split": "eval"}
{"id": "nt_modular_composition_050", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "to-montgomery", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert 5 into Montgomery form for modulus 17, then round-trip back in one expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 5 17 R)]) (from-montgomery x 17 R m-prime))", "verify_expr": "(equal? (let () (let* ([setup (montgomery-setup 17)] [R (car setup)] [m-prime (cadr setup)] [x (to-montgomery 5 17 R)]) (from-montgomery x 17 R m-prime))) 5)", "tags": ["tier0", "number-theory", "modular", "composition", "to-montgomery", "montgomery"], "split": "eval"}
{"id": "nt_modular_composition_053", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff Montgomery exponentiation matches regular modular exponentiation for (7,13,19).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (montgomery-expt 7 13 19) (mod-expt 7 13 19))", "verify_expr": "(equal? (let () (= (montgomery-expt 7 13 19) (mod-expt 7 13 19))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "montgomery"], "split": "eval"}
{"id": "nt_modular_composition_054", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/modular.ss", "source_test": "lattice/number-theory/test-modular.ss", "source_function": "mod-expt", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff Montgomery exponentiation matches regular modular exponentiation for (2,100,1000000007).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (montgomery-expt 2 100 1000000007) (mod-expt 2 100 1000000007))", "verify_expr": "(equal? (let () (= (montgomery-expt 2 100 1000000007) (mod-expt 2 100 1000000007))) #t)", "tags": ["tier0", "number-theory", "modular", "composition", "mod-expt", "montgomery"], "split": "eval"}
