{"id": "egraph_union_find_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf?`\nSpec: Recognize a union-find value by vector shape and tag.\n\nWrite exactly one Scheme function definition for `uf?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf?"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf?`\nSpec: Recognize a union-find value by vector shape and tag.\n\nWrite exactly one Scheme function definition for `uf?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "egraph_union_find_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-size`\nSpec: Return total allocated element count (next ID).\n\nWrite exactly one Scheme function definition for `uf-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-size"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-size`\nSpec: Return total allocated element count (next ID).\n\nWrite exactly one Scheme function definition for `uf-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-union!`\nSpec: Merge two sets by rank, decrement set count, and return merged representative.\n\nWrite exactly one Scheme function definition for `uf-union!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-union!"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-union!`\nSpec: Merge two sets by rank, decrement set count, and return merged representative.\n\nWrite exactly one Scheme function definition for `uf-union!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-uf`.\nReturn only the Scheme definition.\n\n```python\ndef make_uf():\n    return [\"union-find\", [None] * 64, [0] * 64, box(0), box(0)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "make-uf"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-uf`.\nReturn only the Scheme definition.\n\n```python\ndef make_uf():\n    return [\"union-find\", [None] * 64, [0] * 64, box(0), box(0)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_union_find_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-make-set!`.\nReturn only the Scheme definition.\n\n```python\ndef uf_make_set(uf):\n    id_box = uf_next_id_box(uf)\n    element_id = unbox(id_box)\n    ensure_capacity(uf, element_id)\n    uf_parent(uf)[element_id] = element_id\n    uf_rank(uf)[element_id] = 0\n    set_box(id_box, element_id + 1)\n    set_box(uf_count_box(uf), unbox(uf_count_box(uf)) + 1)\n    return element_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-make-set!"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-make-set!`.\nReturn only the Scheme definition.\n\n```python\ndef uf_make_set(uf):\n    id_box = uf_next_id_box(uf)\n    element_id = unbox(id_box)\n    ensure_capacity(uf, element_id)\n    uf_parent(uf)[element_id] = element_id\n    uf_rank(uf)[element_id] = 0\n    set_box(id_box, element_id + 1)\n    set_box(uf_count_box(uf), unbox(uf_count_box(uf)) + 1)\n    return element_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-same-set?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (same-class? uf a b)\n  (= (uf-find uf a) (uf-find uf b)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-same-set?"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-same-set?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (same-class? uf a b)\n  (= (uf-find uf a) (uf-find uf b)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "egraph_union_find_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-uf` in `lattice/egraph/union-find.ss`.\nKnown issue: Rank entries must start at 0, not #f.\n\n```scheme\n(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 #f)\n          (box 0)\n          (box 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "make-uf"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-uf` in `lattice/egraph/union-find.ss`.\nKnown issue: Rank entries must start at 0, not #f.\n\n```scheme\n(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 #f)\n          (box 0)\n          (box 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-make-set!` in `lattice/egraph/union-find.ss`.\nKnown issue: Adding a singleton set must also increment set-count.\n\n```scheme\n(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    id))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Adding a singleton set must also increment set-count.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-make-set!"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-make-set!` in `lattice/egraph/union-find.ss`.\nKnown issue: Adding a singleton set must also increment set-count.\n\n```scheme\n(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    id))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Adding a singleton set must also increment set-count.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_union_find_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-same-set?` in `lattice/egraph/union-find.ss`.\nKnown issue: The predicate is inverted; it should return true when roots are equal.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  (not (= (uf-find uf id1) (uf-find uf id2))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-same-set?"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-same-set?` in `lattice/egraph/union-find.ss`.\nKnown issue: The predicate is inverted; it should return true when roots are equal.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  (not (= (uf-find uf id1) (uf-find uf id2))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault."}
{"id": "egraph_union_find_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: small integration task across module primitives.\n\nCreate an empty union-find and return `(list size count)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (list (uf-size uf) (uf-count uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (list (uf-size uf) (uf-count uf))) '(0 0)))", "tags": ["tier1", "egraph", "union-find", "composition", "make-uf", "direct"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate an empty union-find and return `(list size count)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate three sets, union one pair, and return count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-count uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-count uf))) 2))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-count", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate three sets, union one pair, and return count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate three sets and return their allocated IDs as a list.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (list (uf-make-set! uf) (uf-make-set! uf) (uf-make-set! uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (list (uf-make-set! uf) (uf-make-set! uf) (uf-make-set! uf))) '(0 1 2)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-make-set!", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate three sets and return their allocated IDs as a list.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate four sets, union 0-1 and 2-3, and return whether roots differ.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (not (= (uf-find uf 0) (uf-find uf 2))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (not (= (uf-find uf 0) (uf-find uf 2)))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-find", "property"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate four sets, union 0-1 and 2-3, and return whether roots differ.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate four sets, merge pairs (0,1) and (2,3), and return `(list same01 same02)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (list (uf-same-set? uf 0 1) (uf-same-set? uf 0 2)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (list (uf-same-set? uf 0 1) (uf-same-set? uf 0 2))) '(#t #f)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-same-set?", "integration"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate four sets, merge pairs (0,1) and (2,3), and return `(list same01 same02)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
