{"id": "egraph_union_find_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `make-uf`\nSpec: Create an empty union-find structure with growable parent/rank vectors and zeroed size/count.\n\nWrite exactly one Scheme function definition for `make-uf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "make-uf"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `make-uf`\nSpec: Create an empty union-find structure with growable parent/rank vectors and zeroed size/count.\n\nWrite exactly one Scheme function definition for `make-uf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-uf)\n  ;; TODO: create an empty union-find with initial capacity and counters\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-uf`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "make-uf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-uf)\n  ;; TODO: create an empty union-find with initial capacity and counters\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-uf`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "egraph_union_find_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf? x)\n  ;; TODO: verify union-find representation tag and shape\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf?`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf?"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf? x)\n  ;; TODO: verify union-find representation tag and shape\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf?`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-count`\nSpec: Return the number of distinct disjoint sets currently tracked.\n\nWrite exactly one Scheme function definition for `uf-count`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-count"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-count`\nSpec: Return the number of distinct disjoint sets currently tracked.\n\nWrite exactly one Scheme function definition for `uf-count`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-count uf)\n  ;; TODO: read number of disjoint sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-count`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-count"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-count uf)\n  ;; TODO: read number of disjoint sets\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-count`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "egraph_union_find_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-size uf)\n  ;; TODO: read number of allocated IDs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-size`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-size"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-size uf)\n  ;; TODO: read number of allocated IDs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-size`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-make-set!`\nSpec: Allocate a new singleton set, initialize parent/rank, and update size/count.\n\nWrite exactly one Scheme function definition for `uf-make-set!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-make-set!"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-make-set!`\nSpec: Allocate a new singleton set, initialize parent/rank, and update size/count.\n\nWrite exactly one Scheme function definition for `uf-make-set!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "egraph_union_find_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-make-set! uf)\n  ;; TODO: allocate singleton element and update metadata\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-make-set!`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-make-set!"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-make-set! uf)\n  ;; TODO: allocate singleton element and update metadata\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-make-set!`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-find`\nSpec: Return the set representative for an element with path compression.\n\nWrite exactly one Scheme function definition for `uf-find`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-find"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-find`\nSpec: Return the set representative for an element with path compression.\n\nWrite exactly one Scheme function definition for `uf-find`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "egraph_union_find_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-find uf id)\n  ;; TODO: find root with path compression\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-find`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-find"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-find uf id)\n  ;; TODO: find root with path compression\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-find`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "egraph_union_find_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-union! uf id1 id2)\n  ;; TODO: merge sets by rank and return merged representative\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-union!`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-union!"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-union! uf id1 id2)\n  ;; TODO: merge sets by rank and return merged representative\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-union!`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "egraph_union_find_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-same-set?`\nSpec: Check whether two IDs belong to the same set representative.\n\nWrite exactly one Scheme function definition for `uf-same-set?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "spec-to-code", "uf-same-set?"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/egraph/union-find.ss\nFunction: `uf-same-set?`\nSpec: Check whether two IDs belong to the same set representative.\n\nWrite exactly one Scheme function definition for `uf-same-set?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  ;; TODO: test set-equivalence via representatives\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-same-set?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "skeleton-completion", "uf-same-set?"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  ;; TODO: test set-equivalence via representatives\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `uf-same-set?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_union_find_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-uf`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "make-uf"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-uf`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (and (uf? uf) (= (uf-size uf) 0) (= (uf-count uf) 0))))\n(let () (let ([uf (make-uf)]) (and (= (vector-length (uf-parent uf)) 64) (= (vector-length (uf-rank uf)) 64) (eq? (vector-ref uf 0) 'union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_union_find_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf?`.\nReturn only the Scheme definition.\n\n```python\ndef uf_pred(x):\n    return isinstance(x, list) and len(x) >= 5 and x[0] == \"union-find\"\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf?"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf?`.\nReturn only the Scheme definition.\n\n```python\ndef uf_pred(x):\n    return isinstance(x, list) and len(x) >= 5 and x[0] == \"union-find\"\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_union_find_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (is-uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf?"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (is-uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_union_find_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-count`.\nReturn only the Scheme definition.\n\n```python\ndef uf_count(uf):\n    return unbox(uf_count_box(uf))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-count"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-count`.\nReturn only the Scheme definition.\n\n```python\ndef uf_count(uf):\n    return unbox(uf_count_box(uf))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-count`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (count-sets uf)\n  (unbox (uf-count-box uf)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-count"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-count`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (count-sets uf)\n  (unbox (uf-count-box uf)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "egraph_union_find_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-size`.\nReturn only the Scheme definition.\n\n```python\ndef uf_size(uf):\n    return unbox(uf_next_id_box(uf))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-size"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-size`.\nReturn only the Scheme definition.\n\n```python\ndef uf_size(uf):\n    return unbox(uf_next_id_box(uf))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (total-elems uf)\n  (unbox (uf-next-id-box uf)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-size"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (total-elems uf)\n  (unbox (uf-next-id-box uf)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-make-set!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (add-set! uf)\n  (let* ((id-box (uf-next-id-box uf))\n         (id (unbox id-box)))\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-make-set!"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-make-set!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (add-set! uf)\n  (let* ((id-box (uf-next-id-box uf))\n         (id (unbox id-box)))\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 100)) (uf-make-set! uf)) (and (= (uf-size uf) 100) (= (vector-ref (uf-parent uf) 99) 99))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_union_find_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-find`.\nReturn only the Scheme definition.\n\n```python\ndef uf_find(uf, element_id):\n    parent = uf_parent(uf)\n    p = parent[element_id]\n    if p == element_id:\n        return element_id\n    root = uf_find(uf, p)\n    parent[element_id] = root\n    return root\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-find"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-find`.\nReturn only the Scheme definition.\n\n```python\ndef uf_find(uf, element_id):\n    parent = uf_parent(uf)\n    p = parent[element_id]\n    if p == element_id:\n        return element_id\n    root = uf_find(uf, p)\n    parent[element_id] = root\n    return root\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-find`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (find-root uf id)\n  (let ((parent (uf-parent uf)))\n    (let loop ((i id))\n      (let ((p (vector-ref parent i)))\n        (if (= p i)\n            i\n            (let ((root (loop p)))\n              (vector-set! parent i root)\n              root))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-find"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-find`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (find-root uf id)\n  (let ((parent (uf-parent uf)))\n    (let loop ((i id))\n      (let ((p (vector-ref parent i)))\n        (if (= p i)\n            i\n            (let ((root (loop p)))\n              (vector-set! parent i root)\n              root))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "egraph_union_find_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-union!`.\nReturn only the Scheme definition.\n\n```python\ndef uf_union(uf, id1, id2):\n    root1 = uf_find(uf, id1)\n    root2 = uf_find(uf, id2)\n    if root1 == root2:\n        return root1\n    parent = uf_parent(uf)\n    rank = uf_rank(uf)\n    rank1 = rank[root1]\n    rank2 = rank[root2]\n    set_box(uf_count_box(uf), unbox(uf_count_box(uf)) - 1)\n    if rank1 < rank2:\n        parent[root1] = root2\n        return root2\n    if rank1 > rank2:\n        parent[root2] = root1\n        return root1\n    parent[root2] = root1\n    rank[root1] = rank1 + 1\n    return root1\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-union!"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-union!`.\nReturn only the Scheme definition.\n\n```python\ndef uf_union(uf, id1, id2):\n    root1 = uf_find(uf, id1)\n    root2 = uf_find(uf, id2)\n    if root1 == root2:\n        return root1\n    parent = uf_parent(uf)\n    rank = uf_rank(uf)\n    rank1 = rank[root1]\n    rank2 = rank[root2]\n    set_box(uf_count_box(uf), unbox(uf_count_box(uf)) - 1)\n    if rank1 < rank2:\n        parent[root1] = root2\n        return root2\n    if rank1 > rank2:\n        parent[root2] = root1\n        return root1\n    parent[root2] = root1\n    rank[root1] = rank1 + 1\n    return root1\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-union!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge! uf id1 id2)\n  (let ((root1 (uf-find uf id1))\n        (root2 (uf-find uf id2)))\n    (if (= root1 root2)\n        root1\n        (let ((parent (uf-parent uf))\n              (rank (uf-rank uf))\n              (rank1 (vector-ref (uf-rank uf) root1))\n              (rank2 (vector-ref (uf-rank uf) root2)))\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            ((< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2)\n            ((> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1)\n            (else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "chez-to-fold", "uf-union!"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `uf-union!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge! uf id1 id2)\n  (let ((root1 (uf-find uf id1))\n        (root2 (uf-find uf id2)))\n    (if (= root1 root2)\n        root1\n        (let ((parent (uf-parent uf))\n              (rank (uf-rank uf))\n              (rank1 (vector-ref (uf-rank uf) root1))\n              (rank2 (vector-ref (uf-rank uf) root2)))\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            ((< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2)\n            ((> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1)\n            (else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_union_find_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-same-set?`.\nReturn only the Scheme definition.\n\n```python\ndef uf_same_set(uf, id1, id2):\n    return uf_find(uf, id1) == uf_find(uf, id2)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "python-to-scheme", "uf-same-set?"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `uf-same-set?`.\nReturn only the Scheme definition.\n\n```python\ndef uf_same_set(uf, id1, id2):\n    return uf_find(uf, id1) == uf_find(uf, id2)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "egraph_union_find_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-uf` in `lattice/egraph/union-find.ss`.\nKnown issue: Fresh union-find must start with zero set count.\n\n```scheme\n(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 1)\n          (box 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (and\n  (let ([uf (make-uf)])\n    (and (uf? uf)\n         (= (uf-size uf) 0)\n         (= (uf-count uf) 0)))\n  (let ([uf (make-uf)])\n    (and (= (vector-length (uf-parent uf)) 64)\n         (= (vector-length (uf-rank uf)) 64)\n         (eq? (vector-ref uf 0) 'union-find)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "make-uf"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-uf` in `lattice/egraph/union-find.ss`.\nKnown issue: Fresh union-find must start with zero set count.\n\n```scheme\n(define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 1)\n          (box 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf?` in `lattice/egraph/union-find.ss`.\nKnown issue: Valid union-find values have length exactly 5 or more; strict > 5 rejects valid instances.\n\n```scheme\n(define (uf? x)\n  (and (vector? x)\n       (> (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Valid union-find values have length exactly 5 or more; strict > 5 rejects valid instances.\n\nExpected behavior after patch:\n```scheme\n(let () (uf? (make-uf)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf?"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf?` in `lattice/egraph/union-find.ss`.\nKnown issue: Valid union-find values have length exactly 5 or more; strict > 5 rejects valid instances.\n\n```scheme\n(define (uf? x)\n  (and (vector? x)\n       (> (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Valid union-find values have length exactly 5 or more; strict > 5 rejects valid instances.\n\nExpected behavior after patch:\n```scheme\n(let () (uf? (make-uf)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "egraph_union_find_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf?` in `lattice/egraph/union-find.ss`.\nKnown issue: Tag is stored in slot 0, not slot 1.\n\n```scheme\n(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 1) uf-tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (and\n  (uf? (make-uf))\n  (not (uf? '(union-find)))\n  (not (uf? (vector 'union-find\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0))))\n  (not (uf? (vector 'wrong-tag\n                    (make-vector 1 #f)\n                    (make-vector 1 0)\n                    (box 0)\n                    (box 0))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf?"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf?` in `lattice/egraph/union-find.ss`.\nKnown issue: Tag is stored in slot 0, not slot 1.\n\n```scheme\n(define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 1) uf-tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (uf? (make-uf)))\n(let () (not (uf? '(union-find))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "egraph_union_find_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-count` in `lattice/egraph/union-find.ss`.\nKnown issue: Count must read the count box, not next-id box.\n\n```scheme\n(define (uf-count uf)\n  (unbox (uf-next-id-box uf)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Count must read the count box, not next-id box.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-count"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-count` in `lattice/egraph/union-find.ss`.\nKnown issue: Count must read the count box, not next-id box.\n\n```scheme\n(define (uf-count uf)\n  (unbox (uf-next-id-box uf)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Count must read the count box, not next-id box.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-count uf) 0)))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf b c) (and (= (uf-count uf) 1) (= (uf-size uf) 3) (= (uf-union! uf a c) (uf-find uf a)) (= (uf-count uf) 1)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-count` in `lattice/egraph/union-find.ss`.\nKnown issue: The boxed count must be unboxed before returning.\n\n```scheme\n(define (uf-count uf)\n  (uf-count-box uf))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (uf-count uf)\n  (unbox (uf-count-box uf)))", "verify_expr": "(let ()\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-count uf) 0))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf b c)\n      (and (= (uf-count uf) 1)\n           (= (uf-size uf) 3)\n           (= (uf-union! uf a c) (uf-find uf a))\n           (= (uf-count uf) 1))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-count"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-count` in `lattice/egraph/union-find.ss`.\nKnown issue: The boxed count must be unboxed before returning.\n\n```scheme\n(define (uf-count uf)\n  (uf-count-box uf))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_union_find_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-size` in `lattice/egraph/union-find.ss`.\nKnown issue: Size tracks allocated IDs via next-id, not number of sets.\n\n```scheme\n(define (uf-size uf)\n  (unbox (uf-count-box uf)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-size"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-size` in `lattice/egraph/union-find.ss`.\nKnown issue: Size tracks allocated IDs via next-id, not number of sets.\n\n```scheme\n(define (uf-size uf)\n  (unbox (uf-count-box uf)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-size` in `lattice/egraph/union-find.ss`.\nKnown issue: Size should be exact next-id value with no offset.\n\n```scheme\n(define (uf-size uf)\n  (+ (unbox (uf-next-id-box uf)) 1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Size should be exact next-id value with no offset.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (uf-size uf)\n  (unbox (uf-next-id-box uf)))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (and\n  (let ([uf (make-uf)])\n    (= (uf-size uf) 0))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 70))\n      (uf-make-set! uf))\n    (uf-union! uf 0 69)\n    (and (= (uf-size uf) 70)\n         (= (uf-count uf) 69)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-size"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-size` in `lattice/egraph/union-find.ss`.\nKnown issue: Size should be exact next-id value with no offset.\n\n```scheme\n(define (uf-size uf)\n  (+ (unbox (uf-next-id-box uf)) 1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Size should be exact next-id value with no offset.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (= (uf-size uf) 0)))\n(let () (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-union! uf 0 69) (and (= (uf-size uf) 70) (= (uf-count uf) 69))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_union_find_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-make-set!` in `lattice/egraph/union-find.ss`.\nKnown issue: New singleton must point to itself as parent.\n\n```scheme\n(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id (+ id 1))\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: New singleton must point to itself as parent.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))", "verify_expr": "(let ()\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (and\n  (let ([uf (make-uf)])\n    (let* ([a (uf-make-set! uf)]\n           [b (uf-make-set! uf)]\n           [c (uf-make-set! uf)])\n      (and (= a 0)\n           (= b 1)\n           (= c 2)\n           (= (vector-ref (uf-parent uf) a) a)\n           (= (vector-ref (uf-parent uf) c) c)\n           (= (vector-ref (uf-rank uf) b) 0)\n           (= (uf-size uf) 3)\n           (= (uf-count uf) 3))))\n  (let ([uf (make-uf)])\n    (do ([i 0 (+ i 1)])\n        ((>= i 100))\n      (uf-make-set! uf))\n    (and (= (uf-size uf) 100)\n         (= (vector-ref (uf-parent uf) 99) 99)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-make-set!"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-make-set!` in `lattice/egraph/union-find.ss`.\nKnown issue: New singleton must point to itself as parent.\n\n```scheme\n(define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id (+ id 1))\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: New singleton must point to itself as parent.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let* ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (= a 0) (= b 1) (= c 2) (= (vector-ref (uf-parent uf) a) a) (= (vector-ref (uf-parent uf) c) c) (= (vector-ref (uf-rank uf) b) 0) (= (uf-size uf) 3) (= (uf-count uf) 3)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-find` in `lattice/egraph/union-find.ss`.\nKnown issue: Find must recurse to the true root, not return only one parent hop.\n\n```scheme\n(define (uf-find uf id)\n  (let* ([parent (uf-parent uf)]\n         [p (vector-ref parent id)])\n    (if (= p id)\n        id\n        p)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-find"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-find` in `lattice/egraph/union-find.ss`.\nKnown issue: Find must recurse to the true root, not return only one parent hop.\n\n```scheme\n(define (uf-find uf id)\n  (let* ([parent (uf-parent uf)]\n         [p (vector-ref parent id)])\n    (if (= p id)\n        id\n        p)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-find` in `lattice/egraph/union-find.ss`.\nKnown issue: After recursion, find must return the root, not the immediate parent.\n\n```scheme\n(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              p))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)]\n          [d (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (uf-union! uf c d)\n      (uf-union! uf b c)\n      (let* ([root (uf-find uf d)]\n             [parent (uf-parent uf)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= root (uf-find uf c))\n             (= root (uf-find uf d))\n             (= (vector-ref parent d) root)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)])\n      (= (uf-find uf x) x)))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-find"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-find` in `lattice/egraph/union-find.ss`.\nKnown issue: After recursion, find must return the root, not the immediate parent.\n\n```scheme\n(define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              p))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)] [d (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf c d) (uf-union! uf b c) (let* ([root (uf-find uf d)] [parent (uf-parent uf)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= root (uf-find uf c)) (= root (uf-find uf d)) (= (vector-ref parent d) root))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (= (uf-find uf x) x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_union_find_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-union!` in `lattice/egraph/union-find.ss`.\nKnown issue: Merging two distinct sets must decrement the set count.\n\n```scheme\n(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-union!"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-union!` in `lattice/egraph/union-find.ss`.\nKnown issue: Merging two distinct sets must decrement the set count.\n\n```scheme\n(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-union!` in `lattice/egraph/union-find.ss`.\nKnown issue: When ranks are equal and root2 attaches under root1, increment root1 rank (the new root).\n\n```scheme\n(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root2 (+ rank2 1))\n             root1])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)])\n      (let ([root (uf-union! uf a b)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf b))\n             (= (uf-count uf) 1)\n             (= (vector-ref (uf-rank uf) root) 1)))))\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (uf-union! uf a b)\n      (let ([root (uf-union! uf b c)])\n        (and (= root (uf-find uf a))\n             (= root (uf-find uf c))\n             (= (uf-count uf) 1)\n             (= (uf-union! uf a c) root)\n             (= (uf-count uf) 1)))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-union!"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-union!` in `lattice/egraph/union-find.ss`.\nKnown issue: When ranks are equal and root2 attaches under root1, increment root1 rank (the new root).\n\n```scheme\n(define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root2 (+ rank2 1))\n             root1])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([root (uf-union! uf a b)]) (and (= root (uf-find uf a)) (= root (uf-find uf b)) (= (uf-count uf) 1) (= (vector-ref (uf-rank uf) root) 1))))))\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (let ([root (uf-union! uf b c)]) (and (= root (uf-find uf a)) (= root (uf-find uf c)) (= (uf-count uf) 1) (= (uf-union! uf a c) root) (= (uf-count uf) 1))))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "egraph_union_find_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-same-set?` in `lattice/egraph/union-find.ss`.\nKnown issue: Set equivalence must compare representatives, not raw IDs.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  (= id1 id2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Set equivalence must compare representatives, not raw IDs.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))", "verify_expr": "(let ()\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define uf-tag 'union-find)\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (and\n  (let ([uf (make-uf)])\n    (let ([a (uf-make-set! uf)]\n          [b (uf-make-set! uf)]\n          [c (uf-make-set! uf)])\n      (and (uf-same-set? uf a a)\n           (not (uf-same-set? uf a b))\n           (begin (uf-union! uf a b)\n                  (uf-same-set? uf a b))\n           (not (uf-same-set? uf a c))\n           (begin (uf-union! uf b c)\n                  (uf-same-set? uf a c)))))\n  (let ([uf (make-uf)])\n    (let ([x (uf-make-set! uf)]\n          [y (uf-make-set! uf)])\n      (uf-union! uf x y)\n      (and (uf-same-set? uf x y)\n           (uf-same-set? uf y x))))))", "tags": ["tier1", "egraph", "union-find", "bugfix", "uf-same-set?"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uf-same-set?` in `lattice/egraph/union-find.ss`.\nKnown issue: Set equivalence must compare representatives, not raw IDs.\n\n```scheme\n(define (uf-same-set? uf id1 id2)\n  (= id1 id2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Set equivalence must compare representatives, not raw IDs.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (and (uf-same-set? uf a a) (not (uf-same-set? uf a b)) (begin (uf-union! uf a b) (uf-same-set? uf a b)) (not (uf-same-set? uf a c)) (begin (uf-union! uf b c) (uf-same-set? uf a c))))))\n(let () (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)] [y (uf-make-set! uf)]) (uf-union! uf x y) (and (uf-same-set? uf x y) (uf-same-set? uf y x)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "egraph_union_find_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: small integration task across module primitives.\n\nCreate a union-find and return whether it is tagged correctly.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (and (uf? uf) (eq? (vector-ref uf 0) 'union-find)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (and (uf? uf) (eq? (vector-ref uf 0) 'union-find))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "make-uf", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate a union-find and return whether it is tagged correctly.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: small integration task across module primitives.\n\nCreate a union-find, add two singleton sets, and return current count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (uf-make-set! uf) (uf-make-set! uf) (uf-count uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (uf-make-set! uf) (uf-make-set! uf) (uf-count uf)) 2))", "tags": ["tier1", "egraph", "union-find", "composition", "make-uf", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate a union-find, add two singleton sets, and return current count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "make-uf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate a union-find and return `(list parent-capacity rank-capacity)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (list (vector-length (uf-parent uf)) (vector-length (uf-rank uf))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (list (vector-length (uf-parent uf)) (vector-length (uf-rank uf)))) '(64 64)))", "tags": ["tier1", "egraph", "union-find", "composition", "make-uf", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate a union-find and return `(list parent-capacity rank-capacity)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn `(list (uf? valid) (uf? invalid-list))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([valid (make-uf)] [invalid '(union-find)]) (list (uf? valid) (uf? invalid)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([valid (make-uf)] [invalid '(union-find)]) (list (uf? valid) (uf? invalid))) '(#t #f)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf?", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn `(list (uf? valid) (uf? invalid-list))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether a wrong-tag vector is rejected by `uf?`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(uf? (vector 'not-uf (make-vector 1 #f) (make-vector 1 0) (box 0) (box 0)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (uf? (vector 'not-uf (make-vector 1 #f) (make-vector 1 0) (box 0) (box 0))) #f))", "tags": ["tier1", "egraph", "union-find", "composition", "uf?", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether a wrong-tag vector is rejected by `uf?`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate a union-find, perform one union, and test that `uf?` still holds.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf? uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf? uf))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf?", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate a union-find, perform one union, and test that `uf?` still holds.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf?", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap `uf?` over `(list (make-uf) 42 #t)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map uf? (list (make-uf) 42 #t))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (map uf? (list (make-uf) 42 #t)) '(#t #f #f)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf?", "list"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nMap `uf?` over `(list (make-uf) 42 #t)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: small integration task across module primitives.\n\nUnion the same pair twice and return final count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf a b) (uf-count uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf a b) (uf-count uf))) 1))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-count", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nUnion the same pair twice and return final count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate five sets and union all into one; return count.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 5)) (uf-make-set! uf)) (do ([i 1 (+ i 1)]) ((>= i 5)) (uf-union! uf 0 i)) (uf-count uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 5)) (uf-make-set! uf)) (do ([i 1 (+ i 1)]) ((>= i 5)) (uf-union! uf 0 i)) (uf-count uf)) 1))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-count", "loop"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate five sets and union all into one; return count.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-count", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn count of a fresh union-find.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (uf-count uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (uf-count uf)) 0))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-count", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn count of a fresh union-find.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate three sets, merge one pair, and return size.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-size uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (uf-union! uf a b) (uf-size uf))) 3))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-size", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate three sets, merge one pair, and return size.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate seventy sets and return final size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-size uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 70)) (uf-make-set! uf)) (uf-size uf)) 70))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-size", "loop"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate seventy sets and return final size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: small integration task across module primitives.\n\nReturn size of an empty union-find.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(uf-size (make-uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (uf-size (make-uf)) 0))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-size", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn size of an empty union-find.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-size", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether repeated unions keep size unchanged.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (uf-union! uf 2 3) (= (uf-size uf) 4))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (uf-union! uf 2 3) (= (uf-size uf) 4)) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-size", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether repeated unions keep size unchanged.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: small integration task across module primitives.\n\nCreate 65 sets and return the last allocated ID.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)] [last -1 (uf-make-set! uf)]) ((>= i 65) last)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)] [last -1 (uf-make-set! uf)]) ((>= i 65) last))) 64))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-make-set!", "loop"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate 65 sets and return the last allocated ID.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate one set and return whether its parent points to itself.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([id (uf-make-set! uf)]) (= (vector-ref (uf-parent uf) id) id)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([id (uf-make-set! uf)]) (= (vector-ref (uf-parent uf) id) id))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-make-set!", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate one set and return whether its parent points to itself.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-make-set!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate one set and return `(list rank count size)` for that ID.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (let ([id (uf-make-set! uf)]) (list (vector-ref (uf-rank uf) id) (uf-count uf) (uf-size uf))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([id (uf-make-set! uf)]) (list (vector-ref (uf-rank uf) id) (uf-count uf) (uf-size uf)))) '(0 1 1)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-make-set!", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate one set and return `(list rank count size)` for that ID.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: small integration task across module primitives.\n\nBuild three connected IDs via unions and return `(list (find 0) (find 2))`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 3)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (list (uf-find uf 0) (uf-find uf 2)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (let ([out (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 3)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (list (uf-find uf 0) (uf-find uf 2)))]) (= (car out) (cadr out))))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-find", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild three connected IDs via unions and return `(list (find 0) (find 2))`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: small integration task across module primitives.\n\nCreate one singleton and return its representative.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (uf-find uf x)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([x (uf-make-set! uf)]) (uf-find uf x))) 0))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-find", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate one singleton and return its representative.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate four IDs, merge into one class, call `(uf-find uf 3)`, then return parent of 3.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (uf-union! uf 1 2) (let ([r (uf-find uf 3)]) (vector-ref (uf-parent uf) 3)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (uf-union! uf 1 2) (let ([r (uf-find uf 3)]) (= (vector-ref (uf-parent uf) 3) r))))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-find", "path-compression"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate four IDs, merge into one class, call `(uf-find uf 3)`, then return parent of 3.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate two sets, union them, and return whether both IDs now share the returned root.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([r (uf-union! uf a b)]) (and (= r (uf-find uf a)) (= r (uf-find uf b))))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([r (uf-union! uf a b)]) (and (= r (uf-find uf a)) (= r (uf-find uf b)))))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-union!", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate two sets, union them, and return whether both IDs now share the returned root.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_union_find_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: small integration task across module primitives.\n\nCreate two singleton sets, union once, and return root rank.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([r (uf-union! uf a b)]) (vector-ref (uf-rank uf) r))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (let ([r (uf-union! uf a b)]) (vector-ref (uf-rank uf) r)))) 1))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-union!", "rank"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate two singleton sets, union once, and return root rank.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: small integration task across module primitives.\n\nUnion two IDs twice and return count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf a b) (uf-count uf)))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (uf-union! uf a b) (uf-count uf))) 1))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-union!", "idempotence"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nUnion two IDs twice and return count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "egraph_union_find_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-union!", "prompt": "Task mode: small integration task across module primitives.\n\nCreate four sets, merge 0-1 and 2-3, then merge those groups and return count.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (uf-union! uf 1 2) (uf-count uf))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 4)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 2 3) (uf-union! uf 1 2) (uf-count uf)) 1))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-union!", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate four sets, merge 0-1 and 2-3, then merge those groups and return count.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate two sets, union them, and return `(list (same? a b) (same? b a))`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (list (uf-same-set? uf a b) (uf-same-set? uf b a))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)]) (uf-union! uf a b) (list (uf-same-set? uf a b) (uf-same-set? uf b a)))) '(#t #t)))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-same-set?", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate two sets, union them, and return `(list (same? a b) (same? b a))`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate three fresh sets and return whether first and third are disjoint.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (not (uf-same-set? uf a c))))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (let ([a (uf-make-set! uf)] [b (uf-make-set! uf)] [c (uf-make-set! uf)]) (not (uf-same-set? uf a c)))) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-same-set?", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate three fresh sets and return whether first and third are disjoint.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "egraph_union_find_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/union-find.ss", "source_test": "lattice/egraph/test-union-find.ss", "source_function": "uf-same-set?", "prompt": "Task mode: small integration task across module primitives.\n\nCreate chain unions 0-1 and 1-2, then test if 0 and 2 are equivalent.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 3)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (uf-same-set? uf 0 2))", "verify_expr": "(let ()\n  (define uf-tag 'union-find)\n  (define (uf-parent uf)\n  (vector-ref uf 1))\n  (define (uf-rank uf)\n  (vector-ref uf 2))\n  (define (uf-count-box uf)\n  (vector-ref uf 3))\n  (define (uf-next-id-box uf)\n  (vector-ref uf 4))\n  (define (ensure-capacity! uf id)\n  (let ([parent (uf-parent uf)]\n        [rank (uf-rank uf)])\n    (when (>= id (vector-length parent))\n      (let* ([old-len (vector-length parent)]\n             [new-len (max (* 2 old-len) (+ id 1))]\n             [new-parent (make-vector new-len #f)]\n             [new-rank (make-vector new-len 0)])\n        (do ([i 0 (+ i 1)])\n            ((>= i old-len))\n          (vector-set! new-parent i (vector-ref parent i))\n          (vector-set! new-rank i (vector-ref rank i)))\n        (vector-set! uf 1 new-parent)\n        (vector-set! uf 2 new-rank)))))\n  (define (make-uf)\n  (vector uf-tag\n          (make-vector 64 #f)\n          (make-vector 64 0)\n          (box 0)\n          (box 0)))\n  (define (uf? x)\n  (and (vector? x)\n       (>= (vector-length x) 5)\n       (eq? (vector-ref x 0) uf-tag)))\n  (define (uf-count uf)\n  (unbox (uf-count-box uf)))\n  (define (uf-size uf)\n  (unbox (uf-next-id-box uf)))\n  (define (uf-make-set! uf)\n  (let* ([id-box (uf-next-id-box uf)]\n         [id (unbox id-box)])\n    (ensure-capacity! uf id)\n    (vector-set! (uf-parent uf) id id)\n    (vector-set! (uf-rank uf) id 0)\n    (set-box! id-box (+ id 1))\n    (set-box! (uf-count-box uf) (+ (unbox (uf-count-box uf)) 1))\n    id))\n  (define (uf-find uf id)\n  (let ([parent (uf-parent uf)])\n    (let loop ([i id])\n      (let ([p (vector-ref parent i)])\n        (if (= p i)\n            i\n            (let ([root (loop p)])\n              (vector-set! parent i root)\n              root))))))\n  (define (uf-union! uf id1 id2)\n  (let ([root1 (uf-find uf id1)]\n        [root2 (uf-find uf id2)])\n    (if (= root1 root2)\n        root1\n        (let ([parent (uf-parent uf)]\n              [rank (uf-rank uf)]\n              [rank1 (vector-ref (uf-rank uf) root1)]\n              [rank2 (vector-ref (uf-rank uf) root2)])\n          (set-box! (uf-count-box uf) (- (unbox (uf-count-box uf)) 1))\n          (cond\n            [(< rank1 rank2)\n             (vector-set! parent root1 root2)\n             root2]\n            [(> rank1 rank2)\n             (vector-set! parent root2 root1)\n             root1]\n            [else\n             (vector-set! parent root2 root1)\n             (vector-set! rank root1 (+ rank1 1))\n             root1])))))\n  (define (uf-same-set? uf id1 id2)\n  (= (uf-find uf id1) (uf-find uf id2)))\n  (equal? (let ([uf (make-uf)]) (do ([i 0 (+ i 1)]) ((>= i 3)) (uf-make-set! uf)) (uf-union! uf 0 1) (uf-union! uf 1 2) (uf-same-set? uf 0 2)) #t))", "tags": ["tier1", "egraph", "union-find", "composition", "uf-same-set?", "transitivity"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate chain unions 0-1 and 1-2, then test if 0 and 2 are equivalent.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
