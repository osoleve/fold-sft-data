{"id": "fp_meta_combinators_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `compose`\nSpec: Compose functions right-to-left. Empty input must produce identity.\n\nWrite exactly one Scheme function definition for `compose`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)\n(= ((compose) 42) 42)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "compose"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compose . fns)\n  ;; TODO: compose functions right-to-left, defaulting to identity\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compose`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)\n(= ((compose) 42) 42)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "compose"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (pipe . fns)\n  ;; TODO: compose functions left-to-right, defaulting to identity\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `pipe`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "pipe"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `curry2`\nSpec: Transform a binary function into a curried unary-unary chain.\n\nWrite exactly one Scheme function definition for `curry2`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 7) 2) 5))\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 2) 7) -5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (curry2 f)\n  ;; TODO: return curried form of a binary function\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `curry2`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 7) 2) 5))\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 2) 7) -5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partial f x)\n  ;; TODO: pre-apply x and forward remaining arguments\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partial`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "partial"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `maybe-bind`\nSpec: Monadic bind for Maybe: apply continuation on Just, propagate Nothing unchanged.\n\nWrite exactly one Scheme function definition for `maybe-bind`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "maybe-bind"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (maybe-bind m f)\n  ;; TODO: apply f only for Just values; propagate Nothing\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `maybe-bind`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "maybe-bind"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `sequence-maybe`\nSpec: Convert a list of Maybe values into Maybe of list with short-circuit on Nothing.\n\nWrite exactly one Scheme function definition for `sequence-maybe`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sequence-maybe ms)\n  ;; TODO: collect list of Maybes into Maybe of list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sequence-maybe`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (either-bind e f)\n  ;; TODO: bind over Right and preserve Left\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `either-bind`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right 5) validate) (right 10)))\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right -5) validate) (left 'negative)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "either-bind"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `group-by`\nSpec: Group consecutive elements by key equality while preserving encounter order within groups.\n\nWrite exactly one Scheme function definition for `group-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "group-by"], "split": "train"}
{"id": "fp_meta_combinators_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (group-by key xs)\n  ;; TODO: group consecutive elements with equal keys\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `group-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "skeleton-completion", "group-by"], "split": "train"}
{"id": "fp_meta_combinators_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compose`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compose* . fs)\n  (if (null? fs)\n      identity\n      (fold-right compose2 identity fs)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "compose"], "split": "train"}
{"id": "fp_meta_combinators_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `pipe`.\nReturn only the Scheme definition.\n\n```python\ndef pipe(*fns):\n    if not fns:\n        return lambda x: x\n    def piped(x):\n        out = x\n        for f in fns:\n            out = f(out)\n        return out\n    return piped\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12)\n(= ((pipe) 42) 42)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "pipe"], "split": "train"}
{"id": "fp_meta_combinators_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `pipe`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (pipe* . fs)\n  (if (null? fs)\n      identity\n      (fold-left pipe2 identity fs)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "pipe"], "split": "train"}
{"id": "fp_meta_combinators_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `curry2`.\nReturn only the Scheme definition.\n\n```python\ndef curry2(f):\n    return lambda x: (lambda y: f(x, y))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 7) 2) 5))\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 2) 7) -5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `curry2`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (make-curried2 f)\n  (lambda (x)\n    (lambda (y)\n      (f x y))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partial`.\nReturn only the Scheme definition.\n\n```python\ndef partial(f, x):\n    return lambda *args: f(x, *args)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "partial"], "split": "train"}
{"id": "fp_meta_combinators_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partial`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partial-left f x)\n  (lambda args\n    (apply f (cons x args))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "partial"], "split": "train"}
{"id": "fp_meta_combinators_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `maybe-bind`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (bind-maybe m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "maybe-bind"], "split": "train"}
{"id": "fp_meta_combinators_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `sequence-maybe`.\nReturn only the Scheme definition.\n\n```python\ndef sequence_maybe(ms):\n    if not ms:\n        return just([])\n    head, *tail = ms\n    if not just_q(head):\n        return nothing\n    rest = sequence_maybe(tail)\n    if not just_q(rest):\n        return nothing\n    return just([from_just(head)] + from_just(rest))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `sequence-maybe`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (sequence-ms ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                    (maybe-bind (sequence-ms (cdr ms))\n                                (lambda (xs)\n                                  (just (cons x xs))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `either-bind`.\nReturn only the Scheme definition.\n\n```python\ndef either_bind(e, f):\n    if right_q(e):\n        return f(from_right(e))\n    return e\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "either-bind"], "split": "train"}
{"id": "fp_meta_combinators_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `either-bind`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (bind-either e f)\n  (if (right? e)\n      (f (from-right e))\n      e))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right 5) validate) (right 10)))\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right -5) validate) (left 'negative)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "either-bind"], "split": "train"}
{"id": "fp_meta_combinators_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `group-by`.\nReturn only the Scheme definition.\n\n```python\ndef group_by(key, xs):\n    if not xs:\n        return []\n    groups = []\n    current = [xs[0]]\n    current_key = key(xs[0])\n    for x in xs[1:]:\n        k = key(x)\n        if k == current_key:\n            current.append(x)\n        else:\n            groups.append(current)\n            current = [x]\n            current_key = k\n    groups.append(current)\n    return groups\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "group-by"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compose` in `lattice/fp/meta/combinators.ss`.\nKnown issue: compose should use compose2 semantics; this incorrectly threads using pipe2.\n\n```scheme\n(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right pipe2 id fns)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compose should use compose2 semantics; this incorrectly threads using pipe2.\n\nExpected behavior after patch:\n```scheme\n(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "compose"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pipe` in `lattice/fp/meta/combinators.ss`.\nKnown issue: pipe must run left-to-right, not right-to-left composition.\n\n```scheme\n(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12)\n(= ((pipe) 42) 42)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "pipe"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pipe` in `lattice/fp/meta/combinators.ss`.\nKnown issue: pipe should use pipe2 with fold-left to preserve pipeline order.\n\n```scheme\n(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left compose2 id fns)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12)\n(= ((pipe) 42) 42)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "pipe"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `curry2` in `lattice/fp/meta/combinators.ss`.\nKnown issue: curry2 must return nested single-argument lambdas, not an uncurried binary lambda.\n\n```scheme\n(define (curry2 f)\n  (lambda (x y)\n    (f x y)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `curry2` in `lattice/fp/meta/combinators.ss`.\nKnown issue: curry2 must preserve argument order (x then y).\n\n```scheme\n(define (curry2 f)\n  (lambda (x)\n    (lambda (y)\n      (f y x))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 7) 2) 5))\n(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (= ((sub 2) 7) -5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (curry2 f)\n  (lambda (x)\n          (lambda (y)\n                  (f x y))))", "verify_expr": "(let ([sub (curry2 (lambda (x y) (- x y)))] [pair (curry2 cons)]) (and (= ((sub 7) 2) 5) (= ((sub 2) 7) -5) (equal? ((pair 'a) 'b) '(a . b))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "curry2"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partial` in `lattice/fp/meta/combinators.ss`.\nKnown issue: partial should fix the first argument, not append it at the end.\n\n```scheme\n(define (partial f x)\n  (lambda args (apply f (append args (list x)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "partial"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partial` in `lattice/fp/meta/combinators.ss`.\nKnown issue: partial must preserve variadic tail arguments, not force a single extra argument.\n\n```scheme\n(define (partial f x)\n  (lambda (y) (f x y)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "partial"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `maybe-bind` in `lattice/fp/meta/combinators.ss`.\nKnown issue: Nothing branch should propagate nothing directly, not invoke continuation.\n\n```scheme\n(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      (f nothing)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Nothing branch should propagate nothing directly, not invoke continuation.\n\nExpected behavior after patch:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 0) safe-div) nothing))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "maybe-bind"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sequence-maybe` in `lattice/fp/meta/combinators.ss`.\nKnown issue: Base case for empty list must be (just '()), not nothing.\n\n```scheme\n(define (sequence-maybe ms)\n  (if (null? ms)\n      nothing\n      (maybe-bind (car ms)\n                  (lambda (x)\n                    (maybe-bind (sequence-maybe (cdr ms))\n                                (lambda (xs)\n                                  (just (cons x xs))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Base case for empty list must be (just '()), not nothing.\n\nExpected behavior after patch:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))\n(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sequence-maybe` in `lattice/fp/meta/combinators.ss`.\nKnown issue: sequence-maybe must short-circuit on nothing and avoid unsafe from-just on all elements.\n\n```scheme\n(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (just (map from-just ms))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sequence-maybe ms)\n  (if (null? ms)\n      (just '())\n      (maybe-bind (car ms)\n                  (lambda (x)\n                          (maybe-bind (sequence-maybe (cdr ms))\n                                      (lambda (xs)\n                                              (just (cons x xs))))))))", "verify_expr": "(and (equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3))) (equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing) (equal? (sequence-maybe '()) (just '())))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "sequence-maybe"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `either-bind` in `lattice/fp/meta/combinators.ss`.\nKnown issue: either-bind must bind on Right values, not Left values.\n\n```scheme\n(define (either-bind e f)\n  (if (left? e)\n      (f (from-left e))\n      e))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "either-bind"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `either-bind` in `lattice/fp/meta/combinators.ss`.\nKnown issue: either-bind must return continuation result directly; do not wrap it again in Right.\n\n```scheme\n(define (either-bind e f)\n  (if (right? e)\n      (right (f (from-right e)))\n      e))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right 5) validate) (right 10)))\n(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (equal? (either-bind (right -5) validate) (left 'negative)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "either-bind"], "split": "train"}
{"id": "fp_meta_combinators_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `lattice/fp/meta/combinators.ss`.\nKnown issue: On key change, current-key must update to the new key.\n\n```scheme\n(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) current-key (list (car xs)) (cons (reverse current-group) groups))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: On key change, current-key must update to the new key.\n\nExpected behavior after patch:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "group-by"], "split": "train"}
{"id": "fp_meta_combinators_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate a 3-stage right-to-left composition at input 10.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10)", "verify_expr": "(= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "compose", "order"], "split": "train"}
{"id": "fp_meta_combinators_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate empty compose on 42.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((compose) 42)", "verify_expr": "(= ((compose) 42) 42)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "compose", "edge-case"], "split": "train"}
{"id": "fp_meta_combinators_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether compose(f3,f2,f1) and pipe(f1,f2,f3) agree on input 10.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([f1 (lambda (x) (+ x 1))] [f2 (lambda (x) (* x 2))] [f3 (lambda (x) (- x 3))]) (= ((compose f3 f2 f1) 10) ((pipe f1 f2 f3) 10)))", "verify_expr": "(equal? (let ([f1 (lambda (x) (+ x 1))] [f2 (lambda (x) (* x 2))] [f3 (lambda (x) (- x 3))]) (= ((compose f3 f2 f1) 10) ((pipe f1 f2 f3) 10))) #t)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "compose", "consistency"], "split": "train"}
{"id": "fp_meta_combinators_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPipe add1 then double, and evaluate at 5.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5)", "verify_expr": "(= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "pipe", "direct"], "split": "train"}
{"id": "fp_meta_combinators_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate a 3-stage left-to-right pipeline at input 10.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10)", "verify_expr": "(= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "pipe", "order"], "split": "train"}
{"id": "fp_meta_combinators_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate empty pipe on 99.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "((pipe) 99)", "verify_expr": "(= ((pipe) 99) 99)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "pipe", "edge-case"], "split": "train"}
{"id": "fp_meta_combinators_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether pipe(f1,f2,f3) equals compose(f3,f2,f1) on input 7.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([f1 (lambda (x) (+ x 4))] [f2 (lambda (x) (* x 3))] [f3 (lambda (x) (- x 5))]) (= ((pipe f1 f2 f3) 7) ((compose f3 f2 f1) 7)))", "verify_expr": "(equal? (let ([f1 (lambda (x) (+ x 4))] [f2 (lambda (x) (* x 3))] [f3 (lambda (x) (- x 5))]) (= ((pipe f1 f2 f3) 7) ((compose f3 f2 f1) 7))) #t)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "pipe", "consistency"], "split": "train"}
{"id": "fp_meta_combinators_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse curry2 and partial application to add 5 to 10.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([add (curry2 (lambda (x y) (+ x y)))] [add5 (add 5)]) (add5 10))", "verify_expr": "(= (let* ([add (curry2 (lambda (x y) (+ x y)))] [add5 (add 5)]) (add5 10)) 15)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "curry2", "partial-application"], "split": "train"}
{"id": "fp_meta_combinators_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse curry2 with cons to produce a pair '(a . b).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([pair-maker (curry2 cons)]) ((pair-maker 'a) 'b))", "verify_expr": "(equal? (let ([pair-maker (curry2 cons)]) ((pair-maker 'a) 'b)) '(a . b))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "curry2", "pair"], "split": "train"}
{"id": "fp_meta_combinators_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether curried less-than with left argument 3 accepts 4 and rejects 2.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([lt3 ((curry2 <) 3)]) (and (lt3 4) (not (lt3 2))))", "verify_expr": "(equal? (let ([lt3 ((curry2 <) 3)]) (and (lt3 4) (not (lt3 2)))) #t)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "curry2", "predicate"], "split": "train"}
{"id": "fp_meta_combinators_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: small integration task across module primitives.\n\nPartially apply + with 3, then apply to 4.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([add3 (partial + 3)]) (add3 4))", "verify_expr": "(= (let ([add3 (partial + 3)]) (add3 4)) 7)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "partial", "direct"], "split": "train"}
{"id": "fp_meta_combinators_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: compose existing APIs into one expression.\n\nPartially apply + with 3 and evaluate with two additional arguments 4 and 5.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([add3 (partial + 3)]) (add3 4 5))", "verify_expr": "(= (let ([add3 (partial + 3)]) (add3 4 5)) 12)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "partial", "variadic"], "split": "train"}
{"id": "fp_meta_combinators_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse partial to prepend a fixed prefix in string-append.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([with-hello (partial string-append \"hello-\")]) (with-hello \"world\"))", "verify_expr": "(equal? (let ([with-hello (partial string-append \"hello-\")]) (with-hello \"world\")) \"hello-world\")", "tags": ["tier1", "fp", "meta", "combinators", "composition", "partial", "string"], "split": "train"}
{"id": "fp_meta_combinators_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse partial to fix the first argument of list and build a 3-item list.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([list-with-a (partial list 'a)]) (list-with-a 'b 'c))", "verify_expr": "(equal? (let ([list-with-a (partial list 'a)]) (list-with-a 'b 'c)) '(a b c))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "partial", "list"], "split": "train"}
{"id": "fp_meta_combinators_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: small integration task across module primitives.\n\nUse maybe-bind with safe division and input (just 0).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (maybe-bind (just 0) safe-div))", "verify_expr": "(equal? (let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (maybe-bind (just 0) safe-div)) nothing)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "maybe-bind", "edge-case"], "split": "train"}
{"id": "fp_meta_combinators_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn maybe-bind on nothing with any continuation.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(maybe-bind nothing (lambda (x) (just (+ x 1))))", "verify_expr": "(equal? (maybe-bind nothing (lambda (x) (just (+ x 1)))) nothing)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "maybe-bind", "propagation"], "split": "train"}
{"id": "fp_meta_combinators_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nChain two maybe-bind steps to add 3 and 4 in Maybe context.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(maybe-bind (just 3) (lambda (x) (maybe-bind (just 4) (lambda (y) (just (+ x y))))))", "verify_expr": "(equal? (maybe-bind (just 3) (lambda (x) (maybe-bind (just 4) (lambda (y) (just (+ x y)))))) (just 7))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "maybe-bind", "chaining"], "split": "train"}
{"id": "fp_meta_combinators_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: compose existing APIs into one expression.\n\nSequence a list of all-Just values '(just 1, just 2, just 3).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sequence-maybe (list (just 1) (just 2) (just 3)))", "verify_expr": "(equal? (sequence-maybe (list (just 1) (just 2) (just 3))) (just '(1 2 3)))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "sequence-maybe", "direct"], "split": "train"}
{"id": "fp_meta_combinators_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: small integration task across module primitives.\n\nSequence a list containing a Nothing in the middle.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sequence-maybe (list (just 1) nothing (just 3)))", "verify_expr": "(equal? (sequence-maybe (list (just 1) nothing (just 3))) nothing)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "sequence-maybe", "short-circuit"], "split": "train"}
{"id": "fp_meta_combinators_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: compose existing APIs into one expression.\n\nSequence an empty list of Maybe values.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sequence-maybe '())", "verify_expr": "(equal? (sequence-maybe '()) (just '()))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "sequence-maybe", "edge-case"], "split": "train"}
{"id": "fp_meta_combinators_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: compose existing APIs into one expression.\n\nBind Right 5 through validator that doubles positives and rejects negatives.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (either-bind (right 5) validate))", "verify_expr": "(equal? (let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (either-bind (right 5) validate)) (right 10))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "either-bind", "direct"], "split": "train"}
{"id": "fp_meta_combinators_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: small integration task across module primitives.\n\nBind Right -5 through validator that rejects negatives.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (either-bind (right -5) validate))", "verify_expr": "(equal? (let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (either-bind (right -5) validate)) (left 'negative))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "either-bind", "error-path"], "split": "train"}
{"id": "fp_meta_combinators_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: small integration task across module primitives.\n\nBind a pre-existing Left value through any continuation.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(either-bind (left 'already-error) (lambda (x) (right (* x 2))))", "verify_expr": "(equal? (either-bind (left 'already-error) (lambda (x) (right (* x 2)))) (left 'already-error))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "either-bind", "propagation"], "split": "train"}
{"id": "fp_meta_combinators_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: small integration task across module primitives.\n\nChain two either-bind stages and sum transformed Right values.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(either-bind (right 3) (lambda (x) (either-bind (right 4) (lambda (y) (right (+ x y))))))", "verify_expr": "(equal? (either-bind (right 3) (lambda (x) (either-bind (right 4) (lambda (y) (right (+ x y)))))) (right 7))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "either-bind", "chaining"], "split": "train"}
{"id": "fp_meta_combinators_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: small integration task across module primitives.\n\nGroup consecutive numbers by parity for '(2 4 1 3 6 8 5).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(group-by even? '(2 4 1 3 6 8 5))", "verify_expr": "(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "group-by", "direct"], "split": "train"}
{"id": "fp_meta_combinators_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: small integration task across module primitives.\n\nGroup an empty input list by parity.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(group-by even? '())", "verify_expr": "(equal? (group-by even? '()) '())", "tags": ["tier1", "fp", "meta", "combinators", "composition", "group-by", "edge-case"], "split": "train"}
{"id": "fp_meta_combinators_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nGroup consecutive strings by string-length for '(\"a\" \"b\" \"cc\" \"dd\" \"e\").\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\"))", "verify_expr": "(equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\")))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "group-by", "string"], "split": "train"}
