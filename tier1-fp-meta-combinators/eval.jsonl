{"id": "fp_meta_combinators_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "pipe", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `pipe`\nSpec: Compose functions left-to-right. Empty input must produce identity.\n\nWrite exactly one Scheme function definition for `pipe`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (pipe . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))", "verify_expr": "(and (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2))) 5) 12) (= ((pipe) 42) 42) (= ((pipe (lambda (x) (+ x 1)) (lambda (x) (* x 2)) (lambda (x) (- x 3))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "pipe"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `pipe`\nSpec: Compose functions left-to-right. Empty input must produce identity.\n\nWrite exactly one Scheme function definition for `pipe`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "fp_meta_combinators_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "partial", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `partial`\nSpec: Partially apply the first argument while preserving variadic tail arguments.\n\nWrite exactly one Scheme function definition for `partial`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partial f x)\n  (lambda args (apply f (cons x args))))", "verify_expr": "(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (and (= (minus10 3) 7) (= (minus10 3 2) 5) (equal? (prepend '(a b)) '(x a b))))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "partial"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `partial`\nSpec: Partially apply the first argument while preserving variadic tail arguments.\n\nWrite exactly one Scheme function definition for `partial`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3) 7))\n(let ([minus10 (partial - 10)] [prepend (partial cons 'x)]) (= (minus10 3 2) 5))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "fp_meta_combinators_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "either-bind", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `either-bind`\nSpec: Monadic bind for Either on the Right branch; Left passes through unchanged.\n\nWrite exactly one Scheme function definition for `either-bind`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (either-bind e f)\n  (if (right? e)\n      (f (from-right e))\n      e))", "verify_expr": "(let ([validate (lambda (x) (if (positive? x) (right (* x 2)) (left 'negative)))]) (and (equal? (either-bind (right 5) validate) (right 10)) (equal? (either-bind (right -5) validate) (left 'negative)) (equal? (either-bind (left 'already-error) validate) (left 'already-error))))", "tags": ["tier1", "fp", "meta", "combinators", "spec-to-code", "either-bind"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this combinator utility in Fold-native Scheme.\n\nTarget module: lattice/fp/meta/combinators.ss\nFunction: `either-bind`\nSpec: Monadic bind for Either on the Right branch; Left passes through unchanged.\n\nWrite exactly one Scheme function definition for `either-bind`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "fp_meta_combinators_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compose`.\nReturn only the Scheme definition.\n\n```python\ndef compose(*fns):\n    if not fns:\n        return lambda x: x\n    def composed(x):\n        out = x\n        for f in reversed(fns):\n            out = f(out)\n        return out\n    return composed\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "compose"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compose`.\nReturn only the Scheme definition.\n\n```python\ndef compose(*fns):\n    if not fns:\n        return lambda x: x\n    def composed(x):\n        out = x\n        for f in reversed(fns):\n            out = f(out)\n        return out\n    return composed\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "fp_meta_combinators_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `maybe-bind`.\nReturn only the Scheme definition.\n\n```python\ndef maybe_bind(m, f):\n    if just_q(m):\n        return f(from_just(m))\n    return nothing\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 0) safe-div) nothing))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "python-to-scheme", "maybe-bind"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `maybe-bind`.\nReturn only the Scheme definition.\n\n```python\ndef maybe_bind(m, f):\n    if just_q(m):\n        return f(from_just(m))\n    return nothing\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 0) safe-div) nothing))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "fp_meta_combinators_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `group-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (group-by* key xs)\n  (if (null? xs)\n      '()\n      (let loop ([rest (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n        (if (null? rest)\n            (reverse (cons (reverse current-group) groups))\n            (let ([k (key (car rest))])\n              (if (equal? k current-key)\n                  (loop (cdr rest) current-key (cons (car rest) current-group) groups)\n                  (loop (cdr rest) k (list (car rest)) (cons (reverse current-group) groups))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "chez-to-fold", "group-by"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `group-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (group-by* key xs)\n  (if (null? xs)\n      '()\n      (let loop ([rest (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n        (if (null? rest)\n            (reverse (cons (reverse current-group) groups))\n            (let ([k (key (car rest))])\n              (if (equal? k current-key)\n                  (loop (cdr rest) current-key (cons (car rest) current-group) groups)\n                  (loop (cdr rest) k (list (car rest)) (cons (reverse current-group) groups))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "fp_meta_combinators_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compose` in `lattice/fp/meta/combinators.ss`.\nKnown issue: compose must apply functions right-to-left, not left-to-right.\n\n```scheme\n(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)\n(= ((compose) 42) 42)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-right compose2 id fns)))", "verify_expr": "(and (= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12) (= ((compose) 42) 42) (= ((compose (lambda (x) (- x 3)) (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 10) 19))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "compose"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compose` in `lattice/fp/meta/combinators.ss`.\nKnown issue: compose must apply functions right-to-left, not left-to-right.\n\n```scheme\n(define (compose . fns)\n  (if (null? fns)\n      id\n      (fold-left pipe2 id fns)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)\n(= ((compose) 42) 42)\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "fp_meta_combinators_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `maybe-bind` in `lattice/fp/meta/combinators.ss`.\nKnown issue: maybe-bind must not wrap continuation result in an extra Just layer.\n\n```scheme\n(define (maybe-bind m f)\n  (if (just? m)\n      (just (f (from-just m)))\n      nothing))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: maybe-bind must not wrap continuation result in an extra Just layer.\n\nExpected behavior after patch:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 0) safe-div) nothing))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (maybe-bind m f)\n  (if (just? m)\n      (f (from-just m))\n      nothing))", "verify_expr": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (and (equal? (maybe-bind (just 2) safe-div) (just 5)) (equal? (maybe-bind (just 0) safe-div) nothing) (equal? (maybe-bind nothing safe-div) nothing)))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "maybe-bind"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `maybe-bind` in `lattice/fp/meta/combinators.ss`.\nKnown issue: maybe-bind must not wrap continuation result in an extra Just layer.\n\n```scheme\n(define (maybe-bind m f)\n  (if (just? m)\n      (just (f (from-just m)))\n      nothing))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: maybe-bind must not wrap continuation result in an extra Just layer.\n\nExpected behavior after patch:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 2) safe-div) (just 5)))\n(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (equal? (maybe-bind (just 0) safe-div) nothing))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "fp_meta_combinators_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `lattice/fp/meta/combinators.ss`.\nKnown issue: Each group must preserve encounter order; this version leaves groups reversed.\n\n```scheme\n(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons current-group groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons current-group groups))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each group must preserve encounter order; this version leaves groups reversed.\n\nExpected behavior after patch:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons (reverse current-group) groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons (reverse current-group) groups))))))))", "verify_expr": "(and (equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5))) (equal? (group-by even? '()) '()) (equal? (group-by string-length '(\"a\" \"b\" \"cc\" \"dd\" \"e\")) '((\"a\" \"b\") (\"cc\" \"dd\") (\"e\"))))", "tags": ["tier1", "fp", "meta", "combinators", "bugfix", "group-by"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `group-by` in `lattice/fp/meta/combinators.ss`.\nKnown issue: Each group must preserve encounter order; this version leaves groups reversed.\n\n```scheme\n(define (group-by key xs)\n  (if (null? xs)\n      '()\n      (let loop ([xs (cdr xs)]\n                 [current-key (key (car xs))]\n                 [current-group (list (car xs))]\n                 [groups '()])\n           (if (null? xs)\n               (reverse (cons current-group groups))\n               (let ([k (key (car xs))])\n                    (if (equal? k current-key)\n                        (loop (cdr xs) current-key (cons (car xs) current-group) groups)\n                        (loop (cdr xs) k (list (car xs)) (cons current-group groups))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each group must preserve encounter order; this version leaves groups reversed.\n\nExpected behavior after patch:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (group-by even? '(2 4 1 3 6 8 5)) '((2 4) (1 3) (6 8) (5)))\n(equal? (group-by even? '()) '())\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "fp_meta_combinators_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "compose", "prompt": "Task mode: small integration task across module primitives.\n\nCompose add1 then double, and evaluate at 5.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5)", "verify_expr": "(= ((compose (lambda (x) (* x 2)) (lambda (x) (+ x 1))) 5) 12)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "compose", "direct"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompose add1 then double, and evaluate at 5.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_meta_combinators_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "curry2", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse curry2 to build curried addition and evaluate ((add 3) 4).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([add (curry2 (lambda (x y) (+ x y)))]) ((add 3) 4))", "verify_expr": "(= (let ([add (curry2 (lambda (x y) (+ x y)))]) ((add 3) 4)) 7)", "tags": ["tier1", "fp", "meta", "combinators", "composition", "curry2", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nUse curry2 to build curried addition and evaluate ((add 3) 4).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_meta_combinators_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "maybe-bind", "prompt": "Task mode: small integration task across module primitives.\n\nUse maybe-bind with safe division and input (just 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (maybe-bind (just 2) safe-div))", "verify_expr": "(equal? (let ([safe-div (lambda (n) (if (= n 0) nothing (just (/ 10 n))))]) (maybe-bind (just 2) safe-div)) (just 5))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "maybe-bind", "direct"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nUse maybe-bind with safe division and input (just 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_meta_combinators_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "sequence-maybe", "prompt": "Task mode: small integration task across module primitives.\n\nSequence a single-element Just list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sequence-maybe (list (just 9)))", "verify_expr": "(equal? (sequence-maybe (list (just 9))) (just '(9)))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "sequence-maybe", "singleton"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nSequence a single-element Just list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_meta_combinators_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/meta/combinators.ss", "source_test": "lattice/fp/meta/test-combinators.ss", "source_function": "group-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nGroup '(1 3 2 4 5 7) by parity and return the grouped result.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(group-by even? '(1 3 2 4 5 7))", "verify_expr": "(equal? (group-by even? '(1 3 2 4 5 7)) '((1 3) (2 4) (5 7)))", "tags": ["tier1", "fp", "meta", "combinators", "composition", "group-by", "consecutive-runs"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nGroup '(1 3 2 4 5 7) by parity and return the grouped result.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
