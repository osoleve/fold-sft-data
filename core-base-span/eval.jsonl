{"id": "core_span_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-file`\nSpec: Return file field from span.\n\nWrite exactly one Scheme function definition for `span-file`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-file s)\n  (list-ref s 1))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))", "tags": ["core", "base", "span", "spec-to-code", "span-file"], "split": "eval"}
{"id": "core_span_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-column`\nSpec: Return column field from span.\n\nWrite exactly one Scheme function definition for `span-column`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span-column s)\n  (list-ref s 3))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-column s)\n  (list-ref s 3))\n  (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))", "tags": ["core", "base", "span", "spec-to-code", "span-column"], "split": "eval"}
{"id": "core_span_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-end-column`\nSpec: Return end-column field from span.\n\nWrite exactly one Scheme function definition for `span-end-column`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (span-end-column s)\n  (list-ref s 5))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))", "tags": ["core", "base", "span", "spec-to-code", "span-end-column"], "split": "eval"}
{"id": "core_span_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span?`.\nReturn only the Scheme definition.\n\n```python\ndef is_span(x):\n    return isinstance(x, (list, tuple)) and len(x) > 0 and x[0] == 'span'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(span? '(span \"f.ss\" 1 2 1 3))\n(not (span? '(not-span x)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (and (span? '(span \"f.ss\" 1 2 1 3)) (not (span? '(not-span x)))))", "tags": ["core", "base", "span", "python-to-scheme", "span?"], "split": "eval"}
{"id": "core_span_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-line`.\nReturn only the Scheme definition.\n\n```python\ndef span_line(s):\n    return s[2]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span-line s)\n  (list-ref s 2))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-line s)\n  (list-ref s 2))\n  (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))", "tags": ["core", "base", "span", "python-to-scheme", "span-line"], "split": "eval"}
{"id": "core_span_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-span` in `core/base/span.ss`.\nKnown issue: Field order is wrong; file must be second element.\n\n```scheme\n(define (make-span file line column end-line end-column)\n  (list 'span line column end-line end-column file))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))", "tags": ["core", "base", "span", "bugfix", "make-span"], "split": "eval"}
{"id": "core_span_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-span` in `core/base/span.ss`.\nKnown issue: Formatted span must include file, line, and column; non-span fallback is <unknown>.\n\n```scheme\n(define (format-span s)\n  (if (span? s)\n      (span-file s)\n      \"\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))\n  (and (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\") (equal? (format-span '(oops)) \"<unknown>\")))", "tags": ["core", "base", "span", "bugfix", "format-span"], "split": "eval"}
{"id": "core_span_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConstruct span for file `a.ss` at 1:2 to 1:5.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (make-span \"a.ss\" 1 2 1 5) '(span \"a.ss\" 1 2 1 5))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(make-span \"a.ss\" 1 2 1 5)", "verify_expr": "(equal? (make-span \"a.ss\" 1 2 1 5) '(span \"a.ss\" 1 2 1 5))", "tags": ["core", "base", "span", "composition", "make-span", "direct"], "split": "eval"}
{"id": "core_span_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract end line from `(make-span \"main.ss\" 4 2 7 9)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(span-end-line (make-span \"main.ss\" 4 2 7 9))", "verify_expr": "(equal? (span-end-line (make-span \"main.ss\" 4 2 7 9)) 7)", "tags": ["core", "base", "span", "composition", "span-end-line", "direct"], "split": "eval"}
{"id": "core_span_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff merge keeps start line from first span.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (= (span-line (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 2))) 3) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (span-line (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 2))) 3)", "verify_expr": "(equal? (= (span-line (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 2))) 3) #t)", "tags": ["core", "base", "span", "composition", "merge-spans", "property"], "split": "eval"}
{"id": "core_span_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff all accessors recover fields used at construction.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([s (make-span \"z.ss\" 11 7 12 9)]) (and (equal? (span-file s) \"z.ss\") (= (span-line s) 11) (= (span-column s) 7) (= (span-end-line s) 12) (= (span-end-column s) 9))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([s (make-span \"z.ss\" 11 7 12 9)]) (and (equal? (span-file s) \"z.ss\") (= (span-line s) 11) (= (span-column s) 7) (= (span-end-line s) 12) (= (span-end-column s) 9)))", "verify_expr": "(equal? (let ([s (make-span \"z.ss\" 11 7 12 9)]) (and (equal? (span-file s) \"z.ss\") (= (span-line s) 11) (= (span-column s) 7) (= (span-end-line s) 12) (= (span-end-column s) 9))) #t)", "tags": ["core", "base", "span", "composition", "make-span", "property"], "split": "eval"}
