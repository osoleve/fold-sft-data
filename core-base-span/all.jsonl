{"id": "core_span_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `make-span`\nSpec: Construct a span value as `(span file line column end-line end-column)`.\n\nWrite exactly one Scheme function definition for `make-span`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `make-span`\nSpec: Construct a span value as `(span file line column end-line end-column)`.\n\nWrite exactly one Scheme function definition for `make-span`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))", "tags": ["core", "base", "span", "spec-to-code", "make-span"], "split": "train"}
{"id": "core_span_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-span file line column end-line end-column)\n  ;; TODO: build canonical span record\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-span`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-span file line column end-line end-column)\n  ;; TODO: build canonical span record\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-span`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))", "tags": ["core", "base", "span", "skeleton-completion", "make-span"], "split": "train"}
{"id": "core_span_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span?`\nSpec: Return #t iff value is a span tagged with symbol `span`.\n\nWrite exactly one Scheme function definition for `span?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span?`\nSpec: Return #t iff value is a span tagged with symbol `span`.\n\nWrite exactly one Scheme function definition for `span?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (span? '(span \"f.ss\" 1 2 1 3)))\n(let () (not (span? '(not-span x))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (and (span? '(span \"f.ss\" 1 2 1 3)) (not (span? '(not-span x)))))", "tags": ["core", "base", "span", "spec-to-code", "span?"], "split": "train"}
{"id": "core_span_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span? x)\n  ;; TODO: check whether x is tagged as span\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span?`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span? x)\n  ;; TODO: check whether x is tagged as span\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (span? '(span \"f.ss\" 1 2 1 3)))\n(let () (not (span? '(not-span x))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (and (span? '(span \"f.ss\" 1 2 1 3)) (not (span? '(not-span x)))))", "tags": ["core", "base", "span", "skeleton-completion", "span?"], "split": "train"}
{"id": "core_span_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-file`\nSpec: Return file field from span.\n\nWrite exactly one Scheme function definition for `span-file`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-file`\nSpec: Return file field from span.\n\nWrite exactly one Scheme function definition for `span-file`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-file s)\n  (list-ref s 1))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))", "tags": ["core", "base", "span", "spec-to-code", "span-file"], "split": "eval"}
{"id": "core_span_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span-file s)\n  ;; TODO: extract file field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-file`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span-file s)\n  ;; TODO: extract file field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-file`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-file s)\n  (list-ref s 1))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))", "tags": ["core", "base", "span", "skeleton-completion", "span-file"], "split": "train"}
{"id": "core_span_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-line`\nSpec: Return line field from span.\n\nWrite exactly one Scheme function definition for `span-line`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-line`\nSpec: Return line field from span.\n\nWrite exactly one Scheme function definition for `span-line`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span-line s)\n  (list-ref s 2))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-line s)\n  (list-ref s 2))\n  (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))", "tags": ["core", "base", "span", "spec-to-code", "span-line"], "split": "train"}
{"id": "core_span_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span-line s)\n  ;; TODO: extract line field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-line`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span-line s)\n  ;; TODO: extract line field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-line`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-line s)\n  (list-ref s 2))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-line s)\n  (list-ref s 2))\n  (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))", "tags": ["core", "base", "span", "skeleton-completion", "span-line"], "split": "train"}
{"id": "core_span_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-column`\nSpec: Return column field from span.\n\nWrite exactly one Scheme function definition for `span-column`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-column`\nSpec: Return column field from span.\n\nWrite exactly one Scheme function definition for `span-column`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span-column s)\n  (list-ref s 3))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-column s)\n  (list-ref s 3))\n  (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))", "tags": ["core", "base", "span", "spec-to-code", "span-column"], "split": "eval"}
{"id": "core_span_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span-column s)\n  ;; TODO: extract column field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-column`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span-column s)\n  ;; TODO: extract column field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-column`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-column s)\n  (list-ref s 3))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-column s)\n  (list-ref s 3))\n  (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))", "tags": ["core", "base", "span", "skeleton-completion", "span-column"], "split": "train"}
{"id": "core_span_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-end-line`\nSpec: Return end-line field from span.\n\nWrite exactly one Scheme function definition for `span-end-line`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-end-line`\nSpec: Return end-line field from span.\n\nWrite exactly one Scheme function definition for `span-end-line`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (span-end-line s)\n  (list-ref s 4))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))", "tags": ["core", "base", "span", "spec-to-code", "span-end-line"], "split": "train"}
{"id": "core_span_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span-end-line s)\n  ;; TODO: extract end-line field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-end-line`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span-end-line s)\n  ;; TODO: extract end-line field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-end-line`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (span-end-line s)\n  (list-ref s 4))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))", "tags": ["core", "base", "span", "skeleton-completion", "span-end-line"], "split": "train"}
{"id": "core_span_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-end-column`\nSpec: Return end-column field from span.\n\nWrite exactly one Scheme function definition for `span-end-column`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `span-end-column`\nSpec: Return end-column field from span.\n\nWrite exactly one Scheme function definition for `span-end-column`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (span-end-column s)\n  (list-ref s 5))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))", "tags": ["core", "base", "span", "spec-to-code", "span-end-column"], "split": "eval"}
{"id": "core_span_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (span-end-column s)\n  ;; TODO: extract end-column field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-end-column`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (span-end-column s)\n  ;; TODO: extract end-column field\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `span-end-column`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (span-end-column s)\n  (list-ref s 5))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))", "tags": ["core", "base", "span", "skeleton-completion", "span-end-column"], "split": "train"}
{"id": "core_span_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `merge-spans`\nSpec: Create a new span from start fields of first span and end fields of second span.\n\nWrite exactly one Scheme function definition for `merge-spans`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `merge-spans`\nSpec: Create a new span from start fields of first span and end fields of second span.\n\nWrite exactly one Scheme function definition for `merge-spans`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))\n  (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))", "tags": ["core", "base", "span", "spec-to-code", "merge-spans"], "split": "train"}
{"id": "core_span_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (merge-spans s1 s2)\n  ;; TODO: combine start from s1 with end from s2\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge-spans`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (merge-spans s1 s2)\n  ;; TODO: combine start from s1 with end from s2\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge-spans`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))\n  (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))", "tags": ["core", "base", "span", "skeleton-completion", "merge-spans"], "split": "train"}
{"id": "core_span_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "You are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `format-span`\nSpec: Format span as `file:line:column`, and `<unknown>` for non-span values.\n\nWrite exactly one Scheme function definition for `format-span`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core source-location utilities in Fold-native Scheme.\n\nTarget module: core/base/span.ss\nFunction: `format-span`\nSpec: Format span as `file:line:column`, and `<unknown>` for non-span values.\n\nWrite exactly one Scheme function definition for `format-span`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\"))\n(let () (equal? (format-span '(oops)) \"<unknown>\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))\n  (and (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\") (equal? (format-span '(oops)) \"<unknown>\")))", "tags": ["core", "base", "span", "spec-to-code", "format-span"], "split": "train"}
{"id": "core_span_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (format-span s)\n  ;; TODO: string format for spans; fallback to <unknown>\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-span`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-span s)\n  ;; TODO: string format for spans; fallback to <unknown>\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-span`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\"))\n(let () (equal? (format-span '(oops)) \"<unknown>\"))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))\n  (and (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\") (equal? (format-span '(oops)) \"<unknown>\")))", "tags": ["core", "base", "span", "skeleton-completion", "format-span"], "split": "train"}
{"id": "core_span_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-span`.\nReturn only the Scheme definition.\n\n```python\ndef make_span(file, line, col, end_line, end_col):\n    return ('span', file, line, col, end_line, end_col)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-span`.\nReturn only the Scheme definition.\n\n```python\ndef make_span(file, line, col, end_line, end_col):\n    return ('span', file, line, col, end_line, end_col)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))", "tags": ["core", "base", "span", "python-to-scheme", "make-span"], "split": "train"}
{"id": "core_span_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span?`.\nReturn only the Scheme definition.\n\n```python\ndef is_span(x):\n    return isinstance(x, (list, tuple)) and len(x) > 0 and x[0] == 'span'\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span?`.\nReturn only the Scheme definition.\n\n```python\ndef is_span(x):\n    return isinstance(x, (list, tuple)) and len(x) > 0 and x[0] == 'span'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (span? '(span \"f.ss\" 1 2 1 3)))\n(let () (not (span? '(not-span x))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (and (span? '(span \"f.ss\" 1 2 1 3)) (not (span? '(not-span x)))))", "tags": ["core", "base", "span", "python-to-scheme", "span?"], "split": "eval"}
{"id": "core_span_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-file`.\nReturn only the Scheme definition.\n\n```python\ndef span_file(s):\n    return s[1]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-file`.\nReturn only the Scheme definition.\n\n```python\ndef span_file(s):\n    return s[1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span-file s)\n  (list-ref s 1))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))", "tags": ["core", "base", "span", "python-to-scheme", "span-file"], "split": "train"}
{"id": "core_span_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-line`.\nReturn only the Scheme definition.\n\n```python\ndef span_line(s):\n    return s[2]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-line`.\nReturn only the Scheme definition.\n\n```python\ndef span_line(s):\n    return s[2]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (span-line s)\n  (list-ref s 2))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-line s)\n  (list-ref s 2))\n  (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))", "tags": ["core", "base", "span", "python-to-scheme", "span-line"], "split": "eval"}
{"id": "core_span_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-column`.\nReturn only the Scheme definition.\n\n```python\ndef span_column(s):\n    return s[3]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-column`.\nReturn only the Scheme definition.\n\n```python\ndef span_column(s):\n    return s[3]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (span-column s)\n  (list-ref s 3))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-column s)\n  (list-ref s 3))\n  (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))", "tags": ["core", "base", "span", "python-to-scheme", "span-column"], "split": "train"}
{"id": "core_span_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-end-line`.\nReturn only the Scheme definition.\n\n```python\ndef span_end_line(s):\n    return s[4]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-end-line`.\nReturn only the Scheme definition.\n\n```python\ndef span_end_line(s):\n    return s[4]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (span-end-line s)\n  (list-ref s 4))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))", "tags": ["core", "base", "span", "python-to-scheme", "span-end-line"], "split": "train"}
{"id": "core_span_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-end-column`.\nReturn only the Scheme definition.\n\n```python\ndef span_end_column(s):\n    return s[5]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `span-end-column`.\nReturn only the Scheme definition.\n\n```python\ndef span_end_column(s):\n    return s[5]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (span-end-column s)\n  (list-ref s 5))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))", "tags": ["core", "base", "span", "python-to-scheme", "span-end-column"], "split": "train"}
{"id": "core_span_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `merge-spans`.\nReturn only the Scheme definition.\n\n```python\ndef merge_spans(s1, s2):\n    return make_span(span_file(s1), span_line(s1), span_column(s1), span_end_line(s2), span_end_column(s2))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `merge-spans`.\nReturn only the Scheme definition.\n\n```python\ndef merge_spans(s1, s2):\n    return make_span(span_file(s1), span_line(s1), span_column(s1), span_end_line(s2), span_end_column(s2))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))\n  (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))", "tags": ["core", "base", "span", "python-to-scheme", "merge-spans"], "split": "train"}
{"id": "core_span_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `format-span`.\nReturn only the Scheme definition.\n\n```python\ndef format_span(s):\n    if is_span(s):\n        return f\"{span_file(s)}:{span_line(s)}:{span_column(s)}\"\n    return '<unknown>'\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `format-span`.\nReturn only the Scheme definition.\n\n```python\ndef format_span(s):\n    if is_span(s):\n        return f\"{span_file(s)}:{span_line(s)}:{span_column(s)}\"\n    return '<unknown>'\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\"))\n(let () (equal? (format-span '(oops)) \"<unknown>\"))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))\n  (and (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\") (equal? (format-span '(oops)) \"<unknown>\")))", "tags": ["core", "base", "span", "python-to-scheme", "format-span"], "split": "train"}
{"id": "core_span_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-span` in `core/base/span.ss`.\nKnown issue: Field order is wrong; file must be second element.\n\n```scheme\n(define (make-span file line column end-line end-column)\n  (list 'span line column end-line end-column file))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-span` in `core/base/span.ss`.\nKnown issue: Field order is wrong; file must be second element.\n\n```scheme\n(define (make-span file line column end-line end-column)\n  (list 'span line column end-line end-column file))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (equal? (make-span \"f.ss\" 2 3 2 8) '(span \"f.ss\" 2 3 2 8)))", "tags": ["core", "base", "span", "bugfix", "make-span"], "split": "eval"}
{"id": "core_span_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span?` in `core/base/span.ss`.\nKnown issue: Any pair is not necessarily a span.\n\n```scheme\n(define (span? x)\n  (pair? x))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span?` in `core/base/span.ss`.\nKnown issue: Any pair is not necessarily a span.\n\n```scheme\n(define (span? x)\n  (pair? x))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (span? '(span \"f.ss\" 1 2 1 3)))\n(let () (not (span? '(not-span x))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (and (span? '(span \"f.ss\" 1 2 1 3)) (not (span? '(not-span x)))))", "tags": ["core", "base", "span", "bugfix", "span?"], "split": "train"}
{"id": "core_span_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-file` in `core/base/span.ss`.\nKnown issue: File is at index 1.\n\n```scheme\n(define (span-file s)\n  (list-ref s 2))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-file` in `core/base/span.ss`.\nKnown issue: File is at index 1.\n\n```scheme\n(define (span-file s)\n  (list-ref s 2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: File is at index 1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span-file s)\n  (list-ref s 1))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (equal? (span-file (make-span \"main.ss\" 1 2 1 4)) \"main.ss\"))", "tags": ["core", "base", "span", "bugfix", "span-file"], "split": "train"}
{"id": "core_span_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-line` in `core/base/span.ss`.\nKnown issue: Line is at index 2, not index 1.\n\n```scheme\n(define (span-line s)\n  (list-ref s 1))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-line` in `core/base/span.ss`.\nKnown issue: Line is at index 2, not index 1.\n\n```scheme\n(define (span-line s)\n  (list-ref s 1))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Line is at index 2, not index 1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span-line s)\n  (list-ref s 2))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-line s)\n  (list-ref s 2))\n  (equal? (span-line (make-span \"main.ss\" 7 2 7 4)) 7))", "tags": ["core", "base", "span", "bugfix", "span-line"], "split": "train"}
{"id": "core_span_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-column` in `core/base/span.ss`.\nKnown issue: Column is index 3.\n\n```scheme\n(define (span-column s)\n  (list-ref s 4))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-column` in `core/base/span.ss`.\nKnown issue: Column is index 3.\n\n```scheme\n(define (span-column s)\n  (list-ref s 4))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span-column s)\n  (list-ref s 3))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-column s)\n  (list-ref s 3))\n  (equal? (span-column (make-span \"main.ss\" 7 9 7 14)) 9))", "tags": ["core", "base", "span", "bugfix", "span-column"], "split": "train"}
{"id": "core_span_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-end-line` in `core/base/span.ss`.\nKnown issue: End line must come from index 4.\n\n```scheme\n(define (span-end-line s)\n  (span-line s))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-end-line` in `core/base/span.ss`.\nKnown issue: End line must come from index 4.\n\n```scheme\n(define (span-end-line s)\n  (span-line s))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: End line must come from index 4.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (span-end-line s)\n  (list-ref s 4))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (equal? (span-end-line (make-span \"main.ss\" 7 9 8 3)) 8))", "tags": ["core", "base", "span", "bugfix", "span-end-line"], "split": "train"}
{"id": "core_span_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-end-column` in `core/base/span.ss`.\nKnown issue: End column must come from index 5.\n\n```scheme\n(define (span-end-column s)\n  (span-column s))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `span-end-column` in `core/base/span.ss`.\nKnown issue: End column must come from index 5.\n\n```scheme\n(define (span-end-column s)\n  (span-column s))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (span-end-column s)\n  (list-ref s 5))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (equal? (span-end-column (make-span \"main.ss\" 7 9 8 12)) 12))", "tags": ["core", "base", "span", "bugfix", "span-end-column"], "split": "train"}
{"id": "core_span_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-spans` in `core/base/span.ss`.\nKnown issue: Start fields must come from first span, end fields from second.\n\n```scheme\n(define (merge-spans s1 s2)\n  (make-span (span-file s2) (span-line s2) (span-column s2) (span-end-line s1) (span-end-column s1)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-spans` in `core/base/span.ss`.\nKnown issue: Start fields must come from first span, end fields from second.\n\n```scheme\n(define (merge-spans s1 s2)\n  (make-span (span-file s2) (span-line s2) (span-column s2) (span-end-line s1) (span-end-column s1)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))", "verify_expr": "(let ()\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (span-end-line s)\n  (list-ref s 4))\n  (define (span-end-column s)\n  (list-ref s 5))\n  (define (merge-spans s1 s2)\n  (make-span (span-file s1)\n             (span-line s1)\n             (span-column s1)\n             (span-end-line s2)\n             (span-end-column s2)))\n  (let* ([s1 (make-span \"a.ss\" 2 3 2 7)] [s2 (make-span \"a.ss\" 4 1 4 5)] [m (merge-spans s1 s2)]) (and (equal? (span-file m) \"a.ss\") (= (span-line m) 2) (= (span-column m) 3) (= (span-end-line m) 4) (= (span-end-column m) 5))))", "tags": ["core", "base", "span", "bugfix", "merge-spans"], "split": "train"}
{"id": "core_span_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-span` in `core/base/span.ss`.\nKnown issue: Formatted span must include file, line, and column; non-span fallback is <unknown>.\n\n```scheme\n(define (format-span s)\n  (if (span? s)\n      (span-file s)\n      \"\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-span` in `core/base/span.ss`.\nKnown issue: Formatted span must include file, line, and column; non-span fallback is <unknown>.\n\n```scheme\n(define (format-span s)\n  (if (span? s)\n      (span-file s)\n      \"\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Formatted span must include file, line, and column; non-span fallback is <unknown>.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))", "verify_expr": "(let ()\n  (define (span? x)\n  (and (pair? x) (eq? (car x) 'span)))\n  (define (span-file s)\n  (list-ref s 1))\n  (define (span-line s)\n  (list-ref s 2))\n  (define (span-column s)\n  (list-ref s 3))\n  (define (make-span file line column end-line end-column)\n  (list 'span file line column end-line end-column))\n  (define (format-span s)\n  (if (span? s)\n      (string-append (span-file s) \":\"\n                     (number->string (span-line s)) \":\"\n                     (number->string (span-column s)))\n      \"<unknown>\"))\n  (and (equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\") (equal? (format-span '(oops)) \"<unknown>\")))", "tags": ["core", "base", "span", "bugfix", "format-span"], "split": "eval"}
{"id": "core_span_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "Construct span for file `a.ss` at 1:2 to 1:5.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConstruct span for file `a.ss` at 1:2 to 1:5.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(make-span \"a.ss\" 1 2 1 5)", "verify_expr": "(equal? (make-span \"a.ss\" 1 2 1 5) '(span \"a.ss\" 1 2 1 5))", "tags": ["core", "base", "span", "composition", "make-span", "direct"], "split": "eval"}
{"id": "core_span_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "Check whether `(make-span \"a.ss\" 1 1 1 1)` is a span.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether `(make-span \"a.ss\" 1 1 1 1)` is a span.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(span? (make-span \"a.ss\" 1 1 1 1))", "verify_expr": "(equal? (span? (make-span \"a.ss\" 1 1 1 1)) #t)", "tags": ["core", "base", "span", "composition", "span?", "direct"], "split": "train"}
{"id": "core_span_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span?", "prompt_body": "Check whether symbol `'x` is a span.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether symbol `'x` is a span.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(span? 'x)", "verify_expr": "(equal? (span? 'x) #f)", "tags": ["core", "base", "span", "composition", "span?", "direct"], "split": "train"}
{"id": "core_span_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "Extract file from `(make-span \"main.ss\" 4 2 4 9)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract file from `(make-span \"main.ss\" 4 2 4 9)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(span-file (make-span \"main.ss\" 4 2 4 9))", "verify_expr": "(equal? (span-file (make-span \"main.ss\" 4 2 4 9)) \"main.ss\")", "tags": ["core", "base", "span", "composition", "span-file", "direct"], "split": "train"}
{"id": "core_span_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "Extract line from `(make-span \"main.ss\" 4 2 4 9)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract line from `(make-span \"main.ss\" 4 2 4 9)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(span-line (make-span \"main.ss\" 4 2 4 9))", "verify_expr": "(equal? (span-line (make-span \"main.ss\" 4 2 4 9)) 4)", "tags": ["core", "base", "span", "composition", "span-line", "direct"], "split": "train"}
{"id": "core_span_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-column", "prompt_body": "Extract column from `(make-span \"main.ss\" 4 2 4 9)`.", "prompt": "Task mode: small integration task across module primitives.\n\nExtract column from `(make-span \"main.ss\" 4 2 4 9)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(span-column (make-span \"main.ss\" 4 2 4 9))", "verify_expr": "(equal? (span-column (make-span \"main.ss\" 4 2 4 9)) 2)", "tags": ["core", "base", "span", "composition", "span-column", "direct"], "split": "train"}
{"id": "core_span_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-line", "prompt_body": "Extract end line from `(make-span \"main.ss\" 4 2 7 9)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract end line from `(make-span \"main.ss\" 4 2 7 9)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(span-end-line (make-span \"main.ss\" 4 2 7 9))", "verify_expr": "(equal? (span-end-line (make-span \"main.ss\" 4 2 7 9)) 7)", "tags": ["core", "base", "span", "composition", "span-end-line", "direct"], "split": "eval"}
{"id": "core_span_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "Extract end column from `(make-span \"main.ss\" 4 2 7 9)`.", "prompt": "Task mode: small integration task across module primitives.\n\nExtract end column from `(make-span \"main.ss\" 4 2 7 9)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(span-end-column (make-span \"main.ss\" 4 2 7 9))", "verify_expr": "(equal? (span-end-column (make-span \"main.ss\" 4 2 7 9)) 9)", "tags": ["core", "base", "span", "composition", "span-end-column", "direct"], "split": "train"}
{"id": "core_span_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Merge spans `(a.ss 2:3-2:8)` and `(a.ss 5:1-5:6)`.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge spans `(a.ss 2:3-2:8)` and `(a.ss 5:1-5:6)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(merge-spans (make-span \"a.ss\" 2 3 2 8) (make-span \"a.ss\" 5 1 5 6))", "verify_expr": "(equal? (merge-spans (make-span \"a.ss\" 2 3 2 8) (make-span \"a.ss\" 5 1 5 6)) '(span \"a.ss\" 2 3 5 6))", "tags": ["core", "base", "span", "composition", "merge-spans", "direct"], "split": "train"}
{"id": "core_span_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Format `(make-span \"file.ss\" 10 4 10 8)`.", "prompt": "Task mode: small integration task across module primitives.\n\nFormat `(make-span \"file.ss\" 10 4 10 8)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(format-span (make-span \"file.ss\" 10 4 10 8))", "verify_expr": "(equal? (format-span (make-span \"file.ss\" 10 4 10 8)) \"file.ss:10:4\")", "tags": ["core", "base", "span", "composition", "format-span", "direct"], "split": "train"}
{"id": "core_span_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Format non-span value `'oops`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFormat non-span value `'oops`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(format-span 'oops)", "verify_expr": "(equal? (format-span 'oops) \"<unknown>\")", "tags": ["core", "base", "span", "composition", "format-span", "edge-case"], "split": "train"}
{"id": "core_span_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Return #t iff merge keeps start line from first span.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff merge keeps start line from first span.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (span-line (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 2))) 3)", "verify_expr": "(equal? (= (span-line (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 2))) 3) #t)", "tags": ["core", "base", "span", "composition", "merge-spans", "property"], "split": "eval"}
{"id": "core_span_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "merge-spans", "prompt_body": "Return #t iff merge keeps end column from second span.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merge keeps end column from second span.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (span-end-column (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 42))) 42)", "verify_expr": "(equal? (= (span-end-column (merge-spans (make-span \"x.ss\" 3 2 3 7) (make-span \"x.ss\" 9 1 9 42))) 42) #t)", "tags": ["core", "base", "span", "composition", "merge-spans", "property"], "split": "train"}
{"id": "core_span_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-file", "prompt_body": "Get merged span file from two same-file spans.", "prompt": "Task mode: small integration task across module primitives.\n\nGet merged span file from two same-file spans.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(span-file (merge-spans (make-span \"k.ss\" 1 1 1 2) (make-span \"k.ss\" 2 1 2 2)))", "verify_expr": "(equal? (span-file (merge-spans (make-span \"k.ss\" 1 1 1 2) (make-span \"k.ss\" 2 1 2 2))) \"k.ss\")", "tags": ["core", "base", "span", "composition", "span-file", "integration"], "split": "train"}
{"id": "core_span_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-line", "prompt_body": "Build one span and return `(list line col end-col)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild one span and return `(list line col end-col)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([s (make-span \"m.ss\" 8 6 9 1)]) (list (span-line s) (span-column s) (span-end-column s)))", "verify_expr": "(equal? (let ([s (make-span \"m.ss\" 8 6 9 1)]) (list (span-line s) (span-column s) (span-end-column s))) '(8 6 1))", "tags": ["core", "base", "span", "composition", "span-line", "integration"], "split": "train"}
{"id": "core_span_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "span-end-column", "prompt_body": "Map end columns over two spans.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap end columns over two spans.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map span-end-column (list (make-span \"a\" 1 1 1 5) (make-span \"b\" 2 2 2 9)))", "verify_expr": "(equal? (map span-end-column (list (make-span \"a\" 1 1 1 5) (make-span \"b\" 2 2 2 9))) '(5 9))", "tags": ["core", "base", "span", "composition", "span-end-column", "list"], "split": "train"}
{"id": "core_span_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "format-span", "prompt_body": "Map format-span over span and non-span values.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap format-span over span and non-span values.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map format-span (list (make-span \"f\" 1 2 1 3) 'x))", "verify_expr": "(equal? (map format-span (list (make-span \"f\" 1 2 1 3) 'x)) '(\"f:1:2\" \"<unknown>\"))", "tags": ["core", "base", "span", "composition", "format-span", "list"], "split": "train"}
{"id": "core_span_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/span.ss", "source_test": "core/base/test-error.ss", "source_function": "make-span", "prompt_body": "Return #t iff all accessors recover fields used at construction.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff all accessors recover fields used at construction.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([s (make-span \"z.ss\" 11 7 12 9)]) (and (equal? (span-file s) \"z.ss\") (= (span-line s) 11) (= (span-column s) 7) (= (span-end-line s) 12) (= (span-end-column s) 9)))", "verify_expr": "(equal? (let ([s (make-span \"z.ss\" 11 7 12 9)]) (and (equal? (span-file s) \"z.ss\") (= (span-line s) 11) (= (span-column s) 7) (= (span-end-line s) 12) (= (span-end-column s) 9))) #t)", "tags": ["core", "base", "span", "composition", "make-span", "property"], "split": "eval"}
