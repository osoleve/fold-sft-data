{"id": "egraph_egraph_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `make-egraph`\nSpec: Create an empty e-graph with union-find, e-class store, hashcons table, empty dirty set, and zeroed stats.\n\nReturn exactly one definition for `make-egraph` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "make-egraph"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `make-egraph`.\n\n```scheme\n(define (make-egraph)\n  ;; TODO: initialize all e-graph components and counters\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "make-egraph"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph?`\nSpec: Recognize e-graph values by vector shape and tag.\n\nReturn exactly one definition for `egraph?` and no extra text.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph?"], "split": "eval"}
{"id": "egraph_egraph_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `egraph?`.\n\n```scheme\n(define (egraph? x)\n  ;; TODO: validate e-graph tag and structural shape\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph?"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-find`\nSpec: Return canonical e-class ID for a class by delegating to union-find.\n\nReturn exactly one definition for `egraph-find` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (= (egraph-find eg x) x))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `egraph-find`.\n\n```scheme\n(define (egraph-find eg id)\n  ;; TODO: return canonical class ID via union-find\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (= (egraph-find eg x) x))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-lookup`\nSpec: Canonicalize an e-node, probe hashcons, and return canonical class ID or #f.\n\nReturn exactly one definition for `egraph-lookup` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-lookup"], "split": "eval"}
{"id": "egraph_egraph_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `egraph-lookup`.\n\n```scheme\n(define (egraph-lookup eg enode)\n  ;; TODO: canonicalize enode, query hashcons, return canonical class or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([n (make-enode 'q (vector))]) (and (not (egraph-lookup eg n)) (let ([id (egraph-add-enode! eg n)]) (= (egraph-lookup eg n) id))))))\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-lookup eg (make-enode 'f (vector y)))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-lookup"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-add-enode!`\nSpec: Insert canonical e-node with hashcons deduplication, stats updates, and parent registration.\n\nReturn exactly one definition for `egraph-add-enode!` and no extra text.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-add-enode!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `egraph-add-enode!`.\n\n```scheme\n(define (egraph-add-enode! eg enode)\n  ;; TODO: deduplicate by hashcons or create a new class with parent links\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (and (= id1 id2) (= (egraph-class-count eg) 1) (= (egraph-stat-adds eg) 1) (= (egraph-stat-hits eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))] [parents (eclass-get-parents (egraph-classes eg) x)]) (and (not (null? parents)) (not (not (memv parent-id parents))))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-add-enode!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-merge!`\nSpec: Merge two classes, merge e-class data, and mark affected parent classes dirty.\n\nReturn exactly one definition for `egraph-merge!` and no extra text.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (egraph-merge! eg a b) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-class-count eg) 1) (= (egraph-stat-merges eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (and (> (length (egraph-dirty eg)) 0) (begin (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton for `egraph-merge!`.\n\n```scheme\n(define (egraph-merge! eg id1 id2)\n  ;; TODO: merge classes and mark affected parents dirty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (egraph-merge! eg a b) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-class-count eg) 1) (= (egraph-stat-merges eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (and (> (length (egraph-dirty eg)) 0) (begin (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-rebuild!`\nSpec: Process dirty classes, canonicalize nodes, maintain hashcons, and trigger congruence merges.\n\nReturn exactly one definition for `egraph-rebuild!` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-rebuild!"], "split": "eval"}
{"id": "egraph_egraph_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton for `egraph-rebuild!`.\n\n```scheme\n(define (egraph-rebuild! eg)\n  ;; TODO: rebuild dirty classes and propagate congruence merges\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-rebuild!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-add-term!`\nSpec: Recursively convert S-expression terms to e-nodes and insert them into the e-graph.\n\nReturn exactly one definition for `egraph-add-term!` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-add-term!"], "split": "train"}
{"id": "egraph_egraph_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton for `egraph-add-term!`.\n\n```scheme\n(define (egraph-add-term! eg term)\n  ;; TODO: recursively lower term to e-nodes and insert\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "skeleton-completion", "egraph-add-term!"], "split": "train"}
{"id": "egraph_egraph_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `make-egraph`.\nReturn only the Scheme function definition.\n\n```python\ndef make_egraph():\n    return {\n        \"tag\": \"egraph\",\n        \"uf\": make_uf(),\n        \"classes\": make_eclass_store(),\n        \"hashcons\": {},\n        \"dirty\": persistent_empty_map(),\n        \"stats\": [0, 0, 0, 0],\n    }\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "make-egraph"], "split": "eval"}
{"id": "egraph_egraph_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `make-egraph`.\nReturn only the final Fold definition.\n\n```scheme\n(define (mk-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "make-egraph"], "split": "train"}
{"id": "egraph_egraph_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph?`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_pred(x):\n    return isinstance(x, list) and len(x) >= 6 and x[0] == \"egraph\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph?"], "split": "train"}
{"id": "egraph_egraph_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph?"], "split": "train"}
{"id": "egraph_egraph_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-find`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_find(eg, class_id):\n    return uf_find(egraph_uf(eg), class_id)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-find`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-find eg id)\n  (uf-find (egraph-uf eg) id))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (= (egraph-find eg x) x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-lookup`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_lookup(eg, enode):\n    uf = egraph_uf(eg)\n    canonical = enode_canonicalize(enode, uf)\n    found = egraph_hashcons(eg).get(canonical)\n    return uf_find(uf, found) if found is not None else False\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-lookup"], "split": "train"}
{"id": "egraph_egraph_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-lookup`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canon (enode-canonicalize enode uf)]\n         [tbl (egraph-hashcons eg)]\n         [found (hashtable-ref tbl canon #f)])\n    (and found (uf-find uf found))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-lookup"], "split": "train"}
{"id": "egraph_egraph_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-add-enode!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_add_enode(eg, enode):\n    uf = egraph_uf(eg)\n    canonical = enode_canonicalize(enode, uf)\n    table = egraph_hashcons(eg)\n    existing = table.get(canonical)\n    if existing is not None:\n        egraph_inc_stat(eg, 3)\n        return uf_find(uf, existing)\n\n    classes = egraph_classes(eg)\n    new_id = uf_make_set(uf)\n    egraph_inc_stat(eg, 0)\n    table[canonical] = new_id\n    eclass_add_node(classes, new_id, canonical)\n\n    for child in enode_children(canonical):\n        child_id = egraph_find(eg, child)\n        eclass_add_parent(classes, child_id, new_id)\n    return new_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-add-enode!"], "split": "eval"}
{"id": "egraph_egraph_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-add-enode!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canon (enode-canonicalize enode uf)]\n         [tbl (egraph-hashcons eg)]\n         [existing (hashtable-ref tbl canon #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [cid (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! tbl canon cid)\n          (eclass-add-node! classes cid canon)\n          (let ([kids (enode-children canon)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length kids)))\n              (eclass-add-parent! classes (egraph-find eg (vector-ref kids i)) cid)))\n          cid))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (and (= id1 id2) (= (egraph-class-count eg) 1) (= (egraph-stat-adds eg) 1) (= (egraph-stat-hits eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))] [parents (eclass-get-parents (egraph-classes eg) x)]) (and (not (null? parents)) (not (not (memv parent-id parents))))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-add-enode!"], "split": "train"}
{"id": "egraph_egraph_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-merge!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_merge(eg, id1, id2):\n    uf = egraph_uf(eg)\n    classes = egraph_classes(eg)\n    root1 = uf_find(uf, id1)\n    root2 = uf_find(uf, id2)\n    if root1 == root2:\n        return root1\n\n    egraph_inc_stat(eg, 1)\n    new_root = uf_union(uf, id1, id2)\n    affected = eclass_merge(classes, uf, id1, id2)\n    for parent in affected:\n        egraph_mark_dirty(eg, parent)\n    return new_root\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (egraph-merge! eg a b) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-class-count eg) 1) (= (egraph-stat-merges eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (and (> (length (egraph-dirty eg)) 0) (begin (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-merge!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([r1 (uf-find uf id1)]\n          [r2 (uf-find uf id2)])\n      (if (= r1 r2)\n          r1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([root (uf-union! uf id1 id2)]\n                  [affected (eclass-merge! classes uf id1 id2)])\n              (for-each (lambda (p) (egraph-mark-dirty! eg p)) affected)\n              root))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-rebuild!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_rebuild(eg):\n    uf = egraph_uf(eg)\n    classes = egraph_classes(eg)\n    table = egraph_hashcons(eg)\n    visited = set()\n    processed = 0\n\n    while True:\n        dirty = egraph_pop_dirty(eg)\n        if dirty is False:\n            return processed\n\n        root = uf_find(uf, dirty)\n        if root in visited:\n            continue\n\n        visited.add(root)\n        egraph_inc_stat(eg, 2)\n        processed += 1\n\n        for enode in eclass_get_nodes(classes, root):\n            canonical = enode_canonicalize(enode, uf)\n            if enode != canonical:\n                table.pop(enode, None)\n\n            existing = table.get(canonical)\n            if existing is None:\n                table[canonical] = root\n            elif uf_find(uf, existing) != root:\n                new_root = egraph_merge(eg, root, existing)\n                table[canonical] = new_root\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-rebuild!"], "split": "train"}
{"id": "egraph_egraph_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-rebuild!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [tbl (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty (egraph-pop-dirty! eg)])\n        (if (not dirty)\n            count\n            (let ([root (uf-find uf dirty)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (for-each\n                 (lambda (enode)\n                   (let ([canon (enode-canonicalize enode uf)])\n                     (unless (enode-equal? enode canon)\n                       (hashtable-delete! tbl enode))\n                     (let ([existing (hashtable-ref tbl canon #f)])\n                       (cond\n                         [(not existing)\n                          (hashtable-set! tbl canon root)]\n                         [(not (= (uf-find uf existing) root))\n                          (hashtable-set! tbl canon (egraph-merge! eg root existing))]))))\n                 (eclass-get-nodes classes root)))\n              (loop)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-rebuild!"], "split": "train"}
{"id": "egraph_egraph_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-add-term!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_add_term(eg, term):\n    if isinstance(term, (list, tuple)) and len(term) > 0:\n        op = term[0]\n        args = term[1:]\n        child_ids = [egraph_add_term(eg, arg) for arg in args]\n        return egraph_add_enode(eg, make_enode(op, child_ids))\n    return egraph_add_enode(eg, make_enode(term, []))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-add-term!"], "split": "train"}
{"id": "egraph_egraph_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-add-term!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-add-term! eg term)\n  (if (pair? term)\n      (let* ([op (car term)]\n             [args (cdr term)]\n             [kids (map (lambda (arg) (eg-add-term! eg arg)) args)])\n        (egraph-add-enode! eg (make-enode op (list->vector kids))))\n      (egraph-add-enode! eg (make-enode term (vector)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-add-term!"], "split": "eval"}
{"id": "egraph_egraph_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-egraph` in `lattice/egraph/egraph.ss`.\nKnown issue: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\n```scheme\n(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "make-egraph"], "split": "eval"}
{"id": "egraph_egraph_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-egraph` in `lattice/egraph/egraph.ss`.\nKnown issue: Dirty set must start as `hamt-empty` for O(1) membership operations.\n\n```scheme\n(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          '()\n          (vector 0 0 0 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "make-egraph"], "split": "train"}
{"id": "egraph_egraph_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph?` in `lattice/egraph/egraph.ss`.\nKnown issue: Valid e-graphs have length 6; strict `> 6` rejects canonical values.\n\n```scheme\n(define (egraph? x)\n  (and (vector? x)\n       (> (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph?"], "split": "train"}
{"id": "egraph_egraph_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph?` in `lattice/egraph/egraph.ss`.\nKnown issue: Tag is stored at index 0, not index 1.\n\n```scheme\n(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 1) egraph-tag)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph?"], "split": "train"}
{"id": "egraph_egraph_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-find` in `lattice/egraph/egraph.ss`.\nKnown issue: Class IDs must be canonicalized through union-find.\n\n```scheme\n(define (egraph-find eg id)\n  id)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Class IDs must be canonicalized through union-find.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (= (egraph-find eg x) x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-find` in `lattice/egraph/egraph.ss`.\nKnown issue: The function must look up the provided ID directly; no offset is valid.\n\n```scheme\n(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) (+ id 1)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: The function must look up the provided ID directly; no offset is valid.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg b) (egraph-find eg c))))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (= (egraph-find eg x) x))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-find eg b) (egraph-find eg c)))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (= (egraph-find eg x) x)))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-find"], "split": "train"}
{"id": "egraph_egraph_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-lookup` in `lattice/egraph/egraph.ss`.\nKnown issue: Lookups must canonicalize e-node children before probing hashcons.\n\n```scheme\n(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons enode #f)])\n    (and found (uf-find uf found))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-lookup"], "split": "train"}
{"id": "egraph_egraph_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-lookup` in `lattice/egraph/egraph.ss`.\nKnown issue: Returned IDs must be canonicalized with `uf-find` to avoid stale representatives.\n\n```scheme\n(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    found))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Returned IDs must be canonicalized with `uf-find` to avoid stale representatives.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([n (make-enode 'q (vector))]) (and (not (egraph-lookup eg n)) (let ([id (egraph-add-enode! eg n)]) (= (egraph-lookup eg n) id))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-lookup"], "split": "train"}
{"id": "egraph_egraph_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-enode!` in `lattice/egraph/egraph.ss`.\nKnown issue: Hashcons hit path must return canonical representative, not possibly stale ID.\n\n```scheme\n(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          existing)\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-enode!"], "split": "eval"}
{"id": "egraph_egraph_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-enode!` in `lattice/egraph/egraph.ss`.\nKnown issue: New nodes must register parent links for each child to support rebuild propagation.\n\n```scheme\n(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          new-id))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (and (= id1 id2) (= (egraph-class-count eg) 1) (= (egraph-stat-adds eg) 1) (= (egraph-stat-hits eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))] [parents (eclass-get-parents (egraph-classes eg) x)]) (and (not (null? parents)) (not (not (memv parent-id parents))))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-enode!"], "split": "train"}
{"id": "egraph_egraph_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-merge!` in `lattice/egraph/egraph.ss`.\nKnown issue: Affected parent classes from `eclass-merge!` must be marked dirty for rebuild.\n\n```scheme\n(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (eclass-merge! classes uf id1 id2)\n              new-root))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Affected parent classes from `eclass-merge!` must be marked dirty for rebuild.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (egraph-merge! eg a b) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-class-count eg) 1) (= (egraph-stat-merges eg) 1)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (egraph-merge! eg a b) (and (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-class-count eg) 1) (= (egraph-stat-merges eg) 1)))))\n(let () (let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (and (> (length (egraph-dirty eg)) 0) (begin (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-merge!` in `lattice/egraph/egraph.ss`.\nKnown issue: Already-equivalent classes must short-circuit before incrementing merge stats or mutating structures.\n\n```scheme\n(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (egraph-inc-stat! eg 1)\n    (let ([new-root (uf-union! uf id1 id2)])\n      (let ([affected (eclass-merge! classes uf id1 id2)])\n        (for-each (lambda (p) (egraph-mark-dirty! eg p)) affected))\n      new-root)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg a b)\n      (and (= (egraph-find eg a) (egraph-find eg b))\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-merges eg) 1))))\n  (let ([eg (make-egraph)])\n    (let* ([x (egraph-add-term! eg 'x)]\n           [y (egraph-add-term! eg 'y)]\n           [fx (egraph-add-term! eg '(f x))]\n           [fy (egraph-add-term! eg '(f y))])\n      (egraph-merge! eg x y)\n      (and (> (length (egraph-dirty eg)) 0)\n           (begin\n             (egraph-saturate-rebuild! eg)\n             (= (egraph-find eg fx) (egraph-find eg fy))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-merge!"], "split": "train"}
{"id": "egraph_egraph_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-rebuild!` in `lattice/egraph/egraph.ss`.\nKnown issue: Dirty IDs must be canonicalized to roots before processing to avoid skipped rebuild work.\n\n```scheme\n(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root dirty-id])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Dirty IDs must be canonicalized to roots before processing to avoid skipped rebuild work.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-rebuild!"], "split": "train"}
{"id": "egraph_egraph_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-rebuild!` in `lattice/egraph/egraph.ss`.\nKnown issue: When canonical enodes already exist in another class, rebuild must merge classes (not overwrite hashcons only).\n\n```scheme\n(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (hashtable-set! hashcons canonical root)]))))\n                   nodes)))\n              (loop)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: When canonical enodes already exist in another class, rebuild must merge classes (not overwrite hashcons only).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-rebuild!"], "split": "train"}
{"id": "egraph_egraph_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-term!` in `lattice/egraph/egraph.ss`.\nKnown issue: Application arguments must be recursively inserted and replaced by child e-class IDs.\n\n```scheme\n(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [enode (make-enode op (list->vector args))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Application arguments must be recursively inserted and replaced by child e-class IDs.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-term!"], "split": "train"}
{"id": "egraph_egraph_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-term!` in `lattice/egraph/egraph.ss`.\nKnown issue: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\n```scheme\n(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode 'term (vector)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-term!"], "split": "eval"}
{"id": "egraph_egraph_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate an e-graph, add `x` and `y`, then return `(list class-count node-count adds)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (list (egraph-class-count eg) (egraph-node-count eg) (egraph-stat-adds eg)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (list (egraph-class-count eg) (egraph-node-count eg) (egraph-stat-adds eg))) '(2 2 2)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "make-egraph", "integration"], "split": "eval"}
{"id": "egraph_egraph_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate an e-graph, add the same symbol twice, and report `(same-class? hashcons-hits class-count)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'x)] [b (egraph-add-term! eg 'x)]) (list (= (egraph-find eg a) (egraph-find eg b)) (egraph-stat-hits eg) (egraph-class-count eg))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'x)] [b (egraph-add-term! eg 'x)]) (list (= (egraph-find eg a) (egraph-find eg b)) (egraph-stat-hits eg) (egraph-class-count eg)))) '(#t 1 1)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "make-egraph", "dedup"], "split": "train"}
{"id": "egraph_egraph_composition_003", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInitialize an e-graph, add `(+ x x)`, and return `(list class-count lookup-matches?)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([term-id (egraph-add-term! eg '(+ x x))] [lookup-id (egraph-lookup eg (make-enode '+ (vector (egraph-add-term! eg 'x) (egraph-add-term! eg 'x))))]) (list (egraph-class-count eg) (= (egraph-find eg term-id) (egraph-find eg lookup-id)))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([term-id (egraph-add-term! eg '(+ x x))] [lookup-id (egraph-lookup eg (make-enode '+ (vector (egraph-add-term! eg 'x) (egraph-add-term! eg 'x))))]) (list (egraph-class-count eg) (= (egraph-find eg term-id) (egraph-find eg lookup-id))))) '(2 #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "make-egraph", "lookup"], "split": "train"}
{"id": "egraph_egraph_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: small integration task across module primitives.\n\nCreate an e-graph, merge `x` and `y`, saturate rebuild, and return `(list classes dirty merges)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (list (egraph-class-count eg) (length (egraph-dirty eg)) (egraph-stat-merges eg))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (list (egraph-class-count eg) (length (egraph-dirty eg)) (egraph-stat-merges eg)))) '(1 0 1)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "make-egraph", "merge"], "split": "train"}
{"id": "egraph_egraph_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: small integration task across module primitives.\n\nAfter inserting one term, return `(list (egraph? eg) (egraph? '(egraph)))`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (list (egraph? eg) (egraph? '(egraph))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (list (egraph? eg) (egraph? '(egraph)))) '(#t #f)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph?", "predicate"], "split": "train"}
{"id": "egraph_egraph_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap `egraph?` over `(list (make-egraph) 7 #t)` and return the boolean list.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map egraph? (list (make-egraph) 7 #t))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (map egraph? (list (make-egraph) 7 #t)) '(#t #f #f)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph?", "predicate"], "split": "train"}
{"id": "egraph_egraph_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether a wrong-tag vector is rejected while a normal e-graph is accepted.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([bad (vector 'wrong (make-uf) (make-eclass-store) (make-eqv-hashtable) hamt-empty (vector 0 0 0 0))] [good (make-egraph)]) (and (egraph? good) (not (egraph? bad))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([bad (vector 'wrong (make-uf) (make-eclass-store) (make-eqv-hashtable) hamt-empty (vector 0 0 0 0))] [good (make-egraph)]) (and (egraph? good) (not (egraph? bad)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph?", "edge-case"], "split": "train"}
{"id": "egraph_egraph_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: small integration task across module primitives.\n\nBuild and mutate an e-graph, then return `(and (egraph? eg) (pair? (egraph-stats-report eg)))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (egraph-merge! eg (egraph-add-term! eg 'x) (egraph-add-term! eg 'y)) (and (egraph? eg) (pair? (egraph-stats-report eg))))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-stat-rebuilds eg) (vector-ref (egraph-stats eg) 2))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-stats-report eg)\n  `((classes . ,(egraph-class-count eg))\n    (nodes . ,(egraph-node-count eg))\n    (adds . ,(egraph-stat-adds eg))\n    (merges . ,(egraph-stat-merges eg))\n    (rebuilds . ,(egraph-stat-rebuilds eg))\n    (hashcons-hits . ,(egraph-stat-hits eg))\n    (dirty . ,(length (egraph-dirty eg)))))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (egraph-merge! eg (egraph-add-term! eg 'x) (egraph-add-term! eg 'y)) (and (egraph? eg) (pair? (egraph-stats-report eg)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph?", "integration"], "split": "train"}
{"id": "egraph_egraph_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd `a` and `b`, merge them, and return whether their roots are equal.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (= (egraph-find eg a) (egraph-find eg b))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (= (egraph-find eg a) (egraph-find eg b)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-find", "merge"], "split": "eval"}
{"id": "egraph_egraph_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate `a`, `b`, `c`, merge through `b`, and return `(list eq-ab eq-ac)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (list (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg a) (egraph-find eg c)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (list (= (egraph-find eg a) (egraph-find eg b)) (= (egraph-find eg a) (egraph-find eg c))))) '(#t #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-find", "transitivity"], "split": "train"}
{"id": "egraph_egraph_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck congruence propagation by comparing roots of `(f x)` and `(f y)` after merging `x` and `y`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-find", "congruence"], "split": "train"}
{"id": "egraph_egraph_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: small integration task across module primitives.\n\nInsert `x` twice and return whether both IDs have the same canonical root.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([id1 (egraph-add-term! eg 'x)] [id2 (egraph-add-term! eg 'x)]) (= (egraph-find eg id1) (egraph-find eg id2))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([id1 (egraph-add-term! eg 'x)] [id2 (egraph-add-term! eg 'x)]) (= (egraph-find eg id1) (egraph-find eg id2)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-find", "dedup"], "split": "train"}
{"id": "egraph_egraph_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: small integration task across module primitives.\n\nLookup a nullary node before and after insertion, returning `(list missing-before found-after)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)] [n (make-enode 'q (vector))]) (list (not (egraph-lookup eg n)) (begin (egraph-add-enode! eg n) (not (not (egraph-lookup eg n))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)] [n (make-enode 'q (vector))]) (list (not (egraph-lookup eg n)) (begin (egraph-add-enode! eg n) (not (not (egraph-lookup eg n)))))) '(#t #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-lookup", "hashcons"], "split": "train"}
{"id": "egraph_egraph_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd `(f x)`, then lookup the same canonical enode and return whether roots match.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [x (egraph-add-term! eg 'x)]) (= (egraph-find eg fx) (egraph-lookup eg (make-enode 'f (vector x))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [x (egraph-add-term! eg 'x)]) (= (egraph-find eg fx) (egraph-lookup eg (make-enode 'f (vector x)))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-lookup", "canonical"], "split": "train"}
{"id": "egraph_egraph_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: small integration task across module primitives.\n\nMerge `x` and `y`, rebuild, then test whether lookup of `(f y)` resolves to class of `(f x)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-lookup eg (make-enode 'f (vector y))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-lookup eg (make-enode 'f (vector y)))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-lookup", "congruence"], "split": "train"}
{"id": "egraph_egraph_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAfter adding `(+ x y)`, verify lookup of unrelated `(* x y)` stays absent.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (not (egraph-lookup eg (make-enode '* (vector 0 1)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (not (egraph-lookup eg (make-enode '* (vector 0 1))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-lookup", "negative"], "split": "train"}
{"id": "egraph_egraph_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert the same enode twice with `egraph-add-enode!` and return `(same-id? hits classes)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (list (= id1 id2) (egraph-stat-hits eg) (egraph-class-count eg))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (list (= id1 id2) (egraph-stat-hits eg) (egraph-class-count eg)))) '(#t 1 1)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-enode!", "dedup"], "split": "eval"}
{"id": "egraph_egraph_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: small integration task across module primitives.\n\nAdd child `x`, then add parent `(f x)` manually; return whether parent registration includes the new class ID.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))] [parents (eclass-get-parents (egraph-classes eg) x)]) (not (not (memv parent-id parents))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))] [parents (eclass-get-parents (egraph-classes eg) x)]) (not (not (memv parent-id parents)))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-enode!", "parents"], "split": "train"}
{"id": "egraph_egraph_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: small integration task across module primitives.\n\nInsert two distinct nullary enodes and return class count.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-enode! eg (make-enode 'x (vector))) (egraph-add-enode! eg (make-enode 'y (vector))) (egraph-class-count eg))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-enode! eg (make-enode 'x (vector))) (egraph-add-enode! eg (make-enode 'y (vector))) (egraph-class-count eg)) 2))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-enode!", "basic"], "split": "train"}
{"id": "egraph_egraph_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: compose existing APIs into one expression.\n\nAfter merging `x` and `y`, add `(f x)` and `(f y)` manually; return whether both IDs are equivalent.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (let ([id1 (egraph-add-enode! eg (make-enode 'f (vector x)))] [id2 (egraph-add-enode! eg (make-enode 'f (vector y)))]) (= (egraph-find eg id1) (egraph-find eg id2)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (let ([id1 (egraph-add-enode! eg (make-enode 'f (vector x)))] [id2 (egraph-add-enode! eg (make-enode 'f (vector y)))]) (= (egraph-find eg id1) (egraph-find eg id2))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-enode!", "canonical"], "split": "train"}
{"id": "egraph_egraph_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: small integration task across module primitives.\n\nBuild `(f x)` and `(f y)`, merge `x` with `y`, and return `(list classes merges dirty>0)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (list (egraph-class-count eg) (egraph-stat-merges eg) (> (length (egraph-dirty eg)) 0))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-dirty eg)\n  (hamt-keys (egraph-dirty-set eg)))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let* ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)] [fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))]) (egraph-merge! eg x y) (list (egraph-class-count eg) (egraph-stat-merges eg) (> (length (egraph-dirty eg)) 0)))) '(3 1 #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-merge!", "stats"], "split": "train"}
{"id": "egraph_egraph_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun the same merge twice and return `(list class-count merge-count)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-merge! eg x y) (list (egraph-class-count eg) (egraph-stat-merges eg))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-stat-merges eg) (vector-ref (egraph-stats eg) 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-merge! eg x y) (list (egraph-class-count eg) (egraph-stat-merges eg)))) '(1 1)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-merge!", "idempotence"], "split": "train"}
{"id": "egraph_egraph_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate `a`, `b`, `c`, merge through `b`, and return final class count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (egraph-class-count eg)))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (egraph-class-count eg))) 1))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-merge!", "transitivity"], "split": "train"}
{"id": "egraph_egraph_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nShow congruence closure by merging `x`/`y` and testing roots of `(f x)` and `(f y)` after rebuild.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-merge!", "congruence"], "split": "eval"}
{"id": "egraph_egraph_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: small integration task across module primitives.\n\nAfter merging `x` and `y`, call `egraph-rebuild!` once and return `(list processed>0 fx=fy)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (list (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (list (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)))))) '(#t #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-rebuild!", "single-pass"], "split": "train"}
{"id": "egraph_egraph_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExercise non-root dirty IDs (`a=b`, then `b=c`) and return whether all `(f _)` terms become equivalent.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fa (egraph-add-term! eg '(f a))] [fb (egraph-add-term! eg '(f b))] [fc (egraph-add-term! eg '(f c))] [a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg) (and (= (egraph-find eg fa) (egraph-find eg fb)) (= (egraph-find eg fb) (egraph-find eg fc)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fa (egraph-add-term! eg '(f a))] [fb (egraph-add-term! eg '(f b))] [fc (egraph-add-term! eg '(f c))] [a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [c (egraph-add-term! eg 'c)]) (egraph-merge! eg a b) (egraph-merge! eg b c) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg) (and (= (egraph-find eg fa) (egraph-find eg fb)) (= (egraph-find eg fb) (egraph-find eg fc))))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-rebuild!", "non-root-dirty"], "split": "train"}
{"id": "egraph_egraph_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: small integration task across module primitives.\n\nBuild `(g (f x))` and `(g (f y))`, merge `x`/`y`, saturate rebuild, and return whether roots match.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([gfx (egraph-add-term! eg '(g (f x)))] [gfy (egraph-add-term! eg '(g (f y)))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg) (= (egraph-find eg gfx) (egraph-find eg gfy))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([gfx (egraph-add-term! eg '(g (f x)))] [gfy (egraph-add-term! eg '(g (f y)))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg) (= (egraph-find eg gfx) (egraph-find eg gfy)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-rebuild!", "nested"], "split": "train"}
{"id": "egraph_egraph_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: compose existing APIs into one expression.\n\nOn a clean graph after saturation, call `egraph-rebuild!` and return the processed count.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-saturate-rebuild! eg) (egraph-rebuild! eg)) 0))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-rebuild!", "fixpoint"], "split": "train"}
{"id": "egraph_egraph_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd `(+ x y)` with `egraph-add-term!` and return `(list class-count node-count)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (list (egraph-class-count eg) (egraph-node-count eg)))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (list (egraph-class-count eg) (egraph-node-count eg))) '(3 3)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-term!", "structure"], "split": "train"}
{"id": "egraph_egraph_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert `(+ x x)` and return class count to confirm subterm sharing.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (egraph-class-count eg))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (egraph-class-count eg)) 2))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-term!", "sharing"], "split": "train"}
{"id": "egraph_egraph_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAdd nested term `(+ (* a b) c)` and return resulting class count.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg '(+ (* a b) c)) (egraph-class-count eg))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ (* a b) c)) (egraph-class-count eg)) 5))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-term!", "nested"], "split": "train"}
{"id": "egraph_egraph_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert `(concat \"hello\" \" \" \"world\")` twice and return `(list class-count same-root?)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))] [b (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))]) (list (egraph-class-count eg) (= (egraph-find eg a) (egraph-find eg b)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))] [b (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))]) (list (egraph-class-count eg) (= (egraph-find eg a) (egraph-find eg b))))) '(4 #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-term!", "literals"], "split": "eval"}
