{"id": "egraph_egraph_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph?`\nSpec: Recognize e-graph values by vector shape and tag.\n\nReturn exactly one definition for `egraph?` and no extra text.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (egraph? (make-egraph))\n  (not (egraph? '(egraph)))\n  (not (egraph? (vector 'egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty)))\n  (not (egraph? (vector 'not-egraph\n                       (make-uf)\n                       (make-eclass-store)\n                       (make-eqv-hashtable)\n                       hamt-empty\n                       (vector 0 0 0 0))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph?"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph?`\nSpec: Recognize e-graph values by vector shape and tag.\n\nReturn exactly one definition for `egraph?` and no extra text.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (egraph? (make-egraph)))\n(let () (not (egraph? '(egraph))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_egraph_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-lookup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-lookup`\nSpec: Canonicalize an e-node, probe hashcons, and return canonical class ID or #f.\n\nReturn exactly one definition for `egraph-lookup` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-lookup eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [found (hashtable-ref hashcons canonical #f)])\n    (and found (uf-find uf found))))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([n (make-enode 'q (vector))])\n      (and (not (egraph-lookup eg n))\n           (let ([id (egraph-add-enode! eg n)])\n             (= (egraph-lookup eg n) id)))))\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (egraph-saturate-rebuild! eg)\n      (= (egraph-find eg fx)\n         (egraph-lookup eg (make-enode 'f (vector y))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-lookup"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-lookup`\nSpec: Canonicalize an e-node, probe hashcons, and return canonical class ID or #f.\n\nReturn exactly one definition for `egraph-lookup` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "egraph_egraph_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-rebuild!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-rebuild!`\nSpec: Process dirty classes, canonicalize nodes, maintain hashcons, and trigger congruence merges.\n\nReturn exactly one definition for `egraph-rebuild!` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (let ([fx (egraph-add-term! eg '(f x))]\n          [fy (egraph-add-term! eg '(f y))]\n          [x (egraph-add-term! eg 'x)]\n          [y (egraph-add-term! eg 'y)])\n      (egraph-merge! eg x y)\n      (let ([processed (egraph-rebuild! eg)])\n        (and (> processed 0)\n             (= (egraph-find eg fx) (egraph-find eg fy))\n             (= (egraph-rebuild! eg) 0)))))\n  (let ([eg (make-egraph)])\n    (let ([fa (egraph-add-term! eg '(f a))]\n          [fb (egraph-add-term! eg '(f b))]\n          [fc (egraph-add-term! eg '(f c))]\n          [a (egraph-add-term! eg 'a)]\n          [b (egraph-add-term! eg 'b)]\n          [c (egraph-add-term! eg 'c)])\n      (egraph-merge! eg a b)\n      (egraph-merge! eg b c)\n      (let ([total (egraph-saturate-rebuild! eg)])\n        (and (> total 0)\n             (= (egraph-find eg fa) (egraph-find eg fb))\n             (= (egraph-find eg fb) (egraph-find eg fc))))))))", "tags": ["tier1", "egraph", "egraph-core", "spec-to-code", "egraph-rebuild!"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph function in Fold-native Scheme.\n\nTarget module: lattice/egraph/egraph.ss\nFunction: `egraph-rebuild!`\nSpec: Process dirty classes, canonicalize nodes, maintain hashcons, and trigger congruence merges.\n\nReturn exactly one definition for `egraph-rebuild!` and no extra text.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (let ([processed (egraph-rebuild! eg)]) (and (> processed 0) (= (egraph-find eg fx) (egraph-find eg fy)) (= (egraph-rebuild! eg) 0))))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "egraph_egraph_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `make-egraph`.\nReturn only the Scheme function definition.\n\n```python\ndef make_egraph():\n    return {\n        \"tag\": \"egraph\",\n        \"uf\": make_uf(),\n        \"classes\": make_eclass_store(),\n        \"hashcons\": {},\n        \"dirty\": persistent_empty_map(),\n        \"stats\": [0, 0, 0, 0],\n    }\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "make-egraph"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `make-egraph`.\nReturn only the Scheme function definition.\n\n```python\ndef make_egraph():\n    return {\n        \"tag\": \"egraph\",\n        \"uf\": make_uf(),\n        \"classes\": make_eclass_store(),\n        \"hashcons\": {},\n        \"dirty\": persistent_empty_map(),\n        \"stats\": [0, 0, 0, 0],\n    }\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "egraph_egraph_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-add-enode!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_add_enode(eg, enode):\n    uf = egraph_uf(eg)\n    canonical = enode_canonicalize(enode, uf)\n    table = egraph_hashcons(eg)\n    existing = table.get(canonical)\n    if existing is not None:\n        egraph_inc_stat(eg, 3)\n        return uf_find(uf, existing)\n\n    classes = egraph_classes(eg)\n    new_id = uf_make_set(uf)\n    egraph_inc_stat(eg, 0)\n    table[canonical] = new_id\n    eclass_add_node(classes, new_id, canonical)\n\n    for child in enode_children(canonical):\n        child_id = egraph_find(eg, child)\n        eclass_add_parent(classes, child_id, new_id)\n    return new_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "python-to-scheme", "egraph-add-enode!"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python implementation into Fold-native Scheme.\nPreserve behavior and use the exact target name `egraph-add-enode!`.\nReturn only the Scheme function definition.\n\n```python\ndef egraph_add_enode(eg, enode):\n    uf = egraph_uf(eg)\n    canonical = enode_canonicalize(enode, uf)\n    table = egraph_hashcons(eg)\n    existing = table.get(canonical)\n    if existing is not None:\n        egraph_inc_stat(eg, 3)\n        return uf_find(uf, existing)\n\n    classes = egraph_classes(eg)\n    new_id = uf_make_set(uf)\n    egraph_inc_stat(eg, 0)\n    table[canonical] = new_id\n    eclass_add_node(classes, new_id, canonical)\n\n    for child in enode_children(canonical):\n        child_id = egraph_find(eg, child)\n        eclass_add_parent(classes, child_id, new_id)\n    return new_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "egraph_egraph_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-add-term!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-add-term! eg term)\n  (if (pair? term)\n      (let* ([op (car term)]\n             [args (cdr term)]\n             [kids (map (lambda (arg) (eg-add-term! eg arg)) args)])\n        (egraph-add-enode! eg (make-enode op (list->vector kids))))\n      (egraph-add-enode! eg (make-enode term (vector)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "chez-to-fold", "egraph-add-term!"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet into canonical Fold style.\nTarget function name: `egraph-add-term!`.\nReturn only the final Fold definition.\n\n```scheme\n(define (eg-add-term! eg term)\n  (if (pair? term)\n      (let* ([op (car term)]\n             [args (cdr term)]\n             [kids (map (lambda (arg) (eg-add-term! eg arg)) args)])\n        (egraph-add-enode! eg (make-enode op (list->vector kids))))\n      (egraph-add-enode! eg (make-enode term (vector)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x x)) (= (egraph-class-count eg) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "egraph_egraph_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-egraph` in `lattice/egraph/egraph.ss`.\nKnown issue: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\n```scheme\n(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-size eg)\n  (uf-size (egraph-uf eg)))\n  (define (egraph? x)\n  (and (vector? x)\n       (>= (vector-length x) 6)\n       (eq? (vector-ref x 0) egraph-tag)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (and (egraph? eg)\n         (= (egraph-class-count eg) 0)\n         (= (egraph-node-count eg) 0)\n         (= (egraph-stat-adds eg) 0)\n         (= (egraph-stat-hits eg) 0)\n         (hamt-empty? (egraph-dirty-set eg))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (and (= x 0)\n           (= (egraph-size eg) 1)\n           (= (egraph-class-count eg) 1))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "make-egraph"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-egraph` in `lattice/egraph/egraph.ss`.\nKnown issue: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\n```scheme\n(define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Stats vector must track adds, merges, rebuilds, and hashcons hits (4 slots).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([eg (make-egraph)]) (and (egraph? eg) (= (egraph-class-count eg) 0) (= (egraph-node-count eg) 0) (= (egraph-stat-adds eg) 0) (= (egraph-stat-hits eg) 0) (hamt-empty? (egraph-dirty-set eg)))))\n(let () (let ([eg (make-egraph)]) (let ([x (egraph-add-term! eg 'x)]) (and (= x 0) (= (egraph-size eg) 1) (= (egraph-class-count eg) 1)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_egraph_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-enode!` in `lattice/egraph/egraph.ss`.\nKnown issue: Hashcons hit path must return canonical representative, not possibly stale ID.\n\n```scheme\n(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          existing)\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)]\n        [n (make-enode 'x (vector))])\n    (let ([id1 (egraph-add-enode! eg n)]\n          [id2 (egraph-add-enode! eg n)])\n      (and (= id1 id2)\n           (= (egraph-class-count eg) 1)\n           (= (egraph-stat-adds eg) 1)\n           (= (egraph-stat-hits eg) 1))))\n  (let ([eg (make-egraph)])\n    (let ([x (egraph-add-term! eg 'x)])\n      (let* ([parent-id (egraph-add-enode! eg (make-enode 'f (vector x)))]\n             [parents (eclass-get-parents (egraph-classes eg) x)])\n        (and (not (null? parents))\n             (not (not (memv parent-id parents)))))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-enode!"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-enode!` in `lattice/egraph/egraph.ss`.\nKnown issue: Hashcons hit path must return canonical representative, not possibly stale ID.\n\n```scheme\n(define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          existing)\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "egraph_egraph_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-term!` in `lattice/egraph/egraph.ss`.\nKnown issue: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\n```scheme\n(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode 'term (vector)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (and\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x y))\n    (= (egraph-class-count eg) 3))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ x x))\n    (= (egraph-class-count eg) 2))\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg '(+ (* a b) c))\n    (= (egraph-class-count eg) 5))\n  (let ([eg (make-egraph)])\n    (let ([id1 (egraph-add-term! eg \"hello\")]\n          [id2 (egraph-add-term! eg \"hello\")])\n      (= (egraph-find eg id1) (egraph-find eg id2))))))", "tags": ["tier1", "egraph", "egraph-core", "bugfix", "egraph-add-term!"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `egraph-add-term!` in `lattice/egraph/egraph.ss`.\nKnown issue: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\n```scheme\n(define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode 'term (vector)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Leaf terms must preserve the literal value; they cannot all map to symbol `'term`.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([eg (make-egraph)]) (egraph-add-term! eg '(+ x y)) (= (egraph-class-count eg) 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault."}
{"id": "egraph_egraph_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "make-egraph", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate an e-graph, add `x` and `y`, then return `(list class-count node-count adds)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (list (egraph-class-count eg) (egraph-node-count eg) (egraph-stat-adds eg)))", "verify_expr": "(let ()\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-stat-adds eg) (vector-ref (egraph-stats eg) 0))\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-node-count eg)\n  (eclass-node-count (egraph-classes eg) (egraph-uf eg)))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (list (egraph-class-count eg) (egraph-node-count eg) (egraph-stat-adds eg))) '(2 2 2)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "make-egraph", "integration"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCreate an e-graph, add `x` and `y`, then return `(list class-count node-count adds)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_egraph_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd `a` and `b`, merge them, and return whether their roots are equal.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (= (egraph-find eg a) (egraph-find eg b))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)]) (egraph-merge! eg a b) (= (egraph-find eg a) (egraph-find eg b)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-find", "merge"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nAdd `a` and `b`, merge them, and return whether their roots are equal.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_egraph_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-enode!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert the same enode twice with `egraph-add-enode!` and return `(same-id? hits classes)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (list (= id1 id2) (egraph-stat-hits eg) (egraph-class-count eg))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-stat-hits eg) (vector-ref (egraph-stats eg) 3))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)] [n (make-enode 'x (vector))]) (let ([id1 (egraph-add-enode! eg n)] [id2 (egraph-add-enode! eg n)]) (list (= id1 id2) (egraph-stat-hits eg) (egraph-class-count eg)))) '(#t 1 1)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-enode!", "dedup"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nInsert the same enode twice with `egraph-add-enode!` and return `(same-id? hits classes)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_egraph_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-merge!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nShow congruence closure by merging `x`/`y` and testing roots of `(f x)` and `(f y)` after rebuild.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-dirty-set eg) (vector-ref eg 4))\n  (define (egraph-set-dirty-set! eg ds) (vector-set! eg 4 ds))\n  (define (egraph-mark-dirty! eg class-id)\n  (egraph-set-dirty-set! eg (hamt-assoc class-id #t (egraph-dirty-set eg))))\n  (define (egraph-merge! eg id1 id2)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)])\n    (let ([root1 (uf-find uf id1)]\n          [root2 (uf-find uf id2)])\n      (if (= root1 root2)\n          root1\n          (begin\n            (egraph-inc-stat! eg 1)\n            (let ([new-root (uf-union! uf id1 id2)])\n              (let ([affected (eclass-merge! classes uf id1 id2)])\n                (for-each (lambda (p) (egraph-mark-dirty! eg p))\n                          affected))\n              new-root))))))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-pop-dirty! eg)\n  (let ([ds (egraph-dirty-set eg)])\n    (if (hamt-empty? ds)\n        #f\n        (let ([id (hamt-first-key ds)])\n          (egraph-set-dirty-set! eg (hamt-dissoc id ds))\n          id))))\n  (define (egraph-rebuild! eg)\n  (let ([uf (egraph-uf eg)]\n        [classes (egraph-classes eg)]\n        [hashcons (egraph-hashcons eg)]\n        [visited (make-eqv-hashtable)]\n        [count 0])\n    (let loop ()\n      (let ([dirty-id (egraph-pop-dirty! eg)])\n        (if (not dirty-id)\n            count\n            (let ([root (uf-find uf dirty-id)])\n              (unless (hashtable-ref visited root #f)\n                (hashtable-set! visited root #t)\n                (egraph-inc-stat! eg 2)\n                (set! count (+ count 1))\n                (let ([nodes (eclass-get-nodes classes root)])\n                  (for-each\n                   (lambda (enode)\n                     (let ([canonical (enode-canonicalize enode uf)])\n                       (unless (enode-equal? enode canonical)\n                         (hashtable-delete! hashcons enode))\n                       (let ([existing (hashtable-ref hashcons canonical #f)])\n                         (cond\n                           [(not existing)\n                            (hashtable-set! hashcons canonical root)]\n                           [(not (= (uf-find uf existing) root))\n                            (let ([new-root (egraph-merge! eg root existing)])\n                              (hashtable-set! hashcons canonical new-root))]))))\n                   nodes)))\n              (loop)))))))\n  (define (egraph-saturate-rebuild! eg)\n  (let loop ([total 0])\n    (let ([processed (egraph-rebuild! eg)])\n      (if (zero? processed)\n          total\n          (loop (+ total processed))))))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([fx (egraph-add-term! eg '(f x))] [fy (egraph-add-term! eg '(f y))] [x (egraph-add-term! eg 'x)] [y (egraph-add-term! eg 'y)]) (egraph-merge! eg x y) (egraph-saturate-rebuild! eg) (= (egraph-find eg fx) (egraph-find eg fy)))) #t))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-merge!", "congruence"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nShow congruence closure by merging `x`/`y` and testing roots of `(f x)` and `(f y)` after rebuild.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "egraph_egraph_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/egraph.ss", "source_test": "lattice/egraph/test-egraph.ss", "source_function": "egraph-add-term!", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert `(concat \"hello\" \" \" \"world\")` twice and return `(list class-count same-root?)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))] [b (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))]) (list (egraph-class-count eg) (= (egraph-find eg a) (egraph-find eg b)))))", "verify_expr": "(let ()\n  (define (egraph-uf eg) (vector-ref eg 1))\n  (define (egraph-hashcons eg) (vector-ref eg 3))\n  (define (egraph-classes eg) (vector-ref eg 2))\n  (define (egraph-stats eg) (vector-ref eg 5))\n  (define (egraph-inc-stat! eg idx)\n  (let ([stats (egraph-stats eg)])\n    (vector-set! stats idx (+ (vector-ref stats idx) 1))))\n  (define (egraph-find eg id)\n  (uf-find (egraph-uf eg) id))\n  (define (egraph-add-enode! eg enode)\n  (let* ([uf (egraph-uf eg)]\n         [canonical (enode-canonicalize enode uf)]\n         [hashcons (egraph-hashcons eg)]\n         [existing (hashtable-ref hashcons canonical #f)])\n    (if existing\n        (begin\n          (egraph-inc-stat! eg 3)\n          (uf-find uf existing))\n        (let* ([classes (egraph-classes eg)]\n               [new-id (uf-make-set! uf)])\n          (egraph-inc-stat! eg 0)\n          (hashtable-set! hashcons canonical new-id)\n          (eclass-add-node! classes new-id canonical)\n          (let ([children (enode-children canonical)])\n            (do ([i 0 (+ i 1)])\n                ((>= i (vector-length children)))\n              (let ([child-id (egraph-find eg (vector-ref children i))])\n                (eclass-add-parent! classes child-id new-id))))\n          new-id))))\n  (define (egraph-add-term! eg term)\n  (cond\n    [(pair? term)\n     (let* ([op (car term)]\n            [args (cdr term)]\n            [child-ids (map (lambda (arg) (egraph-add-term! eg arg)) args)]\n            [enode (make-enode op (list->vector child-ids))])\n       (egraph-add-enode! eg enode))]\n    [else\n     (egraph-add-enode! eg (make-enode term (vector)))]))\n  (define (egraph-class-count eg)\n  (uf-count (egraph-uf eg)))\n  (define egraph-tag 'egraph)\n  (define (make-egraph)\n  (vector egraph-tag\n          (make-uf)\n          (make-eclass-store)\n          (make-hashtable enode-hash enode-equal?)\n          hamt-empty\n          (vector 0 0 0 0)))\n  (load \"lattice/egraph/union-find.ss\")\n  (load \"lattice/egraph/eclass.ss\")\n  (equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))] [b (egraph-add-term! eg '(concat \"hello\" \" \" \"world\"))]) (list (egraph-class-count eg) (= (egraph-find eg a) (egraph-find eg b))))) '(4 #t)))", "tags": ["tier1", "egraph", "egraph-core", "composition", "egraph-add-term!", "literals"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nInsert `(concat \"hello\" \" \" \"world\")` twice and return `(list class-count same-root?)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
