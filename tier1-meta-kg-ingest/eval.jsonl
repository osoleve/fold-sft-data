{"id": "meta_kg_ingest_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-normalize-relation`\nSpec: Map common relation phrases to canonical predicates (works_at, located_in, part_of, founded) with rel_* fallback.\n\nWrite exactly one Scheme function definition for `kg-normalize-relation`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-normalize-relation"], "split": "eval"}
{"id": "meta_kg_ingest_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-valid-triple?`\nSpec: Accept only well-formed 3-symbol triples that do not contain unknown placeholders.\n\nWrite exactly one Scheme function definition for `kg-valid-triple?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-valid-triple?"], "split": "eval"}
{"id": "meta_kg_ingest_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-upsert-triple`\nSpec: Insert one triple into a nested alist KG store (subject->predicate->objects) without duplicating objects.\n\nWrite exactly one Scheme function definition for `kg-upsert-triple`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-upsert-triple"], "split": "eval"}
{"id": "meta_kg_ingest_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-normalize-entity`\n\n```python\ndef kg_normalize_entity(x):\n    s = x if isinstance(x, str) else str(x)\n    tokens = tokenize_simple(s)\n    if not tokens:\n        return \"unknown\"\n    return \"-\".join(tokens)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-normalize-entity"], "split": "eval"}
{"id": "meta_kg_ingest_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-parse-simple-fact`\n\n```python\ndef kg_parse_simple_fact(sentence):\n    tokens = tokenize_simple(sentence)\n    for pattern, rel in [\n        ([\"works\", \"at\"], \"works at\"),\n        ([\"employed\", \"by\"], \"works at\"),\n        ([\"lives\", \"in\"], \"lives in\"),\n        ([\"is\", \"part\", \"of\"], \"part of\"),\n        ([\"part\", \"of\"], \"part of\"),\n        ([\"founded\"], \"founded\"),\n    ]:\n        i = find_subseq(tokens, pattern)\n        if i is not None:\n            subj = tokens[:i]\n            obj = tokens[i + len(pattern):]\n            if subj and obj:\n                return kg_make_triple(\" \".join(subj), rel, \" \".join(obj))\n            return None\n    return None\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-parse-simple-fact"], "split": "eval"}
{"id": "meta_kg_ingest_translation_016", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-upsert-triples`\n\n```scheme\n(define (upsert-triples store triples)\n  (fold-left (lambda (acc t) (kg-upsert-triple acc t))\n             store\n             triples))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (kg-upsert-triples '() '((ada works_at acme) (bob located_in paris) (ada works_at acme) (ada founded analytical-engine))) '((ada (works_at acme) (founded analytical-engine)) (bob (located_in paris))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-upsert-triples"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-normalize-entity` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Entity normalization must tokenize and hyphenate; simple downcasing leaves punctuation/spacing artifacts.\n\n```scheme\n(define (kg-normalize-entity x)\n  (let* ([s (if (symbol? x) (symbol->string x) x)])\n    (if (or (not s) (= (string-length s) 0))\n        'unknown\n        (string->symbol (string-downcase s)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-normalize-entity"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-parse-simple-fact` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Parser should support multiple relation patterns (lives in, part of, founded, employed by).\n\n```scheme\n(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                  (and x (cons x \"works at\")))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (kg-make-triple (string-join subject-tokens \" \")\n                          \"works at\"\n                          (string-join object-tokens \" \"))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-parse-simple-fact"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-upsert-triples` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Batch upsert must start from input store; resetting to empty drops existing KG state.\n\n```scheme\n(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   '()\n   triples))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-upsert-triples"], "split": "eval"}
{"id": "meta_kg_ingest_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize the entity text 'Ada Lovelace, PhD!' into a canonical symbol.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-normalize-entity \"Ada Lovelace, PhD!\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-entity \"Ada Lovelace, PhD!\") 'ada-lovelace-phd))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-entity", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a normalized triple from raw text fields for a work relation.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-make-triple", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: small integration task across module primitives.\n\nParse a basic work sentence into a triple.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-parse-simple-fact \"Ada works at Acme\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-parse-simple-fact", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose extraction with upsert and return resulting store for three facts.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\"))) '((ada (works_at acme) (founded engine)) (bob (located_in paris))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\")))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\"))) '((ada (works_at acme) (founded engine)) (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-extract-triples", "integration"], "split": "eval"}
{"id": "meta_kg_ingest_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: small integration task across module primitives.\n\nBatch upsert parsed facts and return object list for (ada, works_at).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([store (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Babbage Labs\")))] [preds (cdr (assq 'ada store))] [row (assq 'works_at preds)]) (cdr row))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (let* ([store (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Babbage Labs\")))] [preds (cdr (assq 'ada store))] [row (assq 'works_at preds)]) (cdr row)) '(acme babbage-labs)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triples", "query-shape"], "split": "eval"}
