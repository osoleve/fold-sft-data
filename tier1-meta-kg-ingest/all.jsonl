{"id": "meta_kg_ingest_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-normalize-entity`\nSpec: Canonicalize an entity token/string to a lowercase hyphenated symbol, returning 'unknown for empty input.\n\nWrite exactly one Scheme function definition for `kg-normalize-entity`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-normalize-entity"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-normalize-entity`\nBehavior contract: Canonicalize an entity token/string to a lowercase hyphenated symbol, returning 'unknown for empty input.\n\n```scheme\n(define (kg-normalize-entity x)\n  ;; TODO: canonicalize entity text into a symbol\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-normalize-entity"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-normalize-relation`\nBehavior contract: Map common relation phrases to canonical predicates (works_at, located_in, part_of, founded) with rel_* fallback.\n\n```scheme\n(define (kg-normalize-relation rel)\n  ;; TODO: map relation phrase aliases to canonical predicate symbols\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-normalize-relation"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-make-triple`\nSpec: Build a normalized (subject predicate object) triple from raw subject/relation/object strings or symbols.\n\nWrite exactly one Scheme function definition for `kg-make-triple`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine))\n(equal? (kg-make-triple 'Paris \"located in\" 'France) '(paris located_in france))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-make-triple`\nBehavior contract: Build a normalized (subject predicate object) triple from raw subject/relation/object strings or symbols.\n\n```scheme\n(define (kg-make-triple subject relation object)\n  ;; TODO: construct normalized (subject predicate object)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine))\n(equal? (kg-make-triple 'Paris \"located in\" 'France) '(paris located_in france))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-valid-triple?`\nBehavior contract: Accept only well-formed 3-symbol triples that do not contain unknown placeholders.\n\n```scheme\n(define (kg-valid-triple? triple)\n  ;; TODO: validate structure and reject unknown placeholders\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-valid-triple?"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-parse-simple-fact`\nSpec: Extract one triple from a simple natural-language fact sentence using controlled relation patterns.\n\nWrite exactly one Scheme function definition for `kg-parse-simple-fact`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-parse-simple-fact"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-parse-simple-fact`\nBehavior contract: Extract one triple from a simple natural-language fact sentence using controlled relation patterns.\n\n```scheme\n(define (kg-parse-simple-fact sentence)\n  ;; TODO: parse one simple NL sentence into a normalized triple\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-parse-simple-fact"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-extract-triples`\nSpec: Parse a sentence list into deduplicated, valid triples while discarding non-facts.\n\nWrite exactly one Scheme function definition for `kg-extract-triples`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\" \"No relation sentence\")) '((ada works_at acme) (bob located_in paris)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-extract-triples`\nBehavior contract: Parse a sentence list into deduplicated, valid triples while discarding non-facts.\n\n```scheme\n(define (kg-extract-triples sentences)\n  ;; TODO: parse all sentences, keep valid triples, and deduplicate\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\" \"No relation sentence\")) '((ada works_at acme) (bob located_in paris)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-upsert-triple`\nBehavior contract: Insert one triple into a nested alist KG store (subject->predicate->objects) without duplicating objects.\n\n```scheme\n(define (kg-upsert-triple store triple)\n  ;; TODO: upsert a triple into nested subject/predicate/object store\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-upsert-triple"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-upsert-triples`\nSpec: Batch-upsert triples into an existing KG store via left fold.\n\nWrite exactly one Scheme function definition for `kg-upsert-triples`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-upsert-triples"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/meta/kg-ingest.ss\nFunction target: `kg-upsert-triples`\nBehavior contract: Batch-upsert triples into an existing KG store via left fold.\n\n```scheme\n(define (kg-upsert-triples store triples)\n  ;; TODO: fold kg-upsert-triple across triple list\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "skeleton", "kg-upsert-triples"], "split": "train"}
{"id": "meta_kg_ingest_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-normalize-entity`\n\n```scheme\n(define (normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-normalize-entity"], "split": "train"}
{"id": "meta_kg_ingest_translation_003", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-normalize-relation`\n\n```python\ndef kg_normalize_relation(rel):\n    tokens = tokenize_simple(rel)\n    if tokens in ([\"works\", \"at\"], [\"employed\", \"by\"], [\"employee\", \"of\"]):\n        return \"works_at\"\n    if tokens in ([\"lives\", \"in\"], [\"located\", \"in\"], [\"in\"]):\n        return \"located_in\"\n    if tokens in ([\"is\", \"part\", \"of\"], [\"part\", \"of\"], [\"member\", \"of\"]):\n        return \"part_of\"\n    if tokens == [\"founded\"]:\n        return \"founded\"\n    if not tokens:\n        return \"unknown_relation\"\n    return \"rel_\" + \"-\".join(tokens)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-normalize-relation"], "split": "train"}
{"id": "meta_kg_ingest_translation_004", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-normalize-relation`\n\n```scheme\n(define (normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol (string-append \"rel_\" (string-join tokens \"-\")))])))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-normalize-relation"], "split": "train"}
{"id": "meta_kg_ingest_translation_005", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-make-triple`\n\n```python\ndef kg_make_triple(subject, relation, obj):\n    return [kg_normalize_entity(subject),\n            kg_normalize_relation(relation),\n            kg_normalize_entity(obj)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine))\n(equal? (kg-make-triple 'Paris \"located in\" 'France) '(paris located_in france))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_translation_006", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-make-triple`\n\n```scheme\n(define (make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine))\n(equal? (kg-make-triple 'Paris \"located in\" 'France) '(paris located_in france))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-valid-triple?`\n\n```python\ndef kg_valid_triple(triple):\n    return (\n        isinstance(triple, list)\n        and len(triple) == 3\n        and all(isinstance(x, str) for x in triple)\n        and triple[0] != \"unknown\"\n        and triple[2] != \"unknown\"\n        and triple[1] != \"unknown_relation\"\n    )\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-valid-triple?"], "split": "train"}
{"id": "meta_kg_ingest_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-valid-triple?`\n\n```scheme\n(define (valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-valid-triple?"], "split": "train"}
{"id": "meta_kg_ingest_translation_010", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-parse-simple-fact`\n\n```scheme\n(define (parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))]) (and x (cons x \"works at\")))\n                    (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))]) (and x (cons x \"works at\")))\n                    (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))]) (and x (cons x \"lives in\")))\n                    (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))]) (and x (cons x \"part of\")))\n                    (let ([x (split-on-pattern tokens '(\"part\" \"of\"))]) (and x (cons x \"part of\")))\n                    (let ([x (split-on-pattern tokens '(\"founded\"))]) (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subj (car parts)]\n               [obj (cdr parts)])\n          (if (or (null? subj) (null? obj))\n              #f\n              (kg-make-triple (string-join subj \" \") rel (string-join obj \" \")))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-parse-simple-fact"], "split": "train"}
{"id": "meta_kg_ingest_translation_011", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-extract-triples`\n\n```python\ndef kg_extract_triples(sentences):\n    out = []\n    for s in sentences:\n        t = kg_parse_simple_fact(s)\n        if t is not None and kg_valid_triple(t) and t not in out:\n            out.append(t)\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\" \"No relation sentence\")) '((ada works_at acme) (bob located_in paris)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_translation_012", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-extract-triples`\n\n```scheme\n(define (extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([t (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and t (kg-valid-triple? t) (not (contains-equal? t acc)))\n                    (cons t acc)\n                    acc))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_translation_013", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-upsert-triple`\n\n```python\ndef kg_upsert_triple(store, triple):\n    if not kg_valid_triple(triple):\n        return store\n    s, p, o = triple\n    preds = dict(store.get(s, {}))\n    objs = list(preds.get(p, []))\n    if o not in objs:\n        objs.append(o)\n    preds[p] = objs\n    new_store = dict(store)\n    new_store[s] = preds\n    return new_store\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-upsert-triple"], "split": "train"}
{"id": "meta_kg_ingest_translation_014", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-upsert-triple`\n\n```scheme\n(define (upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-upsert-triple"], "split": "train"}
{"id": "meta_kg_ingest_translation_015", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-upsert-triples`\n\n```python\ndef kg_upsert_triples(store, triples):\n    acc = store\n    for triple in triples:\n        acc = kg_upsert_triple(acc, triple)\n    return acc\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (kg-upsert-triples '() '((ada works_at acme) (bob located_in paris) (ada works_at acme) (ada founded analytical-engine))) '((ada (works_at acme) (founded analytical-engine)) (bob (located_in paris))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-upsert-triples"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-normalize-entity` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Multi-token entities must keep all tokens, not only the first token.\n\n```scheme\n(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (car tokens)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-normalize-entity"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-normalize-relation` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Known relation aliases (employee of / employed by / is part of) must map to canonical predicates.\n\n```scheme\n(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(equal? tokens '(\"works\" \"at\")) 'works_at]\n      [(equal? tokens '(\"lives\" \"in\")) 'located_in]\n      [(equal? tokens '(\"part\" \"of\")) 'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [else 'unknown_relation])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-normalize-relation"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-normalize-relation` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Unknown relations should be preserved as rel_* predicates, not collapsed to unknown_relation.\n\n```scheme\n(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else 'unknown_relation])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-normalize-relation"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-make-triple` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Relation field must be normalized with kg-normalize-relation.\n\n```scheme\n(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        relation\n        (kg-normalize-entity object)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-make-triple` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Subject/object order is reversed; preserve (subject predicate object).\n\n```scheme\n(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity object)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity subject)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine))\n(equal? (kg-make-triple 'Paris \"located in\" 'France) '(paris located_in france))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (and\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")\n          '(ada-lovelace works_at analytical-engine))\n  (equal? (kg-make-triple 'Paris \"located in\" 'France)\n          '(paris located_in france))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-make-triple"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-valid-triple?` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Validation must enforce symbol fields and reject unknown placeholders.\n\n```scheme\n(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-valid-triple?"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-valid-triple?` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Triples containing unknown/unknown_relation should be rejected as invalid facts.\n\n```scheme\n(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)))) )\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-valid-triple?"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-parse-simple-fact` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Reject malformed facts with empty subject or object instead of emitting unknown placeholders.\n\n```scheme\n(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))]) (and x (cons x \"works at\")))\n                    (let ([x (split-on-pattern tokens '(\"founded\"))]) (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (kg-make-triple (string-join subject-tokens \" \")\n                          rel\n                          (string-join object-tokens \" \"))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-parse-simple-fact"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-extract-triples` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Extraction must deduplicate repeated facts and filter invalid triples.\n\n```scheme\n(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if triple\n                    (cons triple acc)\n                    acc))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\" \"No relation sentence\")) '((ada works_at acme) (bob located_in paris)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-extract-triples` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Map-only implementation leaks #f values and duplicates; require parsed/valid/deduplicated output.\n\n```scheme\n(define (kg-extract-triples sentences)\n  (map kg-parse-simple-fact sentences))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (equal?\n  (kg-extract-triples '(\"Ada works at Acme\"\n                        \"Ada works at Acme\"\n                        \"Bob lives in Paris\"\n                        \"No relation sentence\"))\n  '((ada works_at acme)\n    (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-extract-triples"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-upsert-triple` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Object lists should be set-like per predicate; avoid inserting duplicates on repeated upsert.\n\n```scheme\n(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (append objs (list o))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-upsert-triple"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-upsert-triple` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Upsert should preserve existing predicates/objects for a subject instead of overwriting the entire row.\n\n```scheme\n(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [preds2 (list (cons p (list o)))])\n        (alist-set store s preds2))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-upsert-triple"], "split": "train"}
{"id": "meta_kg_ingest_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-upsert-triples` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Batch upsert must thread the evolving accumulator, not repeatedly use the original store.\n\n```scheme\n(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (_ triple)\n     (kg-upsert-triple store triple))\n   store\n   triples))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-upsert-triples"], "split": "train"}
{"id": "meta_kg_ingest_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize a symbol input 'New_York into canonical entity form.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-normalize-entity 'New_York)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-entity 'New_York) 'new-york))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-entity", "symbol-input"], "split": "train"}
{"id": "meta_kg_ingest_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap normalization over three raw entities and return the resulting symbol list.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map kg-normalize-entity '(\"Alan Turing\" \"Bletchley Park\" \"C3PO\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (map kg-normalize-entity '(\"Alan Turing\" \"Bletchley Park\" \"C3PO\")) '(alan-turing bletchley-park c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-entity", "map"], "split": "train"}
{"id": "meta_kg_ingest_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: small integration task across module primitives.\n\nCompose entity normalization with triple construction and return the subject symbol.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (car (kg-make-triple \"Grace Hopper\" \"founded\" \"COBOL\")) 'grace-hopper)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(car (kg-make-triple \"Grace Hopper\" \"founded\" \"COBOL\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (car (kg-make-triple \"Grace Hopper\" \"founded\" \"COBOL\")) 'grace-hopper))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-entity", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nNormalize relation phrase 'employee of to the canonical predicate.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-normalize-relation \"employee of\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-relation \"employee of\") 'works_at))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-relation", "alias"], "split": "train"}
{"id": "meta_kg_ingest_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: compose existing APIs into one expression.\n\nNormalize relation phrase 'member of to the canonical predicate.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-normalize-relation \"member of\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-relation \"member of\") 'part_of))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-relation", "alias"], "split": "train"}
{"id": "meta_kg_ingest_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nNormalize unknown relation phrase 'contains while preserving information as rel_*.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-normalize-relation \"contains\") 'rel_contains)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-normalize-relation \"contains\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-relation \"contains\") 'rel_contains))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-relation", "fallback"], "split": "train"}
{"id": "meta_kg_ingest_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse 'Ada employed by Acme' and return only the predicate from the extracted triple.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (cadr (kg-parse-simple-fact \"Ada employed by Acme\")) 'works_at)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cadr (kg-parse-simple-fact \"Ada employed by Acme\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (cadr (kg-parse-simple-fact \"Ada employed by Acme\")) 'works_at))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-relation", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConstruct a triple with an unknown relation phrase and keep rel_* fallback predicate.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-make-triple \"Parser\" \"contains\" \"Grammar\") '(parser rel_contains grammar))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-make-triple \"Parser\" \"contains\" \"Grammar\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-make-triple \"Parser\" \"contains\" \"Grammar\") '(parser rel_contains grammar)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-make-triple", "fallback"], "split": "train"}
{"id": "meta_kg_ingest_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpsert one freshly constructed triple and return the resulting store.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-upsert-triple '() (kg-make-triple \"Ada\" \"works at\" \"Acme\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triple '() (kg-make-triple \"Ada\" \"works at\" \"Acme\")) '((ada (works_at acme)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-make-triple", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild two triples and return whether their predicates are canonicalized to works_at and located_in.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([t1 (kg-make-triple \"Ada\" \"employee of\" \"Acme\")] [t2 (kg-make-triple \"Ada\" \"lives in\" \"Paris\")]) (list (cadr t1) (cadr t2))) '(works_at located_in))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([t1 (kg-make-triple \"Ada\" \"employee of\" \"Acme\")] [t2 (kg-make-triple \"Ada\" \"lives in\" \"Paris\")]) (list (cadr t1) (cadr t2)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (let ([t1 (kg-make-triple \"Ada\" \"employee of\" \"Acme\")] [t2 (kg-make-triple \"Ada\" \"lives in\" \"Paris\")]) (list (cadr t1) (cadr t2))) '(works_at located_in)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-make-triple", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck validity of a normal triple '(ada works_at acme).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-valid-triple? '(ada works_at acme))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-valid-triple? '(ada works_at acme)) #t))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-valid-triple?", "direct"], "split": "train"}
{"id": "meta_kg_ingest_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: small integration task across module primitives.\n\nReject a triple with unknown subject placeholder.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-valid-triple? '(unknown works_at acme)) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-valid-triple? '(unknown works_at acme))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-valid-triple? '(unknown works_at acme)) #f))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-valid-triple?", "edge-case"], "split": "train"}
{"id": "meta_kg_ingest_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse 'Ada works at Acme' and validate the extracted triple.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-valid-triple? (kg-parse-simple-fact \"Ada works at Acme\")) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-valid-triple? (kg-parse-simple-fact \"Ada works at Acme\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-valid-triple? (kg-parse-simple-fact \"Ada works at Acme\")) #t))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-valid-triple?", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter a mixed triple list by kg-valid-triple? and return the survivors.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(filter kg-valid-triple? '((ada works_at acme) (unknown works_at acme) (ada unknown_relation acme)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (filter kg-valid-triple? '((ada works_at acme) (unknown works_at acme) (ada unknown_relation acme))) '((ada works_at acme))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-valid-triple?", "filter"], "split": "train"}
{"id": "meta_kg_ingest_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse a part-of sentence into a triple.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-parse-simple-fact \"Paris is part of France\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-parse-simple-fact", "direct"], "split": "train"}
{"id": "meta_kg_ingest_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse a founded sentence into a triple.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-parse-simple-fact \"Linus founded Linux\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-parse-simple-fact", "direct"], "split": "train"}
{"id": "meta_kg_ingest_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #f for non-fact text that has no recognized relation pattern.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-parse-simple-fact \"This sentence has no supported relation\") #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-parse-simple-fact \"This sentence has no supported relation\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-parse-simple-fact \"This sentence has no supported relation\") #f))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-parse-simple-fact", "edge-case"], "split": "train"}
{"id": "meta_kg_ingest_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract triples from a sentence list with duplicates and return deduplicated results.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Acme\" \"Bob lives in Paris\")) '((ada works_at acme) (bob located_in paris))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-extract-triples", "dedupe"], "split": "train"}
{"id": "meta_kg_ingest_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract triples while ignoring unsupported lines and preserving first-seen order.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-extract-triples '(\"Noise\" \"Linus founded Linux\" \"Ada employed by Acme\" \"Noise\")) '((linus founded linux) (ada works_at acme)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-extract-triples '(\"Noise\" \"Linus founded Linux\" \"Ada employed by Acme\" \"Noise\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-extract-triples '(\"Noise\" \"Linus founded Linux\" \"Ada employed by Acme\" \"Noise\")) '((linus founded linux) (ada works_at acme))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-extract-triples", "robustness"], "split": "train"}
{"id": "meta_kg_ingest_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract triples from mixed relation forms including part-of and lives-in.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-extract-triples '(\"Graph is part of Math\" \"Ada lives in London\")) '((graph part_of math) (ada located_in london)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-extract-triples '(\"Graph is part of Math\" \"Ada lives in London\"))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-extract-triples '(\"Graph is part of Math\" \"Ada lives in London\")) '((graph part_of math) (ada located_in london))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-extract-triples", "coverage"], "split": "train"}
{"id": "meta_kg_ingest_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert one triple into an empty store and return the store.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triple '() '(ada works_at acme)) '((ada (works_at acme))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triple '() '(ada works_at acme))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triple '() '(ada works_at acme)) '((ada (works_at acme)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triple", "direct"], "split": "train"}
{"id": "meta_kg_ingest_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpsert the same triple twice and verify no duplicate object is created.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))] [s2 (kg-upsert-triple s1 '(ada works_at acme))]) s2) '((ada (works_at acme))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([s1 (kg-upsert-triple '() '(ada works_at acme))] [s2 (kg-upsert-triple s1 '(ada works_at acme))]) s2)", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))] [s2 (kg-upsert-triple s1 '(ada works_at acme))]) s2) '((ada (works_at acme)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triple", "dedupe"], "split": "train"}
{"id": "meta_kg_ingest_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUpsert a second predicate for an existing subject and return resulting subject row.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cdr (assq 'ada (kg-upsert-triple (kg-upsert-triple '() '(ada works_at acme)) '(ada founded engine))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (cdr (assq 'ada (kg-upsert-triple (kg-upsert-triple '() '(ada works_at acme)) '(ada founded engine)))) '((works_at acme) (founded engine))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triple", "integration"], "split": "train"}
{"id": "meta_kg_ingest_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAttempt to upsert an invalid triple and ensure the store is unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triple '((ada (works_at acme))) '(unknown works_at acme)) '((ada (works_at acme))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triple '((ada (works_at acme))) '(unknown works_at acme))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triple '((ada (works_at acme))) '(unknown works_at acme)) '((ada (works_at acme)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triple", "edge-case"], "split": "train"}
{"id": "meta_kg_ingest_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: small integration task across module primitives.\n\nBatch upsert three triples with one duplicate and return resulting store.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triples '() '((ada works_at acme) (ada works_at acme) (bob located_in paris))) '((ada (works_at acme)) (bob (located_in paris))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triples '() '((ada works_at acme) (ada works_at acme) (bob located_in paris)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triples '() '((ada works_at acme) (ada works_at acme) (bob located_in paris))) '((ada (works_at acme)) (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triples", "dedupe"], "split": "train"}
{"id": "meta_kg_ingest_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: compose existing APIs into one expression.\n\nBatch upsert into a non-empty store and keep prior facts.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triples '((ada (works_at acme))) '((ada founded engine) (carol located_in rome))) '((ada (works_at acme) (founded engine)) (carol (located_in rome))))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-upsert-triples '((ada (works_at acme))) '((ada founded engine) (carol located_in rome)))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triples '((ada (works_at acme))) '((ada founded engine) (carol located_in rome))) '((ada (works_at acme) (founded engine)) (carol (located_in rome)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triples", "existing-state"], "split": "train"}
{"id": "meta_kg_ingest_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract triples from NL text, then batch upsert and return final store.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada employed by Acme\" \"Ada founded Engine\" \"Ada employed by Acme\"))) '((ada (works_at acme) (founded engine))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triples '() (kg-extract-triples '(\"Ada employed by Acme\" \"Ada founded Engine\" \"Ada employed by Acme\")))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada employed by Acme\" \"Ada founded Engine\" \"Ada employed by Acme\"))) '((ada (works_at acme) (founded engine)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triples", "integration"], "split": "train"}
{"id": "meta_kg_ingest_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-relation", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-normalize-relation`\nSpec: Map common relation phrases to canonical predicates (works_at, located_in, part_of, founded) with rel_* fallback.\n\nWrite exactly one Scheme function definition for `kg-normalize-relation`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(eq? (kg-normalize-relation \"works at\") 'works_at)\n(eq? (kg-normalize-relation \"employee of\") 'works_at)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (and\n  (eq? (kg-normalize-relation \"works at\") 'works_at)\n  (eq? (kg-normalize-relation \"employee of\") 'works_at)\n  (eq? (kg-normalize-relation \"located in\") 'located_in)\n  (eq? (kg-normalize-relation \"part of\") 'part_of)\n  (eq? (kg-normalize-relation \"founded\") 'founded)\n  (eq? (kg-normalize-relation \"contains\") 'rel_contains)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-normalize-relation"], "split": "eval"}
{"id": "meta_kg_ingest_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-valid-triple?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-valid-triple?`\nSpec: Accept only well-formed 3-symbol triples that do not contain unknown placeholders.\n\nWrite exactly one Scheme function definition for `kg-valid-triple?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(kg-valid-triple? '(ada works_at acme))\n(not (kg-valid-triple? '(unknown works_at acme)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (and\n  (kg-valid-triple? '(ada works_at acme))\n  (not (kg-valid-triple? '(unknown works_at acme)))\n  (not (kg-valid-triple? '(ada unknown_relation acme)))\n  (not (kg-valid-triple? '(ada works_at)))\n  (not (kg-valid-triple? '(ada works_at 42)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-valid-triple?"], "split": "eval"}
{"id": "meta_kg_ingest_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triple", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/meta/kg-ingest.ss\nFunction: `kg-upsert-triple`\nSpec: Insert one triple into a nested alist KG store (subject->predicate->objects) without duplicating objects.\n\nWrite exactly one Scheme function definition for `kg-upsert-triple`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (let* ([s1 (kg-upsert-triple '() '(ada works_at acme))]\n       [s2 (kg-upsert-triple s1 '(ada works_at acme))]\n       [s3 (kg-upsert-triple s2 '(ada works_at babbage-labs))]\n       [s4 (kg-upsert-triple s3 '(ada founded analytical-engine))])\n  (and (equal? s1 '((ada (works_at acme))))\n       (equal? s2 '((ada (works_at acme))))\n       (equal? s3 '((ada (works_at acme babbage-labs))))\n       (equal? s4 '((ada (works_at acme babbage-labs)\n                         (founded analytical-engine)))))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "spec-to-code", "kg-upsert-triple"], "split": "eval"}
{"id": "meta_kg_ingest_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-normalize-entity`\n\n```python\ndef kg_normalize_entity(x):\n    s = x if isinstance(x, str) else str(x)\n    tokens = tokenize_simple(s)\n    if not tokens:\n        return \"unknown\"\n    return \"-\".join(tokens)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-normalize-entity"], "split": "eval"}
{"id": "meta_kg_ingest_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `kg-parse-simple-fact`\n\n```python\ndef kg_parse_simple_fact(sentence):\n    tokens = tokenize_simple(sentence)\n    for pattern, rel in [\n        ([\"works\", \"at\"], \"works at\"),\n        ([\"employed\", \"by\"], \"works at\"),\n        ([\"lives\", \"in\"], \"lives in\"),\n        ([\"is\", \"part\", \"of\"], \"part of\"),\n        ([\"part\", \"of\"], \"part of\"),\n        ([\"founded\"], \"founded\"),\n    ]:\n        i = find_subseq(tokens, pattern)\n        if i is not None:\n            subj = tokens[:i]\n            obj = tokens[i + len(pattern):]\n            if subj and obj:\n                return kg_make_triple(\" \".join(subj), rel, \" \".join(obj))\n            return None\n    return None\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "python", "kg-parse-simple-fact"], "split": "eval"}
{"id": "meta_kg_ingest_translation_016", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `kg-upsert-triples`\n\n```scheme\n(define (upsert-triples store triples)\n  (fold-left (lambda (acc t) (kg-upsert-triple acc t))\n             store\n             triples))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (kg-upsert-triples '() '((ada works_at acme) (bob located_in paris) (ada works_at acme) (ada founded analytical-engine))) '((ada (works_at acme) (founded analytical-engine)) (bob (located_in paris))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "translation", "chez", "kg-upsert-triples"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-normalize-entity` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Entity normalization must tokenize and hyphenate; simple downcasing leaves punctuation/spacing artifacts.\n\n```scheme\n(define (kg-normalize-entity x)\n  (let* ([s (if (symbol? x) (symbol->string x) x)])\n    (if (or (not s) (= (string-length s) 0))\n        'unknown\n        (string->symbol (string-downcase s)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n(eq? (kg-normalize-entity 'New_York) 'new-york)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (and\n  (eq? (kg-normalize-entity \"Ada Lovelace\") 'ada-lovelace)\n  (eq? (kg-normalize-entity 'New_York) 'new-york)\n  (eq? (kg-normalize-entity \"  \") 'unknown)\n  (eq? (kg-normalize-entity \"C3PO\") 'c3po)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-normalize-entity"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-parse-simple-fact` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Parser should support multiple relation patterns (lives in, part of, founded, employed by).\n\n```scheme\n(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                  (and x (cons x \"works at\")))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (kg-make-triple (string-join subject-tokens \" \")\n                          \"works at\"\n                          (string-join object-tokens \" \"))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n(equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (and\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n  (equal? (kg-parse-simple-fact \"Paris is part of France\") '(paris part_of france))\n  (equal? (kg-parse-simple-fact \"Linus founded Linux\") '(linus founded linux))\n  (equal? (kg-parse-simple-fact \"Bob lives in Paris\") '(bob located_in paris))\n  (not (kg-parse-simple-fact \"No relation sentence\"))\n  (not (kg-parse-simple-fact \"works at Acme\"))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-parse-simple-fact"], "split": "eval"}
{"id": "meta_kg_ingest_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kg-upsert-triples` in `lattice/meta/kg-ingest.ss`.\nKnown issue: Batch upsert must start from input store; resetting to empty drops existing KG state.\n\n```scheme\n(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   '()\n   triples))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal?\n  (kg-upsert-triples '()\n                     '((ada works_at acme)\n                       (bob located_in paris)\n                       (ada works_at acme)\n                       (ada founded analytical-engine)))\n  '((ada (works_at acme)\n         (founded analytical-engine))\n    (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "bugfix", "kg-upsert-triples"], "split": "eval"}
{"id": "meta_kg_ingest_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-normalize-entity", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize the entity text 'Ada Lovelace, PhD!' into a canonical symbol.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-normalize-entity \"Ada Lovelace, PhD!\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-normalize-entity \"Ada Lovelace, PhD!\") 'ada-lovelace-phd))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-normalize-entity", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-make-triple", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a normalized triple from raw text fields for a work relation.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-make-triple \"Ada Lovelace\" \"works at\" \"Analytical Engine\") '(ada-lovelace works_at analytical-engine)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-make-triple", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-parse-simple-fact", "prompt": "Task mode: small integration task across module primitives.\n\nParse a basic work sentence into a triple.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(kg-parse-simple-fact \"Ada works at Acme\")", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-parse-simple-fact \"Ada works at Acme\") '(ada works_at acme)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-parse-simple-fact", "direct"], "split": "eval"}
{"id": "meta_kg_ingest_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-extract-triples", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose extraction with upsert and return resulting store for three facts.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\"))) '((ada (works_at acme) (founded engine)) (bob (located_in paris))))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\")))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada founded Engine\" \"Bob lives in Paris\"))) '((ada (works_at acme) (founded engine)) (bob (located_in paris)))))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-extract-triples", "integration"], "split": "eval"}
{"id": "meta_kg_ingest_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/meta/kg-ingest.ss", "source_test": "lattice/meta/test-kg-ingest.ss", "source_function": "kg-upsert-triples", "prompt": "Task mode: small integration task across module primitives.\n\nBatch upsert parsed facts and return object list for (ada, works_at).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([store (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Babbage Labs\")))] [preds (cdr (assq 'ada store))] [row (assq 'works_at preds)]) (cdr row))", "verify_expr": "(let ()\n  (define (fold-left f init lst)\n  (let loop ([acc init] [xs lst])\n    (if (null? xs)\n        acc\n        (loop (f acc (car xs)) (cdr xs)))))\n  (define (filter pred lst)\n  (let loop ([xs lst] [acc '()])\n    (if (null? xs)\n        (reverse acc)\n        (loop (cdr xs)\n              (if (pred (car xs))\n                  (cons (car xs) acc)\n                  acc)))))\n  (define (string-join parts sep)\n  (if (null? parts)\n      \"\"\n      (let loop ([rest (cdr parts)] [acc (car parts)])\n        (if (null? rest)\n            acc\n            (loop (cdr rest) (string-append acc sep (car rest)))))))\n  (define (tokenize-simple x)\n  (let* ([s (cond [(string? x) x]\n                  [(symbol? x) (symbol->string x)]\n                  [else \"\"])]\n         [len (string-length s)])\n    (let loop ([i 0] [cur '()] [acc '()])\n      (if (= i len)\n          (let ([acc2 (if (null? cur)\n                          acc\n                          (cons (list->string (reverse cur)) acc))])\n            (reverse acc2))\n          (let ([ch (char-downcase (string-ref s i))])\n            (if (or (char-alphabetic? ch) (char-numeric? ch))\n                (loop (+ i 1) (cons ch cur) acc)\n                (if (null? cur)\n                    (loop (+ i 1) '() acc)\n                    (loop (+ i 1)\n                          '()\n                          (cons (list->string (reverse cur)) acc)))))))))\n  (define (list-prefix? prefix xs)\n  (cond\n    [(null? prefix) #t]\n    [(null? xs) #f]\n    [else\n     (and (equal? (car prefix) (car xs))\n          (list-prefix? (cdr prefix) (cdr xs)))]))\n  (define (drop n xs)\n  (if (or (<= n 0) (null? xs))\n      xs\n      (drop (- n 1) (cdr xs))))\n  (define (split-on-pattern xs pat)\n  (let loop ([rest xs] [prefix '()])\n    (cond\n      [(list-prefix? pat rest)\n       (cons (reverse prefix)\n             (drop (length pat) rest))]\n      [(null? rest) #f]\n      [else (loop (cdr rest) (cons (car rest) prefix))])))\n  (define (contains-equal? x xs)\n  (cond\n    [(null? xs) #f]\n    [(equal? x (car xs)) #t]\n    [else (contains-equal? x (cdr xs))]))\n  (define (alist-set alist key value)\n  (let loop ([xs alist] [acc '()] [done #f])\n    (cond\n      [(null? xs)\n       (let ([base (reverse acc)])\n         (if done\n             base\n             (append base (list (cons key value)))))]\n      [(and (pair? (car xs)) (eq? (caar xs) key))\n       (loop (cdr xs) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr xs) (cons (car xs) acc) done)])))\n  (define (kg-normalize-entity x)\n  (let ([tokens (tokenize-simple x)])\n    (if (null? tokens)\n        'unknown\n        (string->symbol (string-join tokens \"-\")))))\n  (define (kg-normalize-relation rel)\n  (let ([tokens (tokenize-simple rel)])\n    (cond\n      [(or (equal? tokens '(\"works\" \"at\"))\n           (equal? tokens '(\"employed\" \"by\"))\n           (equal? tokens '(\"employee\" \"of\")))\n       'works_at]\n      [(or (equal? tokens '(\"lives\" \"in\"))\n           (equal? tokens '(\"located\" \"in\"))\n           (equal? tokens '(\"in\")))\n       'located_in]\n      [(or (equal? tokens '(\"is\" \"part\" \"of\"))\n           (equal? tokens '(\"part\" \"of\"))\n           (equal? tokens '(\"member\" \"of\")))\n       'part_of]\n      [(equal? tokens '(\"founded\")) 'founded]\n      [(null? tokens) 'unknown_relation]\n      [else\n       (string->symbol\n        (string-append\n         \"rel_\"\n         (symbol->string (kg-normalize-entity (string-join tokens \"-\")))))])))\n  (define (kg-make-triple subject relation object)\n  (list (kg-normalize-entity subject)\n        (kg-normalize-relation relation)\n        (kg-normalize-entity object)))\n  (define (kg-valid-triple? triple)\n  (and (list? triple)\n       (= (length triple) 3)\n       (let ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)])\n         (and (symbol? s)\n              (symbol? p)\n              (symbol? o)\n              (not (eq? s 'unknown))\n              (not (eq? o 'unknown))\n              (not (eq? p 'unknown_relation))))))\n  (define (kg-parse-simple-fact sentence)\n  (let* ([tokens (tokenize-simple sentence)]\n         [split\n          (or (let ([x (split-on-pattern tokens '(\"works\" \"at\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"employed\" \"by\"))])\n                (and x (cons x \"works at\")))\n              (let ([x (split-on-pattern tokens '(\"lives\" \"in\"))])\n                (and x (cons x \"lives in\")))\n              (let ([x (split-on-pattern tokens '(\"is\" \"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"part\" \"of\"))])\n                (and x (cons x \"part of\")))\n              (let ([x (split-on-pattern tokens '(\"founded\"))])\n                (and x (cons x \"founded\"))))])\n    (if (not split)\n        #f\n        (let* ([parts (car split)]\n               [rel (cdr split)]\n               [subject-tokens (car parts)]\n               [object-tokens (cdr parts)])\n          (if (or (null? subject-tokens)\n                  (null? object-tokens))\n              #f\n              (kg-make-triple (string-join subject-tokens \" \")\n                              rel\n                              (string-join object-tokens \" \")))))))\n  (define (kg-extract-triples sentences)\n  (let loop ([rest sentences] [acc '()])\n    (if (null? rest)\n        (reverse acc)\n        (let ([triple (kg-parse-simple-fact (car rest))])\n          (loop (cdr rest)\n                (if (and triple\n                         (kg-valid-triple? triple)\n                         (not (contains-equal? triple acc)))\n                    (cons triple acc)\n                    acc))))))\n  (define (kg-upsert-triple store triple)\n  (if (not (kg-valid-triple? triple))\n      store\n      (let* ([s (car triple)]\n             [p (cadr triple)]\n             [o (caddr triple)]\n             [subject-row (assq s store)]\n             [preds (if subject-row (cdr subject-row) '())]\n             [pred-row (assq p preds)]\n             [objs (if pred-row (cdr pred-row) '())]\n             [objs2 (if (memq o objs) objs (append objs (list o)))]\n             [preds2 (alist-set preds p objs2)])\n        (alist-set store s preds2))))\n  (define (kg-upsert-triples store triples)\n  (fold-left\n   (lambda (acc triple)\n     (kg-upsert-triple acc triple))\n   store\n   triples))\n  (equal? (let* ([store (kg-upsert-triples '() (kg-extract-triples '(\"Ada works at Acme\" \"Ada works at Babbage Labs\")))] [preds (cdr (assq 'ada store))] [row (assq 'works_at preds)]) (cdr row)) '(acme babbage-labs)))", "tags": ["tier1", "meta", "knowledge-graph", "ingestion", "composition", "kg-upsert-triples", "query-shape"], "split": "eval"}
