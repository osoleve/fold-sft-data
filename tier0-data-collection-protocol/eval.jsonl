{"id": "collection_protocol_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-any?`\nSpec: Return #t iff at least one element satisfies predicate `pred`.\n\nWrite exactly one Scheme function definition for `coll-any?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-any?"], "split": "eval"}
{"id": "collection_protocol_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-filter-list`\nSpec: Return a list of elements that satisfy predicate `pred` preserving fold traversal order.\n\nWrite exactly one Scheme function definition for `coll-filter-list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-filter-list"], "split": "eval"}
{"id": "collection_protocol_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-partition`\nSpec: Partition into two lists `(matching, non-matching)` while preserving traversal order.\n\nWrite exactly one Scheme function definition for `coll-partition`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-partition"], "split": "eval"}
{"id": "collection_protocol_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-count`.\nReturn only the Scheme definition.\n\n```python\ndef coll_count(coll, pred):\n    acc = 0\n    for elem in coll_fold_iter(coll):\n        if pred(elem):\n            acc += 1\n    return acc\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-count"], "split": "eval"}
{"id": "collection_protocol_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-map-list`.\nReturn only the Scheme definition.\n\n```python\ndef coll_map_list(coll, fn):\n    acc = []\n    for elem in coll_fold_iter(coll):\n        acc.insert(0, fn(elem))\n    return list(reversed(acc))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-map-list"], "split": "eval"}
{"id": "collection_protocol_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-protocols`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (protocols0 type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-protocols"], "split": "eval"}
{"id": "collection_protocol_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-count` in `lattice/data/collection-protocol.ss`.\nKnown issue: The predicate must gate whether the counter increments.\n\n```scheme\n(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (+ acc 1))\n             0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-count"], "split": "eval"}
{"id": "collection_protocol_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-map-list` in `lattice/data/collection-protocol.ss`.\nKnown issue: Missing final reverse breaks expected traversal order.\n\n```scheme\n(define (coll-map-list coll fn)\n  (coll-fold coll\n             (lambda (acc elem)\n               (cons (fn elem) acc))\n             '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-map-list"], "split": "eval"}
{"id": "collection_protocol_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-protocols` in `lattice/data/collection-protocol.ss`.\nKnown issue: Canonical protocol set must include priority protocols too.\n\n```scheme\n(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-protocols"], "split": "eval"}
{"id": "collection_protocol_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: small integration task across module primitives.\n\nCount how many heap elements are strictly greater than 4.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4)))) 3)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4))))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4)))) 3))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-count", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether all values in heap '(3 1 4 1 5 9) are positive.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0))))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-all?", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: small integration task across module primitives.\n\nMap an AVL map to its sorted key list.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv)))) '(1 2 3 4 5))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv))))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv)))) '(1 2 3 4 5)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-map-list", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun coll-find on heap-empty with predicate (> x 0).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (coll-find heap-empty (lambda (x) (> x 0))) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(coll-find heap-empty (lambda (x) (> x 0)))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (equal? (coll-find heap-empty (lambda (x) (> x 0))) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-find", "edge-case"], "split": "eval"}
{"id": "collection_protocol_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether an unknown type tag reports no implemented protocols.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(null? (coll-protocols 'not-a-type))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (equal? (null? (coll-protocols 'not-a-type)) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-protocols", "edge-case"], "split": "eval"}
