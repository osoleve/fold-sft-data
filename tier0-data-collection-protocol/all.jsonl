{"id": "collection_protocol_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-count`\nSpec: Count collection elements that satisfy predicate `pred`.\n\nWrite exactly one Scheme function definition for `coll-count`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-count"], "split": "train"}
{"id": "collection_protocol_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-count coll pred)\n  ;; TODO: count elements where pred returns #t\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-count`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-count"], "split": "train"}
{"id": "collection_protocol_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-any?`\nSpec: Return #t iff at least one element satisfies predicate `pred`.\n\nWrite exactly one Scheme function definition for `coll-any?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-any?"], "split": "eval"}
{"id": "collection_protocol_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-any? coll pred)\n  ;; TODO: return #t if any element satisfies pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-any?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-any?"], "split": "train"}
{"id": "collection_protocol_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-all?`\nSpec: Return #t iff every element satisfies predicate `pred`.\n\nWrite exactly one Scheme function definition for `coll-all?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-all?"], "split": "train"}
{"id": "collection_protocol_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-all? coll pred)\n  ;; TODO: return #t only when all elements satisfy pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-all?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-all?"], "split": "train"}
{"id": "collection_protocol_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-filter-list`\nSpec: Return a list of elements that satisfy predicate `pred` preserving fold traversal order.\n\nWrite exactly one Scheme function definition for `coll-filter-list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-filter-list"], "split": "eval"}
{"id": "collection_protocol_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-filter-list coll pred)\n  ;; TODO: collect matching elements into a list preserving traversal order\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-filter-list`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-filter-list"], "split": "train"}
{"id": "collection_protocol_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-map-list`\nSpec: Map `fn` over collection elements and return a list in traversal order.\n\nWrite exactly one Scheme function definition for `coll-map-list`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-map-list"], "split": "train"}
{"id": "collection_protocol_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-map-list coll fn)\n  ;; TODO: map each element with fn and return a list in traversal order\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-map-list`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-map-list"], "split": "train"}
{"id": "collection_protocol_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-find`\nSpec: Return first element satisfying `pred`, otherwise #f.\n\nWrite exactly one Scheme function definition for `coll-find`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-find"], "split": "train"}
{"id": "collection_protocol_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-find coll pred)\n  ;; TODO: return first matching element or #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-find`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-find"], "split": "train"}
{"id": "collection_protocol_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-partition`\nSpec: Partition into two lists `(matching, non-matching)` while preserving traversal order.\n\nWrite exactly one Scheme function definition for `coll-partition`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-partition"], "split": "eval"}
{"id": "collection_protocol_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-partition coll pred)\n  ;; TODO: return (values matching-list non-matching-list)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-partition`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-partition"], "split": "train"}
{"id": "collection_protocol_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this collection protocol helper in Fold-native Scheme.\n\nTarget module: lattice/data/collection-protocol.ss\nFunction: `coll-protocols`\nSpec: Return protocol symbols implemented by `type-tag` via `type-implements?` over the canonical protocol list.\n\nWrite exactly one Scheme function definition for `coll-protocols`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "spec-to-code", "coll-protocols"], "split": "train"}
{"id": "collection_protocol_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (coll-protocols type-tag)\n  ;; TODO: filter canonical protocol symbols by (type-implements? type-tag proto)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `coll-protocols`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "skeleton-completion", "coll-protocols"], "split": "train"}
{"id": "collection_protocol_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-count`.\nReturn only the Scheme definition.\n\n```python\ndef coll_count(coll, pred):\n    acc = 0\n    for elem in coll_fold_iter(coll):\n        if pred(elem):\n            acc += 1\n    return acc\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-count"], "split": "eval"}
{"id": "collection_protocol_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-count`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (count0 coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-count"], "split": "train"}
{"id": "collection_protocol_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-any?`.\nReturn only the Scheme definition.\n\n```python\ndef coll_any(coll, pred):\n    acc = False\n    for elem in coll_fold_iter(coll):\n        acc = acc or pred(elem)\n    return True if acc else False\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-any?"], "split": "train"}
{"id": "collection_protocol_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-any?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (any0 coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t\n      #f))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-any?"], "split": "train"}
{"id": "collection_protocol_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-all?`.\nReturn only the Scheme definition.\n\n```python\ndef coll_all(coll, pred):\n    acc = True\n    for elem in coll_fold_iter(coll):\n        acc = acc and pred(elem)\n    return True if acc else False\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-all?"], "split": "train"}
{"id": "collection_protocol_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-all?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (all0 coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t\n      #f))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-all?"], "split": "train"}
{"id": "collection_protocol_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-filter-list`.\nReturn only the Scheme definition.\n\n```python\ndef coll_filter_list(coll, pred):\n    acc = []\n    for elem in coll_fold_iter(coll):\n        if pred(elem):\n            acc.insert(0, elem)\n    return list(reversed(acc))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-filter-list"], "split": "train"}
{"id": "collection_protocol_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-filter-list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (filter-list0 coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-filter-list"], "split": "train"}
{"id": "collection_protocol_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-map-list`.\nReturn only the Scheme definition.\n\n```python\ndef coll_map_list(coll, fn):\n    acc = []\n    for elem in coll_fold_iter(coll):\n        acc.insert(0, fn(elem))\n    return list(reversed(acc))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-map-list"], "split": "eval"}
{"id": "collection_protocol_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-map-list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (map-list0 coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-map-list"], "split": "train"}
{"id": "collection_protocol_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-find`.\nReturn only the Scheme definition.\n\n```python\ndef coll_find(coll, pred):\n    acc = None\n    for elem in coll_fold_iter(coll):\n        if acc is not None:\n            acc = acc\n        elif pred(elem):\n            acc = elem\n        else:\n            acc = None\n    return acc\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-find"], "split": "train"}
{"id": "collection_protocol_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-find`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (find0 coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc\n                   acc\n                   (if (pred elem) elem #f)))\n             #f))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-find"], "split": "train"}
{"id": "collection_protocol_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-partition`.\nReturn only the Scheme definition.\n\n```python\ndef coll_partition(coll, pred):\n    yes, no = [], []\n    for elem in coll_fold_iter(coll):\n        if pred(elem):\n            yes.insert(0, elem)\n        else:\n            no.insert(0, elem)\n    return (list(reversed(yes)), list(reversed(no)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-partition"], "split": "train"}
{"id": "collection_protocol_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-partition`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition0 coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-partition"], "split": "train"}
{"id": "collection_protocol_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `coll-protocols`.\nReturn only the Scheme definition.\n\n```python\ndef coll_protocols(type_tag):\n    protos = [\n        'coll-empty?', 'coll-size', 'coll-fold', 'coll-to-list',\n        'keyed-lookup', 'keyed-insert', 'keyed-delete', 'keyed-contains?',\n        'keyed-keys', 'keyed-values',\n        'spatial-nearest', 'spatial-knn', 'spatial-range', 'spatial-radius', 'spatial-contains?',\n        'prio-peek', 'prio-pop', 'prio-insert', 'prio-merge',\n    ]\n    return [p for p in protos if type_implements(type_tag, p)]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "python-to-scheme", "coll-protocols"], "split": "train"}
{"id": "collection_protocol_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `coll-protocols`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (protocols0 type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "chez-to-fold", "coll-protocols"], "split": "eval"}
{"id": "collection_protocol_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-count` in `lattice/data/collection-protocol.ss`.\nKnown issue: The predicate must gate whether the counter increments.\n\n```scheme\n(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (+ acc 1))\n             0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-count"], "split": "eval"}
{"id": "collection_protocol_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-count` in `lattice/data/collection-protocol.ss`.\nKnown issue: Fold initialization should start at 0, not 1.\n\n```scheme\n(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([heap (list->heap '(3 1 4 1 5 9 2 6))] [tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (= (coll-count heap (lambda (x) (> x 4))) 3) (= (coll-count tree (lambda (kv) (<= (car kv) 3))) 2))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-count"], "split": "train"}
{"id": "collection_protocol_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-any?` in `lattice/data/collection-protocol.ss`.\nKnown issue: Any-match logic must use OR accumulation, not AND.\n\n```scheme\n(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #f)\n      #t #f))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-any?"], "split": "train"}
{"id": "collection_protocol_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-any?` in `lattice/data/collection-protocol.ss`.\nKnown issue: Starting accumulator at #t makes non-empty and empty collections incorrectly return #t.\n\n```scheme\n(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #t)\n      #t #f))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8))))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-any? heap (lambda (x) (= x 4))) (not (coll-any? heap (lambda (x) (= x 8)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-any?"], "split": "train"}
{"id": "collection_protocol_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-all?` in `lattice/data/collection-protocol.ss`.\nKnown issue: All-match logic must use AND accumulation, not OR.\n\n```scheme\n(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #t)\n      #t #f))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-all?"], "split": "train"}
{"id": "collection_protocol_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-all?` in `lattice/data/collection-protocol.ss`.\nKnown issue: Starting accumulator at #f forces false even when all elements satisfy predicate.\n\n```scheme\n(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #f)\n      #t #f))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (let ([heap (list->heap '(3 1 4 1 5))]) (and (coll-all? heap (lambda (x) (> x 0))) (not (coll-all? heap (lambda (x) (> x 2)))) (coll-all? heap-empty (lambda (x) #f)))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-all?"], "split": "train"}
{"id": "collection_protocol_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-filter-list` in `lattice/data/collection-protocol.ss`.\nKnown issue: Missing final reverse returns elements in backward traversal order.\n\n```scheme\n(define (coll-filter-list coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (cons elem acc) acc))\n             '()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\"))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-filter-list"], "split": "train"}
{"id": "collection_protocol_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-filter-list` in `lattice/data/collection-protocol.ss`.\nKnown issue: Predicate branch is inverted; this keeps rejected elements instead of matches.\n\n```scheme\n(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) acc (cons elem acc)))\n              '())))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\"))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (define (pair-values pairs)\n  (map cdr pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\") (2 . \"two\")))] [out (coll-filter-list tree (lambda (kv) (odd? (car kv))))]) (and (equal? (pair-keys out) '(1 3 5)) (equal? (pair-values out) '(\"one\" \"three\" \"five\")))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-filter-list"], "split": "train"}
{"id": "collection_protocol_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-map-list` in `lattice/data/collection-protocol.ss`.\nKnown issue: Missing final reverse breaks expected traversal order.\n\n```scheme\n(define (coll-map-list coll fn)\n  (coll-fold coll\n             (lambda (acc elem)\n               (cons (fn elem) acc))\n             '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-map-list"], "split": "eval"}
{"id": "collection_protocol_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-map-list` in `lattice/data/collection-protocol.ss`.\nKnown issue: Mapping function must be applied to each element.\n\n```scheme\n(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons elem acc))\n              '())))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let* ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))] [keys (coll-map-list tree (lambda (kv) (car kv)))]) (equal? keys '(1 3 4))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-map-list"], "split": "train"}
{"id": "collection_protocol_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-find` in `lattice/data/collection-protocol.ss`.\nKnown issue: This returns the last matching element; function should keep the first match.\n\n```scheme\n(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) elem acc))\n             #f))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-find"], "split": "train"}
{"id": "collection_protocol_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-find` in `lattice/data/collection-protocol.ss`.\nKnown issue: On match, function should return the matching element, not #t.\n\n```scheme\n(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) #t #f)))\n             #f))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99))))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (5 . \"five\")))]) (and (equal? (coll-find tree (lambda (kv) (> (car kv) 3))) '(4 . \"four\")) (not (coll-find tree (lambda (kv) (= (car kv) 99)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-find"], "split": "train"}
{"id": "collection_protocol_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-partition` in `lattice/data/collection-protocol.ss`.\nKnown issue: Matching and non-matching buckets are swapped in the fold step.\n\n```scheme\n(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (car acc) (cons elem (cdr acc)))\n                                 (cons (cons elem (car acc)) (cdr acc))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3))))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-partition"], "split": "train"}
{"id": "collection_protocol_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-partition` in `lattice/data/collection-protocol.ss`.\nKnown issue: Final lists must be reversed to restore traversal order.\n\n```scheme\n(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (car result) (cdr result))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (and (equal? (pair-keys yes) '(2 4)) (equal? (pair-keys no) '(1 3)))))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-partition"], "split": "train"}
{"id": "collection_protocol_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-protocols` in `lattice/data/collection-protocol.ss`.\nKnown issue: `type-implements?` argument order is `(type-tag proto)`.\n\n```scheme\n(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? proto type-tag))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-protocols"], "split": "train"}
{"id": "collection_protocol_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coll-protocols` in `lattice/data/collection-protocol.ss`.\nKnown issue: Canonical protocol set must include priority protocols too.\n\n```scheme\n(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (let ([heap-protos (coll-protocols 'heap-node)] [avl-protos (coll-protocols 'avl-node)] [kdtree-protos (coll-protocols 'kdtree-node)]) (and (and (member 'coll-size heap-protos) #t) (and (member 'prio-peek heap-protos) #t) (not (member 'keyed-lookup heap-protos)) (and (member 'keyed-lookup avl-protos) #t) (and (member 'spatial-nearest kdtree-protos) #t))))", "tags": ["tier0", "data", "collection-protocol", "bugfix", "coll-protocols"], "split": "eval"}
{"id": "collection_protocol_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: small integration task across module primitives.\n\nCount how many heap elements are strictly greater than 4.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4)))) 3)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4))))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9 2 6))]) (coll-count heap (lambda (x) (> x 4)))) 3))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-count", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: small integration task across module primitives.\n\nBuild an AVL map and count entries with odd keys.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-count tree (lambda (kv) (odd? (car kv))))) 3)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-count tree (lambda (kv) (odd? (car kv)))))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-count tree (lambda (kv) (odd? (car kv))))) 3))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-count", "direct"], "split": "train"}
{"id": "collection_protocol_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether counting all elements equals coll-size for a heap.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(7 1 8 2 8))]) (= (coll-count heap (lambda (x) #t)) (coll-size heap))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([heap (list->heap '(7 1 8 2 8))]) (= (coll-count heap (lambda (x) #t)) (coll-size heap)))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (equal? (let ([heap (list->heap '(7 1 8 2 8))]) (= (coll-count heap (lambda (x) #t)) (coll-size heap))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-count", "property"], "split": "train"}
{"id": "collection_protocol_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-count", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount elements in heap-empty with a predicate that always returns #t.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (coll-count heap-empty (lambda (x) #t)) 0)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(coll-count heap-empty (lambda (x) #t))", "verify_expr": "(let ()\n  (define (coll-count coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if (pred elem) (+ acc 1) acc))\n             0))\n  (equal? (coll-count heap-empty (lambda (x) #t)) 0))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-count", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck whether heap '(3 1 4 1 5 9) contains the value 9.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-any? heap (lambda (x) (= x 9))))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-any? heap (lambda (x) (= x 9)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-any?", "direct"], "split": "train"}
{"id": "collection_protocol_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether any heap element is greater than 10.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-any? heap (lambda (x) (> x 10)))) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-any? heap (lambda (x) (> x 10))))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-any? heap (lambda (x) (> x 10)))) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-any?", "direct"], "split": "train"}
{"id": "collection_protocol_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether an AVL map has any entry with key 4.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))]) (coll-any? tree (lambda (kv) (= (car kv) 4))))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))]) (coll-any? tree (lambda (kv) (= (car kv) 4)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-any?", "integration"], "split": "train"}
{"id": "collection_protocol_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-any?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck coll-any? on avl-empty with predicate that always returns #t.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (coll-any? avl-empty (lambda (kv) #t)) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(coll-any? avl-empty (lambda (kv) #t))", "verify_expr": "(let ()\n  (define (coll-any? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (or acc (pred elem)))\n                 #f)\n      #t #f))\n  (equal? (coll-any? avl-empty (lambda (kv) #t)) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-any?", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether all values in heap '(3 1 4 1 5 9) are positive.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0))))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (> x 0)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-all?", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether all values in heap '(3 1 4 1 5 9) are even.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (even? x)))) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (even? x))))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (equal? (let ([heap (list->heap '(3 1 4 1 5 9))]) (coll-all? heap (lambda (x) (even? x)))) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-all?", "direct"], "split": "train"}
{"id": "collection_protocol_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether every key in an AVL map is <= 5.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-all? tree (lambda (kv) (<= (car kv) 5)))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-all? tree (lambda (kv) (<= (car kv) 5))))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-all? tree (lambda (kv) (<= (car kv) 5)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-all?", "integration"], "split": "train"}
{"id": "collection_protocol_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-all?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck coll-all? on empty KDTree with a predicate that always returns #f.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(coll-all? kdtree-empty (lambda (pt) #f))", "verify_expr": "(let ()\n  (define (coll-all? coll pred)\n  (if (coll-fold coll\n                 (lambda (acc elem)\n                   (and acc (pred elem)))\n                 #t)\n      #t #f))\n  (equal? (coll-all? kdtree-empty (lambda (pt) #f)) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-all?", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter AVL entries to keys greater than 2, then return the keys.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (pair-keys (coll-filter-list tree (lambda (kv) (> (car kv) 2))))) '(3 4 5))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (pair-keys (coll-filter-list tree (lambda (kv) (> (car kv) 2)))))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (pair-keys (coll-filter-list tree (lambda (kv) (> (car kv) 2))))) '(3 4 5)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-filter-list", "direct"], "split": "train"}
{"id": "collection_protocol_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter AVL entries whose value string length is 4, then return keys.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (pair-keys (coll-filter-list tree (lambda (kv) (= (string-length (cdr kv)) 4)))))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (pair-keys (coll-filter-list tree (lambda (kv) (= (string-length (cdr kv)) 4))))) '(4 5)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-filter-list", "direct"], "split": "train"}
{"id": "collection_protocol_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: compose existing APIs into one expression.\n\nFilter an AVL map with a predicate that never matches.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))]) (coll-filter-list tree (lambda (kv) #f))) '())\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))]) (coll-filter-list tree (lambda (kv) #f)))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\")))]) (coll-filter-list tree (lambda (kv) #f))) '()))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-filter-list", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-filter-list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn the number of AVL entries with keys <= 3 using coll-filter-list.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (length (coll-filter-list tree (lambda (kv) (<= (car kv) 3))))) 3)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (length (coll-filter-list tree (lambda (kv) (<= (car kv) 3)))))", "verify_expr": "(let ()\n  (define (coll-filter-list coll pred)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (if (pred elem) (cons elem acc) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (length (coll-filter-list tree (lambda (kv) (<= (car kv) 3))))) 3))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-filter-list", "integration"], "split": "train"}
{"id": "collection_protocol_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: small integration task across module primitives.\n\nMap an AVL map to its sorted key list.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv)))) '(1 2 3 4 5))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv))))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (car kv)))) '(1 2 3 4 5)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-map-list", "direct"], "split": "eval"}
{"id": "collection_protocol_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: compose existing APIs into one expression.\n\nDouble each heap element with coll-map-list and sum the resulting list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (apply + (coll-map-list (list->heap '(3 1 4)) (lambda (x) (* 2 x)))) 16)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(apply + (coll-map-list (list->heap '(3 1 4)) (lambda (x) (* 2 x))))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (equal? (apply + (coll-map-list (list->heap '(3 1 4)) (lambda (x) (* 2 x)))) 16))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-map-list", "integration"], "split": "train"}
{"id": "collection_protocol_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: small integration task across module primitives.\n\nMap over heap-empty and return the resulting list.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (coll-map-list heap-empty (lambda (x) (+ x 1))) '())\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(coll-map-list heap-empty (lambda (x) (+ x 1)))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (equal? (coll-map-list heap-empty (lambda (x) (+ x 1))) '()))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-map-list", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-map-list", "prompt": "Task mode: small integration task across module primitives.\n\nMap AVL entries to value-string lengths.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (string-length (cdr kv))))) '(3 3 5 4 4))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (string-length (cdr kv)))))", "verify_expr": "(let ()\n  (define (coll-map-list coll fn)\n  (reverse\n   (coll-fold coll\n              (lambda (acc elem)\n                (cons (fn elem) acc))\n              '())))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-map-list tree (lambda (kv) (string-length (cdr kv))))) '(3 3 5 4 4)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-map-list", "direct"], "split": "train"}
{"id": "collection_protocol_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nFind the first AVL entry whose key is greater than 2.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (> (car kv) 2)))) '(3 . \"three\"))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (> (car kv) 2))))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (> (car kv) 2)))) '(3 . \"three\")))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-find", "direct"], "split": "train"}
{"id": "collection_protocol_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAttempt to find AVL entry with key 42.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (coll-find tree (lambda (kv) (= (car kv) 42)))) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (coll-find tree (lambda (kv) (= (car kv) 42))))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\")))]) (coll-find tree (lambda (kv) (= (car kv) 42)))) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-find", "direct"], "split": "train"}
{"id": "collection_protocol_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: compose existing APIs into one expression.\n\nFind the first AVL entry whose value-string length is 4.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (= (string-length (cdr kv)) 4)))) '(4 . \"four\"))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (= (string-length (cdr kv)) 4))))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (coll-find tree (lambda (kv) (= (string-length (cdr kv)) 4)))) '(4 . \"four\")))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-find", "integration"], "split": "train"}
{"id": "collection_protocol_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-find", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun coll-find on heap-empty with predicate (> x 0).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (coll-find heap-empty (lambda (x) (> x 0))) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(coll-find heap-empty (lambda (x) (> x 0)))", "verify_expr": "(let ()\n  (define (coll-find coll pred)\n  (coll-fold coll\n             (lambda (acc elem)\n               (if acc acc\n                   (if (pred elem) elem #f)))\n             #f))\n  (equal? (coll-find heap-empty (lambda (x) (> x 0))) #f))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-find", "edge-case"], "split": "eval"}
{"id": "collection_protocol_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition AVL entries by even keys and return key lists as '(yes no).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (list (pair-keys yes) (pair-keys no))))) '((2 4) (1 3 5)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (list (pair-keys yes) (pair-keys no)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (define (pair-keys pairs)\n  (map car pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (even? (car kv))))) (lambda (yes no) (list (pair-keys yes) (pair-keys no))))) '((2 4) (1 3 5))))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-partition", "direct"], "split": "train"}
{"id": "collection_protocol_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition heap values by (> x 4) and return '(match-count non-match-count).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (coll-partition (list->heap '(3 1 4 1 5 9 2 6)) (lambda (x) (> x 4)))) (lambda (yes no) (list (length yes) (length no)))) '(3 5))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(call-with-values (lambda () (coll-partition (list->heap '(3 1 4 1 5 9 2 6)) (lambda (x) (> x 4)))) (lambda (yes no) (list (length yes) (length no))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (equal? (call-with-values (lambda () (coll-partition (list->heap '(3 1 4 1 5 9 2 6)) (lambda (x) (> x 4)))) (lambda (yes no) (list (length yes) (length no)))) '(3 5)))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-partition", "integration"], "split": "train"}
{"id": "collection_protocol_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that partitioning avl-empty yields two empty lists.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (coll-partition avl-empty (lambda (kv) #t))) (lambda (yes no) (and (null? yes) (null? no)))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (coll-partition avl-empty (lambda (kv) #t))) (lambda (yes no) (and (null? yes) (null? no))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (equal? (call-with-values (lambda () (coll-partition avl-empty (lambda (kv) #t))) (lambda (yes no) (and (null? yes) (null? no)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-partition", "edge-case"], "split": "train"}
{"id": "collection_protocol_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that partition output sizes add up to coll-size for an AVL map.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (<= (car kv) 3)))) (lambda (yes no) (= (+ (length yes) (length no)) (coll-size tree)))))", "verify_expr": "(let ()\n  (define (coll-partition coll pred)\n  (let ([result (coll-fold coll\n                           (lambda (acc elem)\n                             (if (pred elem)\n                                 (cons (cons elem (car acc)) (cdr acc))\n                                 (cons (car acc) (cons elem (cdr acc)))))\n                           (cons '() '()))])\n    (values (reverse (car result)) (reverse (cdr result)))))\n  (define (build-avl pairs)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             pairs))\n  (equal? (let ([tree (build-avl '((3 . \"three\") (1 . \"one\") (4 . \"four\") (2 . \"two\") (5 . \"five\")))]) (call-with-values (lambda () (coll-partition tree (lambda (kv) (<= (car kv) 3)))) (lambda (yes no) (= (+ (length yes) (length no)) (coll-size tree))))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-partition", "property"], "split": "train"}
{"id": "collection_protocol_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-node protocols include coll-size and prio-pop, but not keyed-lookup.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([protos (coll-protocols 'heap-node)]) (and (and (member 'coll-size protos) #t) (and (member 'prio-pop protos) #t) (not (member 'keyed-lookup protos))))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (equal? (let ([protos (coll-protocols 'heap-node)]) (and (and (member 'coll-size protos) #t) (and (member 'prio-pop protos) #t) (not (member 'keyed-lookup protos)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-protocols", "direct"], "split": "train"}
{"id": "collection_protocol_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck AVL protocol coverage: keyed-lookup + keyed-values present, spatial-nearest absent.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([protos (coll-protocols 'avl-node)]) (and (and (member 'keyed-lookup protos) #t) (and (member 'keyed-values protos) #t) (not (member 'spatial-nearest protos)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([protos (coll-protocols 'avl-node)]) (and (and (member 'keyed-lookup protos) #t) (and (member 'keyed-values protos) #t) (not (member 'spatial-nearest protos))))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (equal? (let ([protos (coll-protocols 'avl-node)]) (and (and (member 'keyed-lookup protos) #t) (and (member 'keyed-values protos) #t) (not (member 'spatial-nearest protos)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-protocols", "direct"], "split": "train"}
{"id": "collection_protocol_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck KDTree protocol coverage: spatial-range present and prio-peek absent.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([protos (coll-protocols 'kdtree-node)]) (and (and (member 'spatial-range protos) #t) (and (member 'coll-fold protos) #t) (not (member 'prio-peek protos)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([protos (coll-protocols 'kdtree-node)]) (and (and (member 'spatial-range protos) #t) (and (member 'coll-fold protos) #t) (not (member 'prio-peek protos))))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (equal? (let ([protos (coll-protocols 'kdtree-node)]) (and (and (member 'spatial-range protos) #t) (and (member 'coll-fold protos) #t) (not (member 'prio-peek protos)))) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-protocols", "integration"], "split": "train"}
{"id": "collection_protocol_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/collection-protocol.ss", "source_test": "lattice/data/test-collection-protocol.ss", "source_function": "coll-protocols", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether an unknown type tag reports no implemented protocols.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(null? (coll-protocols 'not-a-type))", "verify_expr": "(let ()\n  (define (coll-protocols type-tag)\n  (filter (lambda (proto)\n            (type-implements? type-tag proto))\n          '(coll-empty? coll-size coll-fold coll-to-list\n            keyed-lookup keyed-insert keyed-delete keyed-contains?\n            keyed-keys keyed-values\n            spatial-nearest spatial-knn spatial-range spatial-radius spatial-contains?\n            prio-peek prio-pop prio-insert prio-merge)))\n  (equal? (null? (coll-protocols 'not-a-type)) #t))", "tags": ["tier0", "data", "collection-protocol", "composition", "coll-protocols", "edge-case"], "split": "eval"}
