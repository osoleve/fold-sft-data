{"id": "avl_tree_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-empty?`\nSpec: Return #t iff tree is the avl-empty sentinel.\n\nWrite exactly one Scheme function definition for `avl-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-empty?"], "split": "train"}
{"id": "avl_tree_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-empty? tree)\n  ;; TODO: recognize the AVL empty sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-empty?"], "split": "train"}
{"id": "avl_tree_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `make-avl-node`\nSpec: Build an AVL node and recompute its cached height as 1 + max(height(left), height(right)).\n\nWrite exactly one Scheme function definition for `make-avl-node`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "make-avl-node"], "split": "eval"}
{"id": "avl_tree_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-avl-node key value left right)\n  ;; TODO: rebuild node with recomputed cached height\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-avl-node`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "make-avl-node"], "split": "train"}
{"id": "avl_tree_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `rebalance`\nSpec: Restore AVL balance for a node by applying single/double rotations when balance factor is outside [-1, 1].\n\nWrite exactly one Scheme function definition for `rebalance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "rebalance"], "split": "train"}
{"id": "avl_tree_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (rebalance tree)\n  ;; TODO: rotate for LL/LR/RR/RL imbalance cases\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `rebalance`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "rebalance"], "split": "train"}
{"id": "avl_tree_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup-by`\nSpec: Lookup key with comparator cmp; return stored value or #f when key is absent.\n\nWrite exactly one Scheme function definition for `avl-lookup-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-lookup-by"], "split": "eval"}
{"id": "avl_tree_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-lookup-by cmp key tree)\n  ;; TODO: comparator-driven BST lookup; return #f when missing\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-lookup-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-lookup-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-insert-by`\nSpec: Insert/update (key, value) under cmp and rebalance on the way back up.\n\nWrite exactly one Scheme function definition for `avl-insert-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-insert-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-insert-by cmp key value tree)\n  ;; TODO: insert/update and rebalance recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-insert-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-insert-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete-min-by`\nSpec: Delete the minimum element under cmp; raise an error on empty tree.\n\nWrite exactly one Scheme function definition for `avl-delete-min-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  ;; TODO: delete smallest key; raise error on empty tree\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete-min-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete-by`\nSpec: Delete key under cmp, using in-order successor replacement for two-child nodes and preserving AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-delete-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-delete-by"], "split": "eval"}
{"id": "avl_tree_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete-by cmp key tree)\n  ;; TODO: delete key with successor replacement + rebalancing\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-delete-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-range-by`\nSpec: Return in-order key/value pairs with lo <= key <= hi under comparator cmp.\n\nWrite exactly one Scheme function definition for `avl-range-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-range-by"], "split": "train"}
{"id": "avl_tree_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-range-by cmp lo hi tree)\n  ;; TODO: return sorted pairs in inclusive [lo, hi] range\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-range-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-range-by"], "split": "train"}
{"id": "avl_tree_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty-tree? t)\n  (eq? t 'avl-empty))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-empty?"], "split": "train"}
{"id": "avl_tree_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-avl-node`.\nReturn only the Scheme definition.\n\n```python\ndef make_avl_node(key, value, left, right):\n    return avl_node(1 + max(avl_height(left), avl_height(right)), key, value, left, right)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "make-avl-node"], "split": "train"}
{"id": "avl_tree_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-avl-node`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-node k v l r)\n  (avl-node (+ 1 (max (avl-height l) (avl-height r)))\n            k v l r))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "make-avl-node"], "split": "train"}
{"id": "avl_tree_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `rebalance`.\nReturn only the Scheme definition.\n\n```python\ndef rebalance(tree):\n    bf = avl_balance_factor(tree)\n    if bf > 1:\n        if avl_balance_factor(avl_left(tree)) < 0:\n            return rotate_right(make_avl_node(avl_key(tree), avl_value(tree), rotate_left(avl_left(tree)), avl_right(tree)))\n        return rotate_right(tree)\n    if bf < -1:\n        if avl_balance_factor(avl_right(tree)) > 0:\n            return rotate_left(make_avl_node(avl_key(tree), avl_value(tree), avl_left(tree), rotate_right(avl_right(tree))))\n        return rotate_left(tree)\n    return tree\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "rebalance"], "split": "train"}
{"id": "avl_tree_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `rebalance`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (rebalance0 t)\n  (let ((bf (avl-balance-factor t)))\n    (cond\n      ((> bf 1)\n       (if (< (avl-balance-factor (avl-left t)) 0)\n           (rotate-right (make-avl-node (avl-key t) (avl-value t)\n                                        (rotate-left (avl-left t))\n                                        (avl-right t)))\n           (rotate-right t)))\n      ((< bf -1)\n       (if (> (avl-balance-factor (avl-right t)) 0)\n           (rotate-left (make-avl-node (avl-key t) (avl-value t)\n                                       (avl-left t)\n                                       (rotate-right (avl-right t))))\n           (rotate-left t)))\n      (else t))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "rebalance"], "split": "train"}
{"id": "avl_tree_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-lookup-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_lookup_by(cmp, key, tree):\n    if avl_empty(tree):\n        return False\n    k = avl_key(tree)\n    if cmp(key, k):\n        return avl_lookup_by(cmp, key, avl_left(tree))\n    if cmp(k, key):\n        return avl_lookup_by(cmp, key, avl_right(tree))\n    return avl_value(tree)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-lookup-by"], "split": "train"}
{"id": "avl_tree_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-lookup-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookup0 cmp key t)\n  (if (avl-empty? t)\n      #f\n      (let ((k (avl-key t)))\n        (cond\n          ((cmp key k) (lookup0 cmp key (avl-left t)))\n          ((cmp k key) (lookup0 cmp key (avl-right t)))\n          (else (avl-value t))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-lookup-by"], "split": "train"}
{"id": "avl_tree_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-insert-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_insert_by(cmp, key, value, tree):\n    if avl_empty(tree):\n        return make_avl_node(key, value, avl_empty_const, avl_empty_const)\n    k = avl_key(tree)\n    v = avl_value(tree)\n    left = avl_left(tree)\n    right = avl_right(tree)\n    if cmp(key, k):\n        return rebalance(make_avl_node(k, v, avl_insert_by(cmp, key, value, left), right))\n    if cmp(k, key):\n        return rebalance(make_avl_node(k, v, left, avl_insert_by(cmp, key, value, right)))\n    return make_avl_node(key, value, left, right)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-insert-by"], "split": "eval"}
{"id": "avl_tree_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-insert-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 cmp key value t)\n  (if (avl-empty? t)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ((k (avl-key t))\n            (v (avl-value t))\n            (l (avl-left t))\n            (r (avl-right t)))\n        (cond\n          ((cmp key k) (rebalance (make-avl-node k v (insert0 cmp key value l) r)))\n          ((cmp k key) (rebalance (make-avl-node k v l (insert0 cmp key value r))))\n          (else (make-avl-node key value l r))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-insert-by"], "split": "train"}
{"id": "avl_tree_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-delete-min-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_delete_min_by(cmp, tree):\n    if avl_empty(tree):\n        raise ValueError('Cannot delete from empty tree')\n    if avl_empty(avl_left(tree)):\n        return avl_right(tree)\n    return rebalance(make_avl_node(avl_key(tree), avl_value(tree), avl_delete_min_by(cmp, avl_left(tree)), avl_right(tree)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-delete-min-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 cmp t)\n  (if (avl-empty? t)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left t))\n          (avl-right t)\n          (rebalance (make-avl-node (avl-key t)\n                                    (avl-value t)\n                                    (delete-min0 cmp (avl-left t))\n                                    (avl-right t))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-delete-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_delete_by(cmp, key, tree):\n    if avl_empty(tree):\n        return tree\n    k = avl_key(tree)\n    v = avl_value(tree)\n    left = avl_left(tree)\n    right = avl_right(tree)\n    if cmp(key, k):\n        return rebalance(make_avl_node(k, v, avl_delete_by(cmp, key, left), right))\n    if cmp(k, key):\n        return rebalance(make_avl_node(k, v, left, avl_delete_by(cmp, key, right)))\n    if avl_empty(left):\n        return right\n    if avl_empty(right):\n        return left\n    succ_key, succ_val = avl_min_node(right)\n    return rebalance(make_avl_node(succ_key, succ_val, left, avl_delete_min_by(cmp, right)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-delete-by"], "split": "train"}
{"id": "avl_tree_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-delete-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete0 cmp key t)\n  (if (avl-empty? t)\n      t\n      (let ((k (avl-key t))\n            (v (avl-value t))\n            (l (avl-left t))\n            (r (avl-right t)))\n        (cond\n          ((cmp key k) (rebalance (make-avl-node k v (delete0 cmp key l) r)))\n          ((cmp k key) (rebalance (make-avl-node k v l (delete0 cmp key r))))\n          (else\n            (cond\n              ((avl-empty? l) r)\n              ((avl-empty? r) l)\n              (else\n                (let ((succ (avl-min-node r)))\n                  (rebalance (make-avl-node (car succ)\n                                            (cdr succ)\n                                            l\n                                            (avl-delete-min-by cmp r)))))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-delete-by"], "split": "train"}
{"id": "avl_tree_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-range-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_range_by(cmp, lo, hi, tree):\n    if avl_empty(tree):\n        return []\n    k = avl_key(tree)\n    v = avl_value(tree)\n    left = avl_range_by(cmp, lo, hi, avl_left(tree)) if cmp(lo, k) else []\n    mid = [(k, v)] if (not cmp(k, lo) and not cmp(hi, k)) else []\n    right = avl_range_by(cmp, lo, hi, avl_right(tree)) if cmp(k, hi) else []\n    return left + mid + right\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-range-by"], "split": "train"}
{"id": "avl_tree_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-range-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (range0 cmp lo hi t)\n  (if (avl-empty? t)\n      '()\n      (let ((k (avl-key t))\n            (v (avl-value t)))\n        (append\n          (if (cmp lo k)\n              (range0 cmp lo hi (avl-left t))\n              '())\n          (if (and (not (cmp k lo)) (not (cmp hi k)))\n              (list (cons k v))\n              '())\n          (if (cmp k hi)\n              (range0 cmp lo hi (avl-right t))\n              '())))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-range-by"], "split": "eval"}
{"id": "avl_tree_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: The empty tree must return #t.\n\n```scheme\n(define (avl-empty? tree)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "train"}
{"id": "avl_tree_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-avl-node` in `lattice/data/avl-tree.ss`.\nKnown issue: Height must use max child height, not min.\n\n```scheme\n(define (make-avl-node key value left right)\n  (avl-node (+ 1 (min (avl-height left) (avl-height right)))\n            key value left right))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "make-avl-node"], "split": "train"}
{"id": "avl_tree_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-avl-node` in `lattice/data/avl-tree.ss`.\nKnown issue: Node height must include the current node (+1).\n\n```scheme\n(define (make-avl-node key value left right)\n  (avl-node (max (avl-height left) (avl-height right))\n            key value left right))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Node height must include the current node (+1).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "make-avl-node"], "split": "train"}
{"id": "avl_tree_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rebalance` in `lattice/data/avl-tree.ss`.\nKnown issue: Right-heavy and double-rotation cases are missing.\n\n```scheme\n(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (if (> bf 1)\n        (rotate-right tree)\n        tree)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "rebalance"], "split": "train"}
{"id": "avl_tree_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rebalance` in `lattice/data/avl-tree.ss`.\nKnown issue: Rotation direction is inverted for both imbalance directions.\n\n```scheme\n(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (rotate-left tree)]\n      [(< bf -1)\n       (rotate-right tree)]\n      [else tree])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [r (rebalance n1)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "rebalance"], "split": "train"}
{"id": "avl_tree_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-lookup-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Comparator branches should follow BST direction: key<k goes left, k<key goes right.\n\n```scheme\n(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-right tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-left tree))]\n          [else (avl-value tree)]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Comparator branches should follow BST direction: key<k goes left, k<key goes right.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-lookup-by"], "split": "train"}
{"id": "avl_tree_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-lookup-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Lookup must return the stored value, not a boolean marker.\n\n```scheme\n(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else #t]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-lookup-by"], "split": "train"}
{"id": "avl_tree_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-insert-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Recursive insert paths must rebalance before returning.\n\n```scheme\n(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (make-avl-node k v (avl-insert-by cmp key value left) right)]\n          [(cmp k key)\n           (make-avl-node k v left (avl-insert-by cmp key value right))]\n          [else\n           (make-avl-node key value left right)]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-insert-by"], "split": "eval"}
{"id": "avl_tree_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-insert-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Updating an existing key must store the new value, not keep the old one.\n\n```scheme\n(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node k v left right)]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-insert-by"], "split": "train"}
{"id": "avl_tree_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Deleting min from an empty tree should raise an error.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      avl-empty\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Deleting min from an empty tree should raise an error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: When left child is empty, the node should be replaced by its right subtree.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-left tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-min-by"], "split": "train"}
{"id": "avl_tree_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Deleting a two-child node cannot discard the left subtree.\n\n```scheme\n(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else right]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Deleting a two-child node cannot discard the left subtree.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-by"], "split": "train"}
{"id": "avl_tree_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Missing rebalance after successor replacement in two-child deletion case.\n\n```scheme\n(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (make-avl-node (car succ) (cdr succ)\n                               left\n                               (avl-delete-min-by cmp right)))])]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-by"], "split": "train"}
{"id": "avl_tree_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-range-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Range is inclusive; endpoint checks must not exclude lo/hi matches.\n\n```scheme\n(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (cmp lo k) (cmp k hi))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Range is inclusive; endpoint checks must not exclude lo/hi matches.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-range-by"], "split": "train"}
{"id": "avl_tree_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-range-by` in `lattice/data/avl-tree.ss`.\nKnown issue: The right-subtree traversal is required when k is below the high bound.\n\n```scheme\n(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         '()))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-range-by"], "split": "eval"}
{"id": "avl_tree_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether avl-empty is empty.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? avl-empty)", "verify_expr": "(equal? (avl-empty? avl-empty) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "direct"], "split": "eval"}
{"id": "avl_tree_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert one key into avl-empty and test avl-empty?.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? (avl-insert-by < 5 \"x\" avl-empty))", "verify_expr": "(equal? (avl-empty? (avl-insert-by < 5 \"x\" avl-empty)) #f)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "direct"], "split": "train"}
{"id": "avl_tree_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete the only key from a singleton AVL tree and report whether it is empty.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? (avl-delete-by < 5 (avl-insert-by < 5 \"x\" avl-empty)))", "verify_expr": "(equal? (avl-empty? (avl-delete-by < 5 (avl-insert-by < 5 \"x\" avl-empty))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "edge-case"], "split": "train"}
{"id": "avl_tree_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a tree from two pairs and report whether it is empty.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? (list->avl '((2 . \"b\") (1 . \"a\"))))", "verify_expr": "(equal? (avl-empty? (list->avl '((2 . \"b\") (1 . \"a\")))) #f)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "integration"], "split": "train"}
{"id": "avl_tree_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a singleton node with make-avl-node and return its height.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-height (make-avl-node 5 \"v\" avl-empty avl-empty))", "verify_expr": "(equal? (avl-height (make-avl-node 5 \"v\" avl-empty avl-empty)) 1)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "direct"], "split": "train"}
{"id": "avl_tree_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a node with child heights 2 and 1, then return the cached height.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [r (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" l r)]) (avl-height n))", "verify_expr": "(equal? (let* ([l (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [r (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" l r)]) (avl-height n)) 3)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "direct"], "split": "train"}
{"id": "avl_tree_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff make-avl-node preserves the provided left and right subtrees.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r)))", "verify_expr": "(equal? (let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "property"], "split": "train"}
{"id": "avl_tree_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild an uneven node with make-avl-node and return its balance factor.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 2 4 \"d\" (avl-node 1 3 \"c\" avl-empty avl-empty) avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (avl-balance-factor n))", "verify_expr": "(equal? (let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 2 4 \"d\" (avl-node 1 3 \"c\" avl-empty avl-empty) avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (avl-balance-factor n)) -1)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "property"], "split": "train"}
{"id": "avl_tree_composition_009", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: compose existing APIs into one expression.\n\nRebalance a right-heavy chain built from keys 1,2,3 and return avl-keys.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)]) (avl-keys (rebalance n1)))", "verify_expr": "(equal? (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)]) (avl-keys (rebalance n1))) '(1 2 3))", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "rotation"], "split": "eval"}
{"id": "avl_tree_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: small integration task across module primitives.\n\nRebalance a left-heavy chain built from keys 3,2,1 and return avl-keys.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([n1 (make-avl-node 1 \"a\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" n1 avl-empty)] [n3 (make-avl-node 3 \"c\" n2 avl-empty)]) (avl-keys (rebalance n3)))", "verify_expr": "(equal? (let* ([n1 (make-avl-node 1 \"a\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" n1 avl-empty)] [n3 (make-avl-node 3 \"c\" n2 avl-empty)]) (avl-keys (rebalance n3))) '(1 2 3))", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "rotation"], "split": "train"}
{"id": "avl_tree_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: small integration task across module primitives.\n\nApply rebalance to a left-right imbalance and return whether AVL/BST invariants hold.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([n2 (make-avl-node 2 \"b\" avl-empty avl-empty)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [n3 (make-avl-node 3 \"c\" n1 avl-empty)] [r (rebalance n3)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3))))", "verify_expr": "(equal? (let* ([n2 (make-avl-node 2 \"b\" avl-empty avl-empty)] [n1 (make-avl-node 1 \"a\" avl-empty n2)] [n3 (make-avl-node 3 \"c\" n1 avl-empty)] [r (rebalance n3)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "rotation", "invariant"], "split": "train"}
{"id": "avl_tree_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: compose existing APIs into one expression.\n\nCall rebalance on an already balanced tree and confirm invariants still hold.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3))))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "invariant"], "split": "train"}
{"id": "avl_tree_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLook up key 7 in a small AVL tree built from association pairs.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-lookup-by < 7 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\"))))", "verify_expr": "(equal? (avl-lookup-by < 7 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))) \"g\")", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "direct"], "split": "train"}
{"id": "avl_tree_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: small integration task across module primitives.\n\nLook up a missing key and return the lookup result.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(avl-lookup-by < 8 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\"))))", "verify_expr": "(equal? (avl-lookup-by < 8 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))) #f)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "edge-case"], "split": "train"}
{"id": "avl_tree_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a tree with descending comparator > and look up key 2 with the same comparator.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([t (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty '((5 . \"five\") (2 . \"two\") (9 . \"nine\")))]) (avl-lookup-by > 2 t))", "verify_expr": "(equal? (let ([t (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty '((5 . \"five\") (2 . \"two\") (9 . \"nine\")))]) (avl-lookup-by > 2 t)) \"two\")", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "comparator"], "split": "train"}
{"id": "avl_tree_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: small integration task across module primitives.\n\nDelete key 2 from a tree and then look it up.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([t (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\")))] [d (avl-delete-by < 2 t)]) (avl-lookup-by < 2 d))", "verify_expr": "(equal? (let* ([t (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\")))] [d (avl-delete-by < 2 t)]) (avl-lookup-by < 2 d)) #f)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "integration"], "split": "train"}
{"id": "avl_tree_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert keys 5,3,7,1,9,4 with avl-insert-by and return sorted keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-keys (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty '(5 3 7 1 9 4)))", "verify_expr": "(equal? (avl-keys (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty '(5 3 7 1 9 4))) '(1 3 4 5 7 9))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "direct"], "split": "eval"}
{"id": "avl_tree_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: small integration task across module primitives.\n\nUpdate an existing key with avl-insert-by and return (size lookup-value).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([t (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [u (avl-insert-by < 2 \"TWO\" t)]) (list (avl-size u) (avl-lookup-by < 2 u)))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [u (avl-insert-by < 2 \"TWO\" t)]) (list (avl-size u) (avl-lookup-by < 2 u))) '(3 \"TWO\"))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "update"], "split": "train"}
{"id": "avl_tree_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert keys under comparator > and return key order from avl-keys.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-keys (fold-left (lambda (acc k) (avl-insert-by > k k acc)) avl-empty '(1 4 2 5 3)))", "verify_expr": "(equal? (avl-keys (fold-left (lambda (acc k) (avl-insert-by > k k acc)) avl-empty '(1 4 2 5 3))) '(5 4 3 2 1))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "comparator"], "split": "train"}
{"id": "avl_tree_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: small integration task across module primitives.\n\nInsert keys 0..19 and return whether AVL and BST invariants plus a height bound hold.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([t (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty (iota 20))]) (and (avl-valid? t) (avl-bst-valid? t) (<= (avl-height t) 7)))", "verify_expr": "(equal? (let ([t (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty (iota 20))]) (and (avl-valid? t) (avl-bst-valid? t) (<= (avl-height t) 7))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "invariant", "stress"], "split": "train"}
{"id": "avl_tree_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete the minimum key from a tree and return remaining keys.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\")))))", "verify_expr": "(equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "direct"], "split": "train"}
{"id": "avl_tree_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff deleting min from avl-empty raises an error.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "edge-case"], "split": "train"}
{"id": "avl_tree_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete the minimum key twice and return resulting keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-keys (avl-delete-min-by < (avl-delete-min-by < (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (1 . \"a\") (4 . \"d\"))))))", "verify_expr": "(equal? (avl-keys (avl-delete-min-by < (avl-delete-min-by < (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (1 . \"a\") (4 . \"d\")))))) '(4 5 7))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "integration"], "split": "train"}
{"id": "avl_tree_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete min once and return whether size drops by one while invariants hold.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([t0 (list->avl '((8 . \"h\") (4 . \"d\") (10 . \"j\") (2 . \"b\") (6 . \"f\")))] [t1 (avl-delete-min-by < t0)]) (and (= (avl-size t1) (- (avl-size t0) 1)) (avl-valid? t1) (avl-bst-valid? t1)))", "verify_expr": "(equal? (let* ([t0 (list->avl '((8 . \"h\") (4 . \"d\") (10 . \"j\") (2 . \"b\") (6 . \"f\")))] [t1 (avl-delete-min-by < t0)]) (and (= (avl-size t1) (- (avl-size t0) 1)) (avl-valid? t1) (avl-bst-valid? t1))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "property", "invariant"], "split": "eval"}
{"id": "avl_tree_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete leaf key 1 and return remaining keys.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(avl-keys (avl-delete-by < 1 (list->avl '((3 . \"c\") (1 . \"a\") (4 . \"d\") (2 . \"b\")))))", "verify_expr": "(equal? (avl-keys (avl-delete-by < 1 (list->avl '((3 . \"c\") (1 . \"a\") (4 . \"d\") (2 . \"b\"))))) '(2 3 4))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "direct"], "split": "train"}
{"id": "avl_tree_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete root key 5 from a full tree and return remaining keys.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))]) (avl-keys (avl-delete-by < 5 t)))", "verify_expr": "(equal? (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))]) (avl-keys (avl-delete-by < 5 t))) '(2 3 4 6 7 8))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "direct", "two-children"], "split": "train"}
{"id": "avl_tree_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: small integration task across module primitives.\n\nDelete a missing key and return (size valid? bst-valid?).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [d (avl-delete-by < 99 t)]) (list (avl-size d) (avl-valid? d) (avl-bst-valid? d)))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [d (avl-delete-by < 99 t)]) (list (avl-size d) (avl-valid? d) (avl-bst-valid? d))) '(3 #t #t))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "edge-case", "invariant"], "split": "train"}
{"id": "avl_tree_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: small integration task across module primitives.\n\nDelete keys 2 then 4 and return (keys size).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([t0 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\")))] [t1 (avl-delete-by < 2 t0)] [t2 (avl-delete-by < 4 t1)]) (list (avl-keys t2) (avl-size t2)))", "verify_expr": "(equal? (let* ([t0 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\")))] [t1 (avl-delete-by < 2 t0)] [t2 (avl-delete-by < 4 t1)]) (list (avl-keys t2) (avl-size t2))) '((1 3 5) 3))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "integration"], "split": "train"}
{"id": "avl_tree_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn pairs for inclusive range [3,7].\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-range-by < 3 7 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\"))))", "verify_expr": "(equal? (avl-range-by < 3 7 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "direct"], "split": "train"}
{"id": "avl_tree_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn pairs for range [20,30] over a small tree.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-range-by < 20 30 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\"))))", "verify_expr": "(equal? (avl-range-by < 20 30 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\")))) '())", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "edge-case"], "split": "train"}
{"id": "avl_tree_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn the exact-boundary range [7,7].\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(avl-range-by < 7 7 (list->avl '((5 . \"e\") (7 . \"g\") (9 . \"i\"))))", "verify_expr": "(equal? (avl-range-by < 7 7 (list->avl '((5 . \"e\") (7 . \"g\") (9 . \"i\")))) '((7 . \"g\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "edge-case"], "split": "train"}
{"id": "avl_tree_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn keys extracted from range [4,10] over a five-element tree.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\")))))", "verify_expr": "(equal? (map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\"))))) '(4 6 10))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "integration"], "split": "eval"}
