{"id": "avl_tree_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-empty?`\nSpec: Return #t iff tree is the avl-empty sentinel.\n\nWrite exactly one Scheme function definition for `avl-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-empty?`\nSpec: Return #t iff tree is the avl-empty sentinel.\n\nWrite exactly one Scheme function definition for `avl-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-empty? tree)\n  ;; TODO: recognize the AVL empty sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-empty?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-empty? tree)\n  ;; TODO: recognize the AVL empty sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup`\nSpec: Lookup key with default `<` comparator; return value or #f.\n\nWrite exactly one Scheme function definition for `avl-lookup`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup`\nSpec: Lookup key with default `<` comparator; return value or #f.\n\nWrite exactly one Scheme function definition for `avl-lookup`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-lookup key tree)\n  ;; TODO: delegate to comparator-based lookup with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-lookup`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-lookup key tree)\n  ;; TODO: delegate to comparator-based lookup with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-lookup`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty-tree? t)\n  (eq? t 'avl-empty))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty-tree? t)\n  (eq? t 'avl-empty))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-lookup`.\nReturn only the Scheme definition.\n\n```python\ndef avl_lookup(key, tree):\n    return avl_lookup_by(lt, key, tree)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-lookup`.\nReturn only the Scheme definition.\n\n```python\ndef avl_lookup(key, tree):\n    return avl_lookup_by(lt, key, tree)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-lookup`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookup-default k t)\n  (avl-lookup-by < k t))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-lookup`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookup-default k t)\n  (avl-lookup-by < k t))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: The empty tree must return #t.\n\n```scheme\n(define (avl-empty? tree)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: The empty tree must return #t.\n\n```scheme\n(define (avl-empty? tree)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-lookup` in `lattice/data/avl-tree.ss`.\nKnown issue: Default lookup must use `<` ordering to match the tree construction convention.\n\n```scheme\n(define (avl-lookup key tree)\n  (avl-lookup-by > key tree))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-lookup` in `lattice/data/avl-tree.ss`.\nKnown issue: Default lookup must use `<` ordering to match the tree construction convention.\n\n```scheme\n(define (avl-lookup key tree)\n  (avl-lookup-by > key tree))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Default lookup must use `<` ordering to match the tree construction convention.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Return whether avl-empty is empty.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether avl-empty is empty.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? avl-empty)", "verify_expr": "(equal? (avl-empty? avl-empty) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "direct"], "split": "eval"}
{"id": "avl_tree_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt_body": "Return #t iff make-avl-node preserves the provided left and right subtrees.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff make-avl-node preserves the provided left and right subtrees.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r)))", "verify_expr": "(equal? (let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "property"], "split": "eval"}
{"id": "avl_tree_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt_body": "Call rebalance on an already balanced tree and confirm invariants still hold.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCall rebalance on an already balanced tree and confirm invariants still hold.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3))))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "invariant"], "split": "eval"}
{"id": "avl_tree_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt_body": "Delete key 2 from a tree and then look it up.", "prompt": "Task mode: small integration task across module primitives.\n\nDelete key 2 from a tree and then look it up.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([t (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\")))] [d (avl-delete-by < 2 t)]) (avl-lookup-by < 2 d))", "verify_expr": "(equal? (let* ([t (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\")))] [d (avl-delete-by < 2 t)]) (avl-lookup-by < 2 d)) #f)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "integration"], "split": "eval"}
{"id": "avl_tree_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt_body": "Update an existing key with avl-insert-by and return (size lookup-value).", "prompt": "Task mode: small integration task across module primitives.\n\nUpdate an existing key with avl-insert-by and return (size lookup-value).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([t (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [u (avl-insert-by < 2 \"TWO\" t)]) (list (avl-size u) (avl-lookup-by < 2 u)))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [u (avl-insert-by < 2 \"TWO\" t)]) (list (avl-size u) (avl-lookup-by < 2 u))) '(3 \"TWO\"))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "update"], "split": "eval"}
{"id": "avl_tree_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Delete the minimum key twice and return resulting keys.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete the minimum key twice and return resulting keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-keys (avl-delete-min-by < (avl-delete-min-by < (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (1 . \"a\") (4 . \"d\"))))))", "verify_expr": "(equal? (avl-keys (avl-delete-min-by < (avl-delete-min-by < (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (1 . \"a\") (4 . \"d\")))))) '(4 5 7))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "integration"], "split": "eval"}
{"id": "avl_tree_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt_body": "Delete keys 2 then 4 and return (keys size).", "prompt": "Task mode: small integration task across module primitives.\n\nDelete keys 2 then 4 and return (keys size).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([t0 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\")))] [t1 (avl-delete-by < 2 t0)] [t2 (avl-delete-by < 4 t1)]) (list (avl-keys t2) (avl-size t2)))", "verify_expr": "(equal? (let* ([t0 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\")))] [t1 (avl-delete-by < 2 t0)] [t2 (avl-delete-by < 4 t1)]) (list (avl-keys t2) (avl-size t2))) '((1 3 5) 3))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "integration"], "split": "eval"}
{"id": "avl_tree_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt_body": "Return pairs for inclusive range [3,7].", "prompt": "Task mode: small integration task across module primitives.\n\nReturn pairs for inclusive range [3,7].\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-range-by < 3 7 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\"))))", "verify_expr": "(equal? (avl-range-by < 3 7 (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "direct"], "split": "eval"}
{"id": "avl_tree_composition_034", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-contains?", "prompt_body": "Check present and missing keys with avl-contains?.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck present and missing keys with avl-contains?.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))]) (and (avl-contains? 2 t) (not (avl-contains? 9 t))))", "verify_expr": "(equal? (let ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))]) (and (avl-contains? 2 t) (not (avl-contains? 9 t)))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-contains?", "property"], "split": "eval"}
{"id": "avl_tree_composition_035", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert", "prompt_body": "Insert via default wrapper and return sorted keys.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert via default wrapper and return sorted keys.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-keys (avl-insert 4 \"d\" (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))))", "verify_expr": "(equal? (avl-keys (avl-insert 4 \"d\" (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\"))))) '(1 2 3 4))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert", "direct"], "split": "eval"}
{"id": "avl_tree_composition_036", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete", "prompt_body": "Delete key 3 using default wrapper and return keys.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete key 3 using default wrapper and return keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-keys (avl-delete 3 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\")))))", "verify_expr": "(equal? (avl-keys (avl-delete 3 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\"))))) '(1 2 4))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete", "direct"], "split": "eval"}
{"id": "avl_tree_composition_037", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range", "prompt_body": "Run default range wrapper for [2,4].", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun default range wrapper for [2,4].\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-range 2 4 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\"))))", "verify_expr": "(equal? (avl-range 2 4 (list->avl '((1 . \"a\") (2 . \"b\") (3 . \"c\") (4 . \"d\") (5 . \"e\")))) '((2 . \"b\") (3 . \"c\") (4 . \"d\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range", "direct"], "split": "eval"}
{"id": "avl_tree_composition_038", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-keys-between", "prompt_body": "Return keys between 2 and 6 inclusive.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn keys between 2 and 6 inclusive.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(avl-keys-between 2 6 (list->avl '((1 . \"a\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\"))))", "verify_expr": "(equal? (avl-keys-between 2 6 (list->avl '((1 . \"a\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))) '(2 4 6))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-keys-between", "direct"], "split": "eval"}
{"id": "avl_tree_composition_039", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-less-than", "prompt_body": "Return pairs with keys strictly less than 5.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn pairs with keys strictly less than 5.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-less-than 5 (list->avl '((2 . \"b\") (5 . \"e\") (1 . \"a\") (7 . \"g\") (4 . \"d\"))))", "verify_expr": "(equal? (avl-less-than 5 (list->avl '((2 . \"b\") (5 . \"e\") (1 . \"a\") (7 . \"g\") (4 . \"d\")))) '((1 . \"a\") (2 . \"b\") (4 . \"d\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-less-than", "direct"], "split": "eval"}
{"id": "avl_tree_composition_040", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-greater-than", "prompt_body": "Return pairs with keys strictly greater than 5.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn pairs with keys strictly greater than 5.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-greater-than 5 (list->avl '((2 . \"b\") (5 . \"e\") (1 . \"a\") (7 . \"g\") (6 . \"f\"))))", "verify_expr": "(equal? (avl-greater-than 5 (list->avl '((2 . \"b\") (5 . \"e\") (1 . \"a\") (7 . \"g\") (6 . \"f\")))) '((6 . \"f\") (7 . \"g\")))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-greater-than", "direct"], "split": "eval"}
