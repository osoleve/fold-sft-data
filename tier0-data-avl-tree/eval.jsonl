{"id": "avl_tree_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `make-avl-node`\nSpec: Build an AVL node and recompute its cached height as 1 + max(height(left), height(right)).\n\nWrite exactly one Scheme function definition for `make-avl-node`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))", "verify_expr": "(let ()\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (let* ([left (avl-node 2 2 \"b\" (avl-node 1 1 \"a\" avl-empty avl-empty) avl-empty)] [right (avl-node 1 4 \"d\" avl-empty avl-empty)] [n (make-avl-node 3 \"c\" left right)]) (and (= (avl-height n) 3) (= (avl-key n) 3) (equal? (avl-value n) \"c\") (equal? (avl-left n) left) (equal? (avl-right n) right))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "make-avl-node"], "split": "eval"}
{"id": "avl_tree_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup-by`\nSpec: Lookup key with comparator cmp; return stored value or #f when key is absent.\n\nWrite exactly one Scheme function definition for `avl-lookup-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (let* ([pairs '((5 . \"five\") (2 . \"two\") (9 . \"nine\"))] [asc (fold-left (lambda (acc kv) (avl-insert-by < (car kv) (cdr kv) acc)) avl-empty pairs)] [desc (fold-left (lambda (acc kv) (avl-insert-by > (car kv) (cdr kv) acc)) avl-empty pairs)]) (and (equal? (avl-lookup-by < 9 asc) \"nine\") (equal? (avl-lookup-by < 8 asc) #f) (equal? (avl-lookup-by > 2 desc) \"two\"))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-lookup-by"], "split": "eval"}
{"id": "avl_tree_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete-by`\nSpec: Delete key under cmp, using in-order successor replacement for two-child nodes and preserving AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-delete-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))] [d1 (avl-delete-by < 7 t)] [d2 (avl-delete-by < 5 d1)] [d3 (avl-delete-by < 42 d2)]) (and (avl-valid? d2) (avl-bst-valid? d2) (not (avl-contains-by? < 7 d1)) (not (avl-contains-by? < 5 d2)) (= (avl-size d2) 5) (= (avl-size d3) 5) (equal? (avl-keys d2) '(2 3 4 6 8)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-delete-by"], "split": "eval"}
{"id": "avl_tree_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-insert-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_insert_by(cmp, key, value, tree):\n    if avl_empty(tree):\n        return make_avl_node(key, value, avl_empty_const, avl_empty_const)\n    k = avl_key(tree)\n    v = avl_value(tree)\n    left = avl_left(tree)\n    right = avl_right(tree)\n    if cmp(key, k):\n        return rebalance(make_avl_node(k, v, avl_insert_by(cmp, key, value, left), right))\n    if cmp(k, key):\n        return rebalance(make_avl_node(k, v, left, avl_insert_by(cmp, key, value, right)))\n    return make_avl_node(key, value, left, right)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-insert-by"], "split": "eval"}
{"id": "avl_tree_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-range-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (range0 cmp lo hi t)\n  (if (avl-empty? t)\n      '()\n      (let ((k (avl-key t))\n            (v (avl-value t)))\n        (append\n          (if (cmp lo k)\n              (range0 cmp lo hi (avl-left t))\n              '())\n          (if (and (not (cmp k lo)) (not (cmp hi k)))\n              (list (cons k v))\n              '())\n          (if (cmp k hi)\n              (range0 cmp lo hi (avl-right t))\n              '())))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-range-by"], "split": "eval"}
{"id": "avl_tree_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-insert-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Recursive insert paths must rebalance before returning.\n\n```scheme\n(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (make-avl-node k v (avl-insert-by cmp key value left) right)]\n          [(cmp k key)\n           (make-avl-node k v left (avl-insert-by cmp key value right))]\n          [else\n           (make-avl-node key value left right)]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (let* ([t0 (fold-left (lambda (acc k) (avl-insert-by < k (* k 10) acc)) avl-empty '(5 3 7))] [t1 (avl-insert-by < 6 60 t0)] [t2 (avl-insert-by < 7 700 t1)]) (and (avl-valid? t2) (avl-bst-valid? t2) (= (avl-size t2) 4) (= (avl-lookup-by < 7 t2) 700) (equal? (avl-keys t2) '(3 5 6 7)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-insert-by"], "split": "eval"}
{"id": "avl_tree_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-range-by` in `lattice/data/avl-tree.ss`.\nKnown issue: The right-subtree traversal is required when k is below the high bound.\n\n```scheme\n(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         '()))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (let* ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))] [r1 (avl-range-by < 3 7 t)] [r2 (avl-range-by < 8 10 t)] [r3 (avl-range-by < 20 30 t)]) (and (equal? r1 '((3 . \"c\") (5 . \"e\") (7 . \"g\"))) (equal? r2 '((9 . \"i\"))) (equal? r3 '()))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-range-by"], "split": "eval"}
{"id": "avl_tree_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether avl-empty is empty.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-empty? avl-empty)", "verify_expr": "(equal? (avl-empty? avl-empty) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-empty?", "direct"], "split": "eval"}
{"id": "avl_tree_composition_009", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt": "Task mode: compose existing APIs into one expression.\n\nRebalance a right-heavy chain built from keys 1,2,3 and return avl-keys.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)]) (avl-keys (rebalance n1)))", "verify_expr": "(equal? (let* ([n3 (make-avl-node 3 \"c\" avl-empty avl-empty)] [n2 (make-avl-node 2 \"b\" avl-empty n3)] [n1 (make-avl-node 1 \"a\" avl-empty n2)]) (avl-keys (rebalance n1))) '(1 2 3))", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "rotation"], "split": "eval"}
{"id": "avl_tree_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert keys 5,3,7,1,9,4 with avl-insert-by and return sorted keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(avl-keys (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty '(5 3 7 1 9 4)))", "verify_expr": "(equal? (avl-keys (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty '(5 3 7 1 9 4))) '(1 3 4 5 7 9))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "direct"], "split": "eval"}
{"id": "avl_tree_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete min once and return whether size drops by one while invariants hold.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([t0 (list->avl '((8 . \"h\") (4 . \"d\") (10 . \"j\") (2 . \"b\") (6 . \"f\")))] [t1 (avl-delete-min-by < t0)]) (and (= (avl-size t1) (- (avl-size t0) 1)) (avl-valid? t1) (avl-bst-valid? t1)))", "verify_expr": "(equal? (let* ([t0 (list->avl '((8 . \"h\") (4 . \"d\") (10 . \"j\") (2 . \"b\") (6 . \"f\")))] [t1 (avl-delete-min-by < t0)]) (and (= (avl-size t1) (- (avl-size t0) 1)) (avl-valid? t1) (avl-bst-valid? t1))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-min-by", "property", "invariant"], "split": "eval"}
{"id": "avl_tree_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn keys extracted from range [4,10] over a five-element tree.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\")))))", "verify_expr": "(equal? (map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\"))))) '(4 6 10))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "integration"], "split": "eval"}
