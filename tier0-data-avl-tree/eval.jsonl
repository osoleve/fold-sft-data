{"id": "avl_tree_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-empty?`\nSpec: Return #t iff tree is the avl-empty sentinel.\n\nWrite exactly one Scheme function definition for `avl-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-empty?`\nSpec: Return #t iff tree is the avl-empty sentinel.\n\nWrite exactly one Scheme function definition for `avl-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-empty? tree)\n  ;; TODO: recognize the AVL empty sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-empty?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-empty? tree)\n  ;; TODO: recognize the AVL empty sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup`\nSpec: Lookup key with default `<` comparator; return value or #f.\n\nWrite exactly one Scheme function definition for `avl-lookup`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-lookup`\nSpec: Lookup key with default `<` comparator; return value or #f.\n\nWrite exactly one Scheme function definition for `avl-lookup`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-lookup key tree)\n  ;; TODO: delegate to comparator-based lookup with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-lookup`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-lookup key tree)\n  ;; TODO: delegate to comparator-based lookup with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-lookup`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-lookup key tree)\n  (avl-lookup-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (equal? (avl-lookup 7 t) \"g\") (equal? (avl-lookup 8 t) #f))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-lookup"], "split": "eval"}
{"id": "avl_tree_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-contains?", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-contains?`\nSpec: Return whether key is present using default `<` comparator.\n\nWrite exactly one Scheme function definition for `avl-contains?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-contains?`\nSpec: Return whether key is present using default `<` comparator.\n\nWrite exactly one Scheme function definition for `avl-contains?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (avl-contains? 3 t) (not (avl-contains? 42 t)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-contains? key tree)\n  (avl-contains-by? < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-contains? key tree)\n  (avl-contains-by? < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (avl-contains? 3 t) (not (avl-contains? 42 t)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-contains?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-contains?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-contains? key tree)\n  ;; TODO: delegate to comparator-based contains? with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-contains?`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-contains? key tree)\n  ;; TODO: delegate to comparator-based contains? with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-contains?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (avl-contains? 3 t) (not (avl-contains? 42 t)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-contains? key tree)\n  (avl-contains-by? < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-contains-by? cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-contains-by? cmp key (avl-left tree))]\n          [(cmp k key) (avl-contains-by? cmp key (avl-right tree))]\n          [else #t]))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-contains? key tree)\n  (avl-contains-by? < key tree))\n  (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))]) (and (avl-contains? 3 t) (not (avl-contains? 42 t)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-contains?"], "split": "eval"}
{"id": "avl_tree_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-insert`\nSpec: Insert/update with default `<` comparator and preserve AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-insert`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-insert`\nSpec: Insert/update with default `<` comparator and preserve AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-insert`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([t0 (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [t1 (avl-insert 2 \"TWO\" t0)] [t2 (avl-insert 4 \"four\" t1)]) (and (= (avl-size t2) 4) (equal? (avl-lookup 2 t2) \"TWO\") (equal? (avl-keys t2) '(1 2 3 4)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-insert key value tree)\n  (avl-insert-by < key value tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (let* ([t0 (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [t1 (avl-insert 2 \"TWO\" t0)] [t2 (avl-insert 4 \"four\" t1)]) (and (= (avl-size t2) 4) (equal? (avl-lookup 2 t2) \"TWO\") (equal? (avl-keys t2) '(1 2 3 4)))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-insert"], "split": "eval"}
{"id": "avl_tree_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-insert key value tree)\n  ;; TODO: delegate to comparator-based insert with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-insert`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-insert key value tree)\n  ;; TODO: delegate to comparator-based insert with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-insert`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([t0 (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [t1 (avl-insert 2 \"TWO\" t0)] [t2 (avl-insert 4 \"four\" t1)]) (and (= (avl-size t2) 4) (equal? (avl-lookup 2 t2) \"TWO\") (equal? (avl-keys t2) '(1 2 3 4)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-insert key value tree)\n  (avl-insert-by < key value tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-lookup-by cmp key tree)\n  (if (avl-empty? tree)\n      #f\n      (let ([k (avl-key tree)])\n        (cond\n          [(cmp key k) (avl-lookup-by cmp key (avl-left tree))]\n          [(cmp k key) (avl-lookup-by cmp key (avl-right tree))]\n          [else (avl-value tree)]))))\n  (define (avl-lookup key tree)\n  (avl-lookup-by < key tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-size tree)\n  (if (avl-empty? tree)\n      0\n      (+ 1 (avl-size (avl-left tree)) (avl-size (avl-right tree)))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (let* ([t0 (list->avl '((2 . \"two\") (1 . \"one\") (3 . \"three\")))] [t1 (avl-insert 2 \"TWO\" t0)] [t2 (avl-insert 4 \"four\" t1)]) (and (= (avl-size t2) 4) (equal? (avl-lookup 2 t2) \"TWO\") (equal? (avl-keys t2) '(1 2 3 4)))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-insert"], "split": "eval"}
{"id": "avl_tree_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete-min-by`\nSpec: Delete the minimum element under cmp; raise an error on empty tree.\n\nWrite exactly one Scheme function definition for `avl-delete-min-by`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete-min-by`\nSpec: Delete the minimum element under cmp; raise an error on empty tree.\n\nWrite exactly one Scheme function definition for `avl-delete-min-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  ;; TODO: delete smallest key; raise error on empty tree\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete-min-by`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  ;; TODO: delete smallest key; raise error on empty tree\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete-min-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete`\nSpec: Delete key using default `<` comparator while preserving AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-delete`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-delete`\nSpec: Delete key using default `<` comparator while preserving AVL invariants.\n\nWrite exactly one Scheme function definition for `avl-delete`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\")))] [d (avl-delete 3 t)] [d2 (avl-delete 99 d)]) (and (equal? (avl-keys d) '(2 5 7)) (equal? (avl-keys d2) '(2 5 7)) (avl-valid? d2) (avl-bst-valid? d2))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-delete key tree)\n  (avl-delete-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-delete key tree)\n  (avl-delete-by < key tree))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\")))] [d (avl-delete 3 t)] [d2 (avl-delete 99 d)]) (and (equal? (avl-keys d) '(2 5 7)) (equal? (avl-keys d2) '(2 5 7)) (avl-valid? d2) (avl-bst-valid? d2))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-delete"], "split": "eval"}
{"id": "avl_tree_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete key tree)\n  ;; TODO: delegate to comparator-based delete with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-delete key tree)\n  ;; TODO: delegate to comparator-based delete with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-delete`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\")))] [d (avl-delete 3 t)] [d2 (avl-delete 99 d)]) (and (equal? (avl-keys d) '(2 5 7)) (equal? (avl-keys d2) '(2 5 7)) (avl-valid? d2) (avl-bst-valid? d2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-delete key tree)\n  (avl-delete-by < key tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (define (avl-min-node tree)\n  (if (avl-empty? tree)\n      (error 'avl-min-node \"Cannot find min in empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (cons (avl-key tree) (avl-value tree))\n          (avl-min-node (avl-left tree)))))\n  (define (avl-delete-by cmp key tree)\n  (if (avl-empty? tree)\n      tree\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-delete-by cmp key left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-delete-by cmp key right)))]\n          [else\n           (cond\n             [(avl-empty? left) right]\n             [(avl-empty? right) left]\n             [else\n              (let ([succ (avl-min-node right)])\n                (rebalance (make-avl-node (car succ) (cdr succ)\n                                          left\n                                          (avl-delete-min-by cmp right))))])]))))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-valid? tree)\n  (if (avl-empty? tree)\n      #t\n      (let ([bf (avl-balance-factor tree)])\n        (and (>= bf -1)\n             (<= bf 1)\n             (avl-valid? (avl-left tree))\n             (avl-valid? (avl-right tree))))))\n  (define (avl-bst-valid-range? tree lo hi)\n  (if (avl-empty? tree)\n      #t\n      (let ([k (avl-key tree)])\n        (and (or (not lo) (< lo k))\n             (or (not hi) (< k hi))\n             (avl-bst-valid-range? (avl-left tree) lo k)\n             (avl-bst-valid-range? (avl-right tree) k hi)))))\n  (define (avl-bst-valid? tree)\n  (avl-bst-valid-range? tree #f #f))\n  (define (avl-delete key tree)\n  (avl-delete-by < key tree))\n  (let* ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\")))] [d (avl-delete 3 t)] [d2 (avl-delete 99 d)]) (and (equal? (avl-keys d) '(2 5 7)) (equal? (avl-keys d2) '(2 5 7)) (avl-valid? d2) (avl-bst-valid? d2))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-delete"], "split": "eval"}
{"id": "avl_tree_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-range`\nSpec: Return inclusive range pairs using default `<` comparator.\n\nWrite exactly one Scheme function definition for `avl-range`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-range`\nSpec: Return inclusive range pairs using default `<` comparator.\n\nWrite exactly one Scheme function definition for `avl-range`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-range 3 7 t) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-range 3 7 t) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-range"], "split": "eval"}
{"id": "avl_tree_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-range lo hi tree)\n  ;; TODO: delegate to comparator-based range with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-range`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-range lo hi tree)\n  ;; TODO: delegate to comparator-based range with <\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-range`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-range 3 7 t) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-range 3 7 t) '((3 . \"c\") (5 . \"e\") (7 . \"g\")))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-range"], "split": "eval"}
{"id": "avl_tree_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-keys-between", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-keys-between`\nSpec: Return all keys in inclusive [lo, hi].\n\nWrite exactly one Scheme function definition for `avl-keys-between`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-keys-between`\nSpec: Return all keys in inclusive [lo, hi].\n\nWrite exactly one Scheme function definition for `avl-keys-between`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-keys-between 3 7 t) '(3 5 7))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-keys-between lo hi tree)\n  (map car (avl-range lo hi tree)))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-keys-between lo hi tree)\n  (map car (avl-range lo hi tree)))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-keys-between 3 7 t) '(3 5 7))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-keys-between"], "split": "eval"}
{"id": "avl_tree_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-keys-between", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-keys-between lo hi tree)\n  ;; TODO: map car over avl-range result\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-keys-between`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-keys-between lo hi tree)\n  ;; TODO: map car over avl-range result\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-keys-between`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-keys-between 3 7 t) '(3 5 7))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-keys-between lo hi tree)\n  (map car (avl-range lo hi tree)))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-range-by cmp lo hi tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)])\n        (append\n         (if (cmp lo k)\n             (avl-range-by cmp lo hi (avl-left tree))\n             '())\n         (if (and (not (cmp k lo)) (not (cmp hi k)))\n             (list (cons k v))\n             '())\n         (if (cmp k hi)\n             (avl-range-by cmp lo hi (avl-right tree))\n             '())))))\n  (define (avl-range lo hi tree)\n  (avl-range-by < lo hi tree))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-keys-between lo hi tree)\n  (map car (avl-range lo hi tree)))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\") (9 . \"i\")))]) (equal? (avl-keys-between 3 7 t) '(3 5 7))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-keys-between"], "split": "eval"}
{"id": "avl_tree_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-less-than", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-less-than`\nSpec: Return all key/value pairs with key < bound, in key order.\n\nWrite exactly one Scheme function definition for `avl-less-than`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-less-than`\nSpec: Return all key/value pairs with key < bound, in key order.\n\nWrite exactly one Scheme function definition for `avl-less-than`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-less-than 5 t) '((1 . \"a\") (3 . \"c\")))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (avl-less-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (< k bound)\n            (append (avl-less-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-less-than bound (avl-right tree)))\n            (avl-less-than bound (avl-left tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-less-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (< k bound)\n            (append (avl-less-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-less-than bound (avl-right tree)))\n            (avl-less-than bound (avl-left tree))))))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-less-than 5 t) '((1 . \"a\") (3 . \"c\")))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-less-than"], "split": "eval"}
{"id": "avl_tree_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-less-than", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-less-than bound tree)\n  ;; TODO: return in-order pairs where key < bound\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-less-than`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-less-than bound tree)\n  ;; TODO: return in-order pairs where key < bound\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-less-than`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-less-than 5 t) '((1 . \"a\") (3 . \"c\")))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (avl-less-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (< k bound)\n            (append (avl-less-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-less-than bound (avl-right tree)))\n            (avl-less-than bound (avl-left tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-less-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (< k bound)\n            (append (avl-less-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-less-than bound (avl-right tree)))\n            (avl-less-than bound (avl-left tree))))))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-less-than 5 t) '((1 . \"a\") (3 . \"c\")))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-less-than"], "split": "eval"}
{"id": "avl_tree_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-greater-than", "prompt_body": "You are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-greater-than`\nSpec: Return all key/value pairs with key > bound, in key order.\n\nWrite exactly one Scheme function definition for `avl-greater-than`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 AVL tree code in Fold-native Scheme.\n\nTarget module: lattice/data/avl-tree.ss\nFunction: `avl-greater-than`\nSpec: Return all key/value pairs with key > bound, in key order.\n\nWrite exactly one Scheme function definition for `avl-greater-than`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-greater-than 3 t) '((5 . \"e\") (7 . \"g\")))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-greater-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (> k bound)\n            (append (avl-greater-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-greater-than bound (avl-right tree)))\n            (avl-greater-than bound (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-greater-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (> k bound)\n            (append (avl-greater-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-greater-than bound (avl-right tree)))\n            (avl-greater-than bound (avl-right tree))))))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-greater-than 3 t) '((5 . \"e\") (7 . \"g\")))))", "tags": ["tier0", "data", "avl-tree", "spec-to-code", "avl-greater-than"], "split": "eval"}
{"id": "avl_tree_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-greater-than", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-greater-than bound tree)\n  ;; TODO: return in-order pairs where key > bound\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-greater-than`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (avl-greater-than bound tree)\n  ;; TODO: return in-order pairs where key > bound\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `avl-greater-than`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-greater-than 3 t) '((5 . \"e\") (7 . \"g\")))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (avl-greater-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (> k bound)\n            (append (avl-greater-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-greater-than bound (avl-right tree)))\n            (avl-greater-than bound (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl-greater-than bound tree)\n  (if (avl-empty? tree)\n      '()\n      (let ([k (avl-key tree)])\n        (if (> k bound)\n            (append (avl-greater-than bound (avl-left tree))\n                    (list (cons k (avl-value tree)))\n                    (avl-greater-than bound (avl-right tree)))\n            (avl-greater-than bound (avl-right tree))))))\n  (let ([t (list->avl '((1 . \"a\") (3 . \"c\") (5 . \"e\") (7 . \"g\")))]) (equal? (avl-greater-than 3 t) '((5 . \"e\") (7 . \"g\")))))", "tags": ["tier0", "data", "avl-tree", "skeleton-completion", "avl-greater-than"], "split": "eval"}
{"id": "avl_tree_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef avl_empty(tree):\n    return tree == 'avl-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty-tree? t)\n  (eq? t 'avl-empty))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty-tree? t)\n  (eq? t 'avl-empty))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (avl-empty? avl-empty))\n(let () (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-delete-min-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_delete_min_by(cmp, tree):\n    if avl_empty(tree):\n        raise ValueError('Cannot delete from empty tree')\n    if avl_empty(avl_left(tree)):\n        return avl_right(tree)\n    return rebalance(make_avl_node(avl_key(tree), avl_value(tree), avl_delete_min_by(cmp, avl_left(tree)), avl_right(tree)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `avl-delete-min-by`.\nReturn only the Scheme definition.\n\n```python\ndef avl_delete_min_by(cmp, tree):\n    if avl_empty(tree):\n        raise ValueError('Cannot delete from empty tree')\n    if avl_empty(avl_left(tree)):\n        return avl_right(tree)\n    return rebalance(make_avl_node(avl_key(tree), avl_value(tree), avl_delete_min_by(cmp, avl_left(tree)), avl_right(tree)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "python-to-scheme", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-delete-min-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 cmp t)\n  (if (avl-empty? t)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left t))\n          (avl-right t)\n          (rebalance (make-avl-node (avl-key t)\n                                    (avl-value t)\n                                    (delete-min0 cmp (avl-left t))\n                                    (avl-right t))))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `avl-delete-min-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 cmp t)\n  (if (avl-empty? t)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left t))\n          (avl-right t)\n          (rebalance (make-avl-node (avl-key t)\n                                    (avl-value t)\n                                    (delete-min0 cmp (avl-left t))\n                                    (avl-right t))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "chez-to-fold", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: AVL emptiness uses the avl-empty sentinel, not the null list.\n\n```scheme\n(define (avl-empty? tree)\n  (null? tree))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: The empty tree must return #t.\n\n```scheme\n(define (avl-empty? tree)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-empty?` in `lattice/data/avl-tree.ss`.\nKnown issue: The empty tree must return #t.\n\n```scheme\n(define (avl-empty? tree)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-empty? tree)\n  (eq? tree 'avl-empty))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (and (avl-empty? avl-empty) (not (avl-empty? (avl-node 1 5 \"x\" avl-empty avl-empty)))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-empty?"], "split": "eval"}
{"id": "avl_tree_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Deleting min from an empty tree should raise an error.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      avl-empty\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: Deleting min from an empty tree should raise an error.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      avl-empty\n      (if (avl-empty? (avl-left tree))\n          (avl-right tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Deleting min from an empty tree should raise an error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-min-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: When left child is empty, the node should be replaced by its right subtree.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-left tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `avl-delete-min-by` in `lattice/data/avl-tree.ss`.\nKnown issue: When left child is empty, the node should be replaced by its right subtree.\n\n```scheme\n(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n      (if (avl-empty? (avl-left tree))\n          (avl-left tree)\n          (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)))\n(let () (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))", "verify_expr": "(let ()\n  (define avl-empty 'avl-empty)\n  (define (avl-empty? tree)\n  (eq? tree 'avl-empty))\n  (define (avl-node height key value left right)\n  (list 'avl-node height key value left right))\n  (define (avl-height tree)\n  (if (avl-empty? tree) 0 (cadr tree)))\n  (define (make-avl-node key value left right)\n  (avl-node (+ 1 (max (avl-height left) (avl-height right)))\n            key value left right))\n  (define (avl-key tree)\n  (caddr tree))\n  (define (avl-value tree)\n  (cadddr tree))\n  (define (avl-left tree)\n  (car (cddddr tree)))\n  (define (avl-right tree)\n  (cadr (cddddr tree)))\n  (define (avl-balance-factor tree)\n  (if (avl-empty? tree)\n      0\n      (- (avl-height (avl-left tree))\n         (avl-height (avl-right tree)))))\n  (define (rotate-left tree)\n  (let ([x-key (avl-key tree)]\n        [x-val (avl-value tree)]\n        [a (avl-left tree)]\n        [y (avl-right tree)])\n    (let ([y-key (avl-key y)]\n          [y-val (avl-value y)]\n          [b (avl-left y)]\n          [c (avl-right y)])\n      (make-avl-node y-key y-val\n                     (make-avl-node x-key x-val a b)\n                     c))))\n  (define (rotate-right tree)\n  (let ([y-key (avl-key tree)]\n        [y-val (avl-value tree)]\n        [x (avl-left tree)]\n        [c (avl-right tree)])\n    (let ([x-key (avl-key x)]\n          [x-val (avl-value x)]\n          [a (avl-left x)]\n          [b (avl-right x)])\n      (make-avl-node x-key x-val\n                     a\n                     (make-avl-node y-key y-val b c)))))\n  (define (rebalance tree)\n  (let ([bf (avl-balance-factor tree)])\n    (cond\n      [(> bf 1)\n       (if (< (avl-balance-factor (avl-left tree)) 0)\n           (rotate-right (make-avl-node (avl-key tree) (avl-value tree)\n                                        (rotate-left (avl-left tree))\n                                        (avl-right tree)))\n           (rotate-right tree))]\n      [(< bf -1)\n       (if (> (avl-balance-factor (avl-right tree)) 0)\n           (rotate-left (make-avl-node (avl-key tree) (avl-value tree)\n                                       (avl-left tree)\n                                       (rotate-right (avl-right tree))))\n           (rotate-left tree))]\n      [else tree])))\n  (define (avl-insert-by cmp key value tree)\n  (if (avl-empty? tree)\n      (make-avl-node key value avl-empty avl-empty)\n      (let ([k (avl-key tree)]\n            [v (avl-value tree)]\n            [left (avl-left tree)]\n            [right (avl-right tree)])\n        (cond\n          [(cmp key k)\n           (rebalance (make-avl-node k v (avl-insert-by cmp key value left) right))]\n          [(cmp k key)\n           (rebalance (make-avl-node k v left (avl-insert-by cmp key value right)))]\n          [else\n           (make-avl-node key value left right)]))))\n  (define (avl-insert key value tree)\n  (avl-insert-by < key value tree))\n  (define (list->avl lst)\n  (fold-left (lambda (tree pair)\n               (avl-insert (car pair) (cdr pair) tree))\n             avl-empty\n             lst))\n  (define (avl->list tree)\n  (if (avl-empty? tree)\n      '()\n      (append (avl->list (avl-left tree))\n              (list (cons (avl-key tree) (avl-value tree)))\n              (avl->list (avl-right tree)))))\n  (define (avl-keys tree)\n  (map car (avl->list tree)))\n  (define (avl-delete-min-by cmp tree)\n  (if (avl-empty? tree)\n      (error 'avl-delete-min \"Cannot delete from empty tree\")\n          (if (avl-empty? (avl-left tree))\n              (avl-right tree)\n              (rebalance (make-avl-node (avl-key tree) (avl-value tree)\n                                    (avl-delete-min-by cmp (avl-left tree))\n                                    (avl-right tree))))))\n  (and (equal? (avl-keys (avl-delete-min-by < (list->avl '((4 . \"d\") (2 . \"b\") (6 . \"f\") (1 . \"a\"))))) '(2 4 6)) (guard (ex [else #t]) (begin (avl-delete-min-by < avl-empty) #f))))", "tags": ["tier0", "data", "avl-tree", "bugfix", "avl-delete-min-by"], "split": "eval"}
{"id": "avl_tree_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "make-avl-node", "prompt_body": "Return #t iff make-avl-node preserves the provided left and right subtrees.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff make-avl-node preserves the provided left and right subtrees.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r)))", "verify_expr": "(equal? (let* ([l (avl-node 1 1 \"a\" avl-empty avl-empty)] [r (avl-node 1 3 \"c\" avl-empty avl-empty)] [n (make-avl-node 2 \"b\" l r)]) (and (equal? (avl-left n) l) (equal? (avl-right n) r))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "make-avl-node", "property"], "split": "eval"}
{"id": "avl_tree_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "rebalance", "prompt_body": "Call rebalance on an already balanced tree and confirm invariants still hold.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCall rebalance on an already balanced tree and confirm invariants still hold.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3))))", "verify_expr": "(equal? (let* ([t (list->avl '((2 . \"b\") (1 . \"a\") (3 . \"c\")))] [r (rebalance t)]) (and (avl-valid? r) (avl-bst-valid? r) (equal? (avl-keys r) '(1 2 3)))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "rebalance", "invariant"], "split": "eval"}
{"id": "avl_tree_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-lookup-by", "prompt_body": "Look up key 7 in a small AVL tree built from association pairs.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLook up key 7 in a small AVL tree built from association pairs.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(avl-lookup-by < 7 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\"))))", "verify_expr": "(equal? (avl-lookup-by < 7 (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\")))) \"g\")", "tags": ["tier0", "data", "avl-tree", "composition", "avl-lookup-by", "direct"], "split": "eval"}
{"id": "avl_tree_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-insert-by", "prompt_body": "Insert keys 0..19 and return whether AVL and BST invariants plus a height bound hold.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert keys 0..19 and return whether AVL and BST invariants plus a height bound hold.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([t (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty (iota 20))]) (and (avl-valid? t) (avl-bst-valid? t) (<= (avl-height t) 7)))", "verify_expr": "(equal? (let ([t (fold-left (lambda (acc k) (avl-insert-by < k k acc)) avl-empty (iota 20))]) (and (avl-valid? t) (avl-bst-valid? t) (<= (avl-height t) 7))) #t)", "tags": ["tier0", "data", "avl-tree", "composition", "avl-insert-by", "invariant", "stress"], "split": "eval"}
{"id": "avl_tree_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-delete-by", "prompt_body": "Delete root key 5 from a full tree and return remaining keys.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDelete root key 5 from a full tree and return remaining keys.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))]) (avl-keys (avl-delete-by < 5 t)))", "verify_expr": "(equal? (let ([t (list->avl '((5 . \"e\") (3 . \"c\") (7 . \"g\") (2 . \"b\") (4 . \"d\") (6 . \"f\") (8 . \"h\")))]) (avl-keys (avl-delete-by < 5 t))) '(2 3 4 6 7 8))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-delete-by", "direct", "two-children"], "split": "eval"}
{"id": "avl_tree_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/avl-tree.ss", "source_test": "lattice/data/test-avl-tree.ss", "source_function": "avl-range-by", "prompt_body": "Return keys extracted from range [4,10] over a five-element tree.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn keys extracted from range [4,10] over a five-element tree.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\")))))", "verify_expr": "(equal? (map car (avl-range-by < 4 10 (list->avl '((1 . \"a\") (4 . \"d\") (6 . \"f\") (10 . \"j\") (12 . \"l\"))))) '(4 6 10))", "tags": ["tier0", "data", "avl-tree", "composition", "avl-range-by", "integration"], "split": "eval"}
